// Generated from grammar/SyslParser.g4 by ANTLR 4.7.

package parser // SyslParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 144, 1676,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 3, 2, 3, 2, 3, 2, 3, 2, 7, 2, 365, 10,
	2, 12, 2, 14, 2, 368, 11, 2, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 374, 10, 3,
	3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 7, 4, 381, 10, 4, 12, 4, 14, 4, 384, 11,
	4, 3, 5, 3, 5, 3, 5, 3, 5, 3, 6, 3, 6, 3, 7, 3, 7, 3, 7, 6, 7, 395, 10,
	7, 13, 7, 14, 7, 396, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10,
	3, 10, 7, 10, 408, 10, 10, 12, 10, 14, 10, 411, 11, 10, 3, 10, 3, 10, 3,
	11, 3, 11, 3, 11, 3, 11, 7, 11, 419, 10, 11, 12, 11, 14, 11, 422, 11, 11,
	3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 431, 10, 12, 3,
	13, 3, 13, 3, 13, 3, 13, 7, 13, 437, 10, 13, 12, 13, 14, 13, 440, 11, 13,
	3, 13, 3, 13, 3, 14, 3, 14, 5, 14, 446, 10, 14, 3, 15, 3, 15, 3, 15, 3,
	15, 7, 15, 452, 10, 15, 12, 15, 14, 15, 455, 11, 15, 3, 15, 3, 15, 3, 16,
	3, 16, 3, 17, 3, 17, 3, 17, 5, 17, 464, 10, 17, 3, 18, 3, 18, 5, 18, 468,
	10, 18, 3, 19, 3, 19, 3, 19, 5, 19, 473, 10, 19, 3, 20, 3, 20, 5, 20, 477,
	10, 20, 3, 21, 3, 21, 3, 21, 5, 21, 482, 10, 21, 3, 22, 3, 22, 5, 22, 486,
	10, 22, 3, 23, 3, 23, 3, 23, 6, 23, 491, 10, 23, 13, 23, 14, 23, 492, 3,
	23, 3, 23, 3, 24, 3, 24, 3, 24, 5, 24, 500, 10, 24, 3, 25, 3, 25, 3, 25,
	3, 25, 3, 25, 3, 26, 3, 26, 6, 26, 509, 10, 26, 13, 26, 14, 26, 510, 3,
	26, 3, 26, 3, 27, 3, 27, 3, 27, 3, 27, 5, 27, 519, 10, 27, 5, 27, 521,
	10, 27, 3, 27, 5, 27, 524, 10, 27, 3, 27, 5, 27, 527, 10, 27, 3, 27, 3,
	27, 5, 27, 531, 10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 537, 10, 28,
	3, 28, 3, 28, 3, 29, 3, 29, 6, 29, 543, 10, 29, 13, 29, 14, 29, 544, 3,
	29, 3, 29, 3, 30, 3, 30, 5, 30, 551, 10, 30, 3, 30, 3, 30, 3, 30, 5, 30,
	556, 10, 30, 3, 30, 5, 30, 559, 10, 30, 5, 30, 561, 10, 30, 3, 31, 3, 31,
	3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 6, 32, 571, 10, 32, 13, 32, 14,
	32, 572, 3, 32, 3, 32, 3, 33, 5, 33, 578, 10, 33, 3, 33, 3, 33, 3, 33,
	5, 33, 583, 10, 33, 3, 34, 7, 34, 586, 10, 34, 12, 34, 14, 34, 589, 11,
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 35, 7, 35, 596, 10, 35, 12, 35, 14,
	35, 599, 11, 35, 3, 35, 3, 35, 3, 35, 5, 35, 604, 10, 35, 3, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 6, 35, 613, 10, 35, 13, 35, 14, 35,
	614, 3, 35, 5, 35, 618, 10, 35, 3, 36, 3, 36, 3, 37, 3, 37, 3, 37, 3, 38,
	3, 38, 7, 38, 627, 10, 38, 12, 38, 14, 38, 630, 11, 38, 3, 39, 3, 39, 5,
	39, 634, 10, 39, 3, 39, 5, 39, 637, 10, 39, 3, 40, 3, 40, 3, 40, 3, 41,
	3, 41, 3, 41, 3, 41, 5, 41, 646, 10, 41, 6, 41, 648, 10, 41, 13, 41, 14,
	41, 649, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 5, 42, 657, 10, 42, 3, 43,
	7, 43, 660, 10, 43, 12, 43, 14, 43, 663, 11, 43, 3, 43, 3, 43, 3, 43, 3,
	43, 6, 43, 669, 10, 43, 13, 43, 14, 43, 670, 3, 43, 3, 43, 3, 44, 3, 44,
	3, 44, 3, 44, 3, 44, 3, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 5, 46, 690, 10, 46, 3, 46, 5, 46, 693, 10, 46, 3, 47,
	3, 47, 3, 47, 3, 47, 7, 47, 699, 10, 47, 12, 47, 14, 47, 702, 11, 47, 3,
	48, 3, 48, 5, 48, 706, 10, 48, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49,
	5, 49, 714, 10, 49, 3, 49, 3, 49, 3, 50, 3, 50, 3, 51, 3, 51, 3, 51, 5,
	51, 723, 10, 51, 3, 52, 3, 52, 6, 52, 727, 10, 52, 13, 52, 14, 52, 728,
	5, 52, 731, 10, 52, 3, 53, 3, 53, 3, 53, 7, 53, 736, 10, 53, 12, 53, 14,
	53, 739, 11, 53, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 56, 3, 56, 3, 57,
	3, 57, 6, 57, 750, 10, 57, 13, 57, 14, 57, 751, 3, 57, 3, 57, 3, 57, 3,
	57, 5, 57, 758, 10, 57, 5, 57, 760, 10, 57, 3, 58, 3, 58, 3, 58, 3, 58,
	7, 58, 766, 10, 58, 12, 58, 14, 58, 769, 11, 58, 3, 58, 3, 58, 3, 59, 3,
	59, 3, 59, 3, 59, 5, 59, 777, 10, 59, 3, 59, 3, 59, 5, 59, 781, 10, 59,
	3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 7, 60, 788, 10, 60, 12, 60, 14, 60,
	791, 11, 60, 3, 60, 3, 60, 3, 61, 3, 61, 5, 61, 797, 10, 61, 3, 61, 3,
	61, 3, 61, 7, 61, 802, 10, 61, 12, 61, 14, 61, 805, 11, 61, 3, 61, 3, 61,
	3, 62, 3, 62, 7, 62, 811, 10, 62, 12, 62, 14, 62, 814, 11, 62, 3, 63, 3,
	63, 3, 63, 3, 63, 3, 63, 7, 63, 821, 10, 63, 12, 63, 14, 63, 824, 11, 63,
	3, 63, 3, 63, 3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 3, 65, 6, 65, 834, 10,
	65, 13, 65, 14, 65, 835, 3, 65, 3, 65, 3, 66, 6, 66, 841, 10, 66, 13, 66,
	14, 66, 842, 3, 67, 5, 67, 846, 10, 67, 3, 67, 3, 67, 3, 67, 6, 67, 851,
	10, 67, 13, 67, 14, 67, 852, 3, 67, 3, 67, 3, 68, 3, 68, 3, 68, 3, 68,
	6, 68, 861, 10, 68, 13, 68, 14, 68, 862, 3, 68, 3, 68, 3, 69, 3, 69, 3,
	69, 3, 69, 3, 69, 5, 69, 872, 10, 69, 3, 69, 5, 69, 875, 10, 69, 3, 70,
	3, 70, 3, 70, 3, 71, 3, 71, 5, 71, 882, 10, 71, 3, 72, 3, 72, 3, 72, 7,
	72, 887, 10, 72, 12, 72, 14, 72, 890, 11, 72, 3, 73, 3, 73, 3, 73, 3, 73,
	3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 905,
	10, 74, 3, 74, 5, 74, 908, 10, 74, 3, 75, 3, 75, 5, 75, 912, 10, 75, 3,
	75, 5, 75, 915, 10, 75, 3, 75, 5, 75, 918, 10, 75, 3, 75, 3, 75, 3, 75,
	6, 75, 923, 10, 75, 13, 75, 14, 75, 924, 3, 75, 3, 75, 3, 76, 3, 76, 3,
	77, 3, 77, 3, 77, 5, 77, 934, 10, 77, 3, 77, 5, 77, 937, 10, 77, 3, 77,
	5, 77, 940, 10, 77, 3, 77, 3, 77, 3, 77, 3, 77, 6, 77, 946, 10, 77, 13,
	77, 14, 77, 947, 3, 77, 3, 77, 5, 77, 952, 10, 77, 5, 77, 954, 10, 77,
	3, 78, 3, 78, 5, 78, 958, 10, 78, 3, 78, 3, 78, 3, 78, 3, 78, 6, 78, 964,
	10, 78, 13, 78, 14, 78, 965, 3, 78, 3, 78, 3, 79, 3, 79, 3, 79, 3, 79,
	5, 79, 974, 10, 79, 3, 80, 3, 80, 3, 80, 3, 80, 7, 80, 980, 10, 80, 12,
	80, 14, 80, 983, 11, 80, 3, 81, 3, 81, 3, 81, 3, 81, 3, 82, 3, 82, 3, 82,
	3, 82, 3, 82, 5, 82, 994, 10, 82, 3, 83, 3, 83, 6, 83, 998, 10, 83, 13,
	83, 14, 83, 999, 3, 83, 5, 83, 1003, 10, 83, 3, 84, 3, 84, 3, 84, 3, 85,
	3, 85, 3, 86, 3, 86, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 88, 3,
	88, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1024, 10, 89, 3, 89, 3, 89, 3, 90,
	3, 90, 3, 90, 3, 90, 3, 90, 6, 90, 1033, 10, 90, 13, 90, 14, 90, 1034,
	3, 90, 3, 90, 5, 90, 1039, 10, 90, 3, 91, 3, 91, 3, 91, 5, 91, 1044, 10,
	91, 3, 91, 5, 91, 1047, 10, 91, 3, 91, 3, 91, 3, 91, 3, 91, 6, 91, 1053,
	10, 91, 13, 91, 14, 91, 1054, 3, 91, 3, 91, 5, 91, 1059, 10, 91, 3, 92,
	3, 92, 3, 92, 3, 92, 5, 92, 1065, 10, 92, 3, 92, 3, 92, 3, 92, 3, 92, 6,
	92, 1071, 10, 92, 13, 92, 14, 92, 1072, 3, 92, 3, 92, 5, 92, 1077, 10,
	92, 3, 93, 3, 93, 5, 93, 1081, 10, 93, 3, 94, 3, 94, 3, 95, 3, 95, 5, 95,
	1087, 10, 95, 3, 95, 3, 95, 3, 96, 3, 96, 3, 97, 3, 97, 3, 97, 7, 97, 1096,
	10, 97, 12, 97, 14, 97, 1099, 11, 97, 3, 98, 3, 98, 3, 98, 5, 98, 1104,
	10, 98, 3, 98, 3, 98, 3, 99, 3, 99, 5, 99, 1110, 10, 99, 3, 100, 3, 100,
	3, 100, 7, 100, 1115, 10, 100, 12, 100, 14, 100, 1118, 11, 100, 3, 101,
	3, 101, 3, 101, 3, 101, 3, 101, 5, 101, 1125, 10, 101, 3, 101, 3, 101,
	3, 101, 3, 101, 3, 101, 3, 101, 3, 102, 3, 102, 3, 102, 5, 102, 1136, 10,
	102, 3, 102, 3, 102, 3, 102, 3, 103, 3, 103, 3, 103, 3, 104, 3, 104, 5,
	104, 1146, 10, 104, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 5, 105, 1153,
	10, 105, 3, 105, 3, 105, 3, 105, 3, 106, 3, 106, 3, 107, 3, 107, 3, 107,
	5, 107, 1163, 10, 107, 3, 107, 3, 107, 3, 107, 3, 108, 3, 108, 3, 108,
	3, 108, 3, 108, 3, 109, 3, 109, 3, 110, 3, 110, 3, 111, 3, 111, 3, 112,
	5, 112, 1180, 10, 112, 3, 112, 3, 112, 3, 113, 5, 113, 1185, 10, 113, 3,
	113, 3, 113, 5, 113, 1189, 10, 113, 3, 113, 3, 113, 3, 113, 5, 113, 1194,
	10, 113, 3, 114, 3, 114, 3, 114, 3, 114, 5, 114, 1200, 10, 114, 3, 115,
	3, 115, 3, 115, 3, 115, 7, 115, 1206, 10, 115, 12, 115, 14, 115, 1209,
	11, 115, 3, 115, 3, 115, 3, 116, 5, 116, 1214, 10, 116, 3, 116, 3, 116,
	5, 116, 1218, 10, 116, 3, 116, 3, 116, 3, 116, 3, 117, 3, 117, 3, 117,
	3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 5, 117,
	1234, 10, 117, 3, 118, 3, 118, 3, 119, 3, 119, 3, 119, 7, 119, 1241, 10,
	119, 12, 119, 14, 119, 1244, 11, 119, 3, 120, 3, 120, 3, 120, 3, 120, 3,
	121, 3, 121, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3,
	122, 3, 122, 3, 122, 3, 122, 5, 122, 1263, 10, 122, 3, 123, 3, 123, 3,
	123, 3, 123, 5, 123, 1269, 10, 123, 3, 124, 3, 124, 3, 125, 3, 125, 3,
	125, 3, 125, 3, 126, 3, 126, 3, 126, 3, 126, 3, 127, 3, 127, 3, 127, 3,
	127, 3, 127, 3, 127, 3, 127, 3, 127, 5, 127, 1289, 10, 127, 3, 128, 3,
	128, 7, 128, 1293, 10, 128, 12, 128, 14, 128, 1296, 11, 128, 3, 129, 3,
	129, 3, 129, 3, 130, 3, 130, 5, 130, 1303, 10, 130, 3, 131, 5, 131, 1306,
	10, 131, 3, 131, 3, 131, 3, 132, 3, 132, 3, 132, 3, 133, 3, 133, 7, 133,
	1315, 10, 133, 12, 133, 14, 133, 1318, 11, 133, 3, 134, 3, 134, 3, 134,
	3, 135, 3, 135, 7, 135, 1325, 10, 135, 12, 135, 14, 135, 1328, 11, 135,
	3, 136, 3, 136, 3, 137, 3, 137, 3, 137, 3, 137, 7, 137, 1336, 10, 137,
	12, 137, 14, 137, 1339, 11, 137, 3, 138, 3, 138, 3, 138, 7, 138, 1344,
	10, 138, 12, 138, 14, 138, 1347, 11, 138, 3, 139, 3, 139, 3, 139, 7, 139,
	1352, 10, 139, 12, 139, 14, 139, 1355, 11, 139, 3, 140, 3, 140, 3, 140,
	7, 140, 1360, 10, 140, 12, 140, 14, 140, 1363, 11, 140, 3, 141, 3, 141,
	3, 141, 7, 141, 1368, 10, 141, 12, 141, 14, 141, 1371, 11, 141, 3, 142,
	3, 142, 3, 142, 7, 142, 1376, 10, 142, 12, 142, 14, 142, 1379, 11, 142,
	3, 143, 3, 143, 3, 143, 7, 143, 1384, 10, 143, 12, 143, 14, 143, 1387,
	11, 143, 3, 144, 3, 144, 3, 144, 7, 144, 1392, 10, 144, 12, 144, 14, 144,
	1395, 11, 144, 3, 145, 3, 145, 5, 145, 1399, 10, 145, 3, 145, 3, 145, 3,
	145, 3, 145, 3, 145, 3, 146, 3, 146, 3, 146, 3, 147, 3, 147, 3, 148, 3,
	148, 3, 148, 7, 148, 1414, 10, 148, 12, 148, 14, 148, 1417, 11, 148, 3,
	149, 3, 149, 3, 149, 3, 149, 3, 149, 5, 149, 1424, 10, 149, 3, 150, 3,
	150, 3, 150, 3, 150, 5, 150, 1430, 10, 150, 3, 151, 3, 151, 3, 151, 3,
	152, 5, 152, 1436, 10, 152, 3, 152, 3, 152, 3, 152, 3, 152, 6, 152, 1442,
	10, 152, 13, 152, 14, 152, 1443, 3, 152, 5, 152, 1447, 10, 152, 3, 152,
	3, 152, 3, 153, 3, 153, 3, 153, 3, 153, 3, 153, 5, 153, 1456, 10, 153,
	3, 154, 3, 154, 3, 154, 3, 154, 5, 154, 1462, 10, 154, 3, 155, 3, 155,
	3, 155, 3, 155, 3, 155, 3, 155, 3, 155, 5, 155, 1471, 10, 155, 3, 156,
	3, 156, 3, 156, 3, 156, 3, 157, 3, 157, 3, 157, 3, 157, 3, 157, 3, 158,
	3, 158, 3, 158, 3, 158, 3, 158, 3, 159, 3, 159, 3, 160, 3, 160, 3, 161,
	3, 161, 3, 161, 3, 161, 3, 161, 3, 161, 3, 161, 3, 161, 3, 161, 5, 161,
	1500, 10, 161, 3, 161, 3, 161, 5, 161, 1504, 10, 161, 3, 162, 3, 162, 3,
	162, 3, 162, 3, 162, 3, 163, 3, 163, 3, 163, 5, 163, 1514, 10, 163, 3,
	164, 3, 164, 3, 164, 5, 164, 1519, 10, 164, 3, 165, 3, 165, 3, 166, 3,
	166, 3, 167, 3, 167, 3, 168, 5, 168, 1528, 10, 168, 3, 168, 3, 168, 3,
	168, 3, 168, 3, 168, 5, 168, 1535, 10, 168, 3, 168, 3, 168, 5, 168, 1539,
	10, 168, 3, 168, 3, 168, 3, 168, 3, 168, 6, 168, 1545, 10, 168, 13, 168,
	14, 168, 1546, 3, 168, 3, 168, 3, 168, 3, 168, 3, 169, 3, 169, 3, 169,
	3, 169, 3, 170, 3, 170, 3, 170, 3, 170, 3, 171, 3, 171, 3, 171, 7, 171,
	1564, 10, 171, 12, 171, 14, 171, 1567, 11, 171, 3, 172, 3, 172, 3, 173,
	3, 173, 3, 173, 3, 173, 3, 173, 3, 173, 3, 173, 5, 173, 1578, 10, 173,
	3, 173, 5, 173, 1581, 10, 173, 3, 173, 3, 173, 3, 173, 3, 173, 3, 173,
	5, 173, 1588, 10, 173, 3, 174, 3, 174, 3, 174, 5, 174, 1593, 10, 174, 3,
	174, 3, 174, 3, 174, 7, 174, 1598, 10, 174, 12, 174, 14, 174, 1601, 11,
	174, 3, 174, 3, 174, 5, 174, 1605, 10, 174, 3, 174, 3, 174, 3, 175, 3,
	175, 3, 175, 3, 175, 3, 175, 3, 175, 3, 175, 3, 175, 3, 175, 3, 175, 3,
	175, 3, 175, 3, 175, 3, 175, 3, 175, 3, 175, 6, 175, 1625, 10, 175, 13,
	175, 14, 175, 1626, 3, 175, 3, 175, 5, 175, 1631, 10, 175, 3, 176, 7, 176,
	1634, 10, 176, 12, 176, 14, 176, 1637, 11, 176, 3, 176, 3, 176, 3, 176,
	3, 176, 3, 177, 5, 177, 1644, 10, 177, 3, 177, 3, 177, 3, 177, 7, 177,
	1649, 10, 177, 12, 177, 14, 177, 1652, 11, 177, 3, 178, 3, 178, 7, 178,
	1656, 10, 178, 12, 178, 14, 178, 1659, 11, 178, 3, 179, 6, 179, 1662, 10,
	179, 13, 179, 14, 179, 1663, 3, 180, 5, 180, 1667, 10, 180, 3, 180, 6,
	180, 1670, 10, 180, 13, 180, 14, 180, 1671, 3, 180, 3, 180, 3, 180, 2,
	2, 181, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
	36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70,
	72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
	106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
	136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164,
	166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194,
	196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,
	226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254,
	256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284,
	286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314,
	316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344,
	346, 348, 350, 352, 354, 356, 358, 2, 20, 4, 2, 62, 63, 140, 140, 4, 2,
	43, 43, 141, 141, 3, 2, 8, 9, 4, 2, 8, 9, 11, 11, 4, 2, 16, 18, 20, 22,
	4, 2, 59, 59, 62, 63, 4, 2, 117, 119, 135, 138, 4, 2, 87, 87, 141, 141,
	5, 2, 5, 5, 134, 134, 140, 140, 3, 2, 123, 124, 4, 2, 130, 130, 132, 132,
	3, 2, 121, 122, 4, 2, 75, 75, 140, 141, 5, 2, 96, 96, 99, 99, 101, 102,
	4, 2, 97, 98, 110, 110, 4, 2, 96, 96, 99, 99, 4, 2, 78, 79, 82, 83, 4,
	2, 106, 106, 108, 108, 2, 1739, 2, 360, 3, 2, 2, 2, 4, 369, 3, 2, 2, 2,
	6, 377, 3, 2, 2, 2, 8, 385, 3, 2, 2, 2, 10, 389, 3, 2, 2, 2, 12, 391, 3,
	2, 2, 2, 14, 398, 3, 2, 2, 2, 16, 401, 3, 2, 2, 2, 18, 403, 3, 2, 2, 2,
	20, 414, 3, 2, 2, 2, 22, 425, 3, 2, 2, 2, 24, 432, 3, 2, 2, 2, 26, 445,
	3, 2, 2, 2, 28, 447, 3, 2, 2, 2, 30, 458, 3, 2, 2, 2, 32, 463, 3, 2, 2,
	2, 34, 467, 3, 2, 2, 2, 36, 469, 3, 2, 2, 2, 38, 476, 3, 2, 2, 2, 40, 478,
	3, 2, 2, 2, 42, 485, 3, 2, 2, 2, 44, 487, 3, 2, 2, 2, 46, 499, 3, 2, 2,
	2, 48, 501, 3, 2, 2, 2, 50, 506, 3, 2, 2, 2, 52, 520, 3, 2, 2, 2, 54, 532,
	3, 2, 2, 2, 56, 540, 3, 2, 2, 2, 58, 548, 3, 2, 2, 2, 60, 562, 3, 2, 2,
	2, 62, 564, 3, 2, 2, 2, 64, 577, 3, 2, 2, 2, 66, 587, 3, 2, 2, 2, 68, 597,
	3, 2, 2, 2, 70, 619, 3, 2, 2, 2, 72, 621, 3, 2, 2, 2, 74, 624, 3, 2, 2,
	2, 76, 631, 3, 2, 2, 2, 78, 638, 3, 2, 2, 2, 80, 641, 3, 2, 2, 2, 82, 653,
	3, 2, 2, 2, 84, 661, 3, 2, 2, 2, 86, 674, 3, 2, 2, 2, 88, 680, 3, 2, 2,
	2, 90, 684, 3, 2, 2, 2, 92, 694, 3, 2, 2, 2, 94, 705, 3, 2, 2, 2, 96, 707,
	3, 2, 2, 2, 98, 717, 3, 2, 2, 2, 100, 719, 3, 2, 2, 2, 102, 730, 3, 2,
	2, 2, 104, 732, 3, 2, 2, 2, 106, 740, 3, 2, 2, 2, 108, 743, 3, 2, 2, 2,
	110, 745, 3, 2, 2, 2, 112, 759, 3, 2, 2, 2, 114, 761, 3, 2, 2, 2, 116,
	776, 3, 2, 2, 2, 118, 782, 3, 2, 2, 2, 120, 794, 3, 2, 2, 2, 122, 808,
	3, 2, 2, 2, 124, 815, 3, 2, 2, 2, 126, 827, 3, 2, 2, 2, 128, 829, 3, 2,
	2, 2, 130, 840, 3, 2, 2, 2, 132, 845, 3, 2, 2, 2, 134, 856, 3, 2, 2, 2,
	136, 874, 3, 2, 2, 2, 138, 876, 3, 2, 2, 2, 140, 881, 3, 2, 2, 2, 142,
	883, 3, 2, 2, 2, 144, 891, 3, 2, 2, 2, 146, 904, 3, 2, 2, 2, 148, 909,
	3, 2, 2, 2, 150, 928, 3, 2, 2, 2, 152, 953, 3, 2, 2, 2, 154, 955, 3, 2,
	2, 2, 156, 969, 3, 2, 2, 2, 158, 975, 3, 2, 2, 2, 160, 984, 3, 2, 2, 2,
	162, 993, 3, 2, 2, 2, 164, 997, 3, 2, 2, 2, 166, 1004, 3, 2, 2, 2, 168,
	1007, 3, 2, 2, 2, 170, 1009, 3, 2, 2, 2, 172, 1011, 3, 2, 2, 2, 174, 1017,
	3, 2, 2, 2, 176, 1023, 3, 2, 2, 2, 178, 1027, 3, 2, 2, 2, 180, 1040, 3,
	2, 2, 2, 182, 1060, 3, 2, 2, 2, 184, 1080, 3, 2, 2, 2, 186, 1082, 3, 2,
	2, 2, 188, 1084, 3, 2, 2, 2, 190, 1090, 3, 2, 2, 2, 192, 1092, 3, 2, 2,
	2, 194, 1100, 3, 2, 2, 2, 196, 1107, 3, 2, 2, 2, 198, 1111, 3, 2, 2, 2,
	200, 1119, 3, 2, 2, 2, 202, 1132, 3, 2, 2, 2, 204, 1140, 3, 2, 2, 2, 206,
	1145, 3, 2, 2, 2, 208, 1147, 3, 2, 2, 2, 210, 1157, 3, 2, 2, 2, 212, 1159,
	3, 2, 2, 2, 214, 1167, 3, 2, 2, 2, 216, 1172, 3, 2, 2, 2, 218, 1174, 3,
	2, 2, 2, 220, 1176, 3, 2, 2, 2, 222, 1179, 3, 2, 2, 2, 224, 1184, 3, 2,
	2, 2, 226, 1199, 3, 2, 2, 2, 228, 1201, 3, 2, 2, 2, 230, 1213, 3, 2, 2,
	2, 232, 1233, 3, 2, 2, 2, 234, 1235, 3, 2, 2, 2, 236, 1237, 3, 2, 2, 2,
	238, 1245, 3, 2, 2, 2, 240, 1249, 3, 2, 2, 2, 242, 1251, 3, 2, 2, 2, 244,
	1268, 3, 2, 2, 2, 246, 1270, 3, 2, 2, 2, 248, 1272, 3, 2, 2, 2, 250, 1276,
	3, 2, 2, 2, 252, 1288, 3, 2, 2, 2, 254, 1290, 3, 2, 2, 2, 256, 1297, 3,
	2, 2, 2, 258, 1300, 3, 2, 2, 2, 260, 1305, 3, 2, 2, 2, 262, 1309, 3, 2,
	2, 2, 264, 1312, 3, 2, 2, 2, 266, 1319, 3, 2, 2, 2, 268, 1322, 3, 2, 2,
	2, 270, 1329, 3, 2, 2, 2, 272, 1331, 3, 2, 2, 2, 274, 1340, 3, 2, 2, 2,
	276, 1348, 3, 2, 2, 2, 278, 1356, 3, 2, 2, 2, 280, 1364, 3, 2, 2, 2, 282,
	1372, 3, 2, 2, 2, 284, 1380, 3, 2, 2, 2, 286, 1388, 3, 2, 2, 2, 288, 1396,
	3, 2, 2, 2, 290, 1405, 3, 2, 2, 2, 292, 1408, 3, 2, 2, 2, 294, 1410, 3,
	2, 2, 2, 296, 1418, 3, 2, 2, 2, 298, 1425, 3, 2, 2, 2, 300, 1431, 3, 2,
	2, 2, 302, 1435, 3, 2, 2, 2, 304, 1450, 3, 2, 2, 2, 306, 1461, 3, 2, 2,
	2, 308, 1463, 3, 2, 2, 2, 310, 1472, 3, 2, 2, 2, 312, 1476, 3, 2, 2, 2,
	314, 1481, 3, 2, 2, 2, 316, 1486, 3, 2, 2, 2, 318, 1488, 3, 2, 2, 2, 320,
	1499, 3, 2, 2, 2, 322, 1505, 3, 2, 2, 2, 324, 1513, 3, 2, 2, 2, 326, 1518,
	3, 2, 2, 2, 328, 1520, 3, 2, 2, 2, 330, 1522, 3, 2, 2, 2, 332, 1524, 3,
	2, 2, 2, 334, 1527, 3, 2, 2, 2, 336, 1552, 3, 2, 2, 2, 338, 1556, 3, 2,
	2, 2, 340, 1560, 3, 2, 2, 2, 342, 1568, 3, 2, 2, 2, 344, 1570, 3, 2, 2,
	2, 346, 1589, 3, 2, 2, 2, 348, 1608, 3, 2, 2, 2, 350, 1635, 3, 2, 2, 2,
	352, 1643, 3, 2, 2, 2, 354, 1653, 3, 2, 2, 2, 356, 1661, 3, 2, 2, 2, 358,
	1666, 3, 2, 2, 2, 360, 361, 7, 38, 2, 2, 361, 366, 7, 63, 2, 2, 362, 363,
	7, 36, 2, 2, 363, 365, 7, 63, 2, 2, 364, 362, 3, 2, 2, 2, 365, 368, 3,
	2, 2, 2, 366, 364, 3, 2, 2, 2, 366, 367, 3, 2, 2, 2, 367, 3, 3, 2, 2, 2,
	368, 366, 3, 2, 2, 2, 369, 370, 7, 51, 2, 2, 370, 373, 7, 58, 2, 2, 371,
	372, 7, 43, 2, 2, 372, 374, 7, 58, 2, 2, 373, 371, 3, 2, 2, 2, 373, 374,
	3, 2, 2, 2, 374, 375, 3, 2, 2, 2, 375, 376, 7, 52, 2, 2, 376, 5, 3, 2,
	2, 2, 377, 382, 5, 2, 2, 2, 378, 379, 7, 39, 2, 2, 379, 381, 5, 2, 2, 2,
	380, 378, 3, 2, 2, 2, 381, 384, 3, 2, 2, 2, 382, 380, 3, 2, 2, 2, 382,
	383, 3, 2, 2, 2, 383, 7, 3, 2, 2, 2, 384, 382, 3, 2, 2, 2, 385, 386, 7,
	47, 2, 2, 386, 387, 5, 6, 4, 2, 387, 388, 7, 48, 2, 2, 388, 9, 3, 2, 2,
	2, 389, 390, 9, 2, 2, 2, 390, 11, 3, 2, 2, 2, 391, 394, 5, 74, 38, 2, 392,
	393, 9, 3, 2, 2, 393, 395, 5, 10, 6, 2, 394, 392, 3, 2, 2, 2, 395, 396,
	3, 2, 2, 2, 396, 394, 3, 2, 2, 2, 396, 397, 3, 2, 2, 2, 397, 13, 3, 2,
	2, 2, 398, 399, 7, 55, 2, 2, 399, 400, 7, 70, 2, 2, 400, 15, 3, 2, 2, 2,
	401, 402, 7, 59, 2, 2, 402, 17, 3, 2, 2, 2, 403, 404, 7, 47, 2, 2, 404,
	409, 5, 16, 9, 2, 405, 406, 7, 39, 2, 2, 406, 408, 5, 16, 9, 2, 407, 405,
	3, 2, 2, 2, 408, 411, 3, 2, 2, 2, 409, 407, 3, 2, 2, 2, 409, 410, 3, 2,
	2, 2, 410, 412, 3, 2, 2, 2, 411, 409, 3, 2, 2, 2, 412, 413, 7, 48, 2, 2,
	413, 19, 3, 2, 2, 2, 414, 415, 7, 47, 2, 2, 415, 420, 5, 18, 10, 2, 416,
	417, 7, 39, 2, 2, 417, 419, 5, 18, 10, 2, 418, 416, 3, 2, 2, 2, 419, 422,
	3, 2, 2, 2, 420, 418, 3, 2, 2, 2, 420, 421, 3, 2, 2, 2, 421, 423, 3, 2,
	2, 2, 422, 420, 3, 2, 2, 2, 423, 424, 7, 48, 2, 2, 424, 21, 3, 2, 2, 2,
	425, 426, 7, 63, 2, 2, 426, 430, 7, 40, 2, 2, 427, 431, 5, 16, 9, 2, 428,
	431, 5, 18, 10, 2, 429, 431, 5, 20, 11, 2, 430, 427, 3, 2, 2, 2, 430, 428,
	3, 2, 2, 2, 430, 429, 3, 2, 2, 2, 431, 23, 3, 2, 2, 2, 432, 433, 7, 47,
	2, 2, 433, 438, 5, 22, 12, 2, 434, 435, 7, 39, 2, 2, 435, 437, 5, 22, 12,
	2, 436, 434, 3, 2, 2, 2, 437, 440, 3, 2, 2, 2, 438, 436, 3, 2, 2, 2, 438,
	439, 3, 2, 2, 2, 439, 441, 3, 2, 2, 2, 440, 438, 3, 2, 2, 2, 441, 442,
	7, 48, 2, 2, 442, 25, 3, 2, 2, 2, 443, 446, 5, 22, 12, 2, 444, 446, 5,
	2, 2, 2, 445, 443, 3, 2, 2, 2, 445, 444, 3, 2, 2, 2, 446, 27, 3, 2, 2,
	2, 447, 448, 7, 47, 2, 2, 448, 453, 5, 26, 14, 2, 449, 450, 7, 39, 2, 2,
	450, 452, 5, 26, 14, 2, 451, 449, 3, 2, 2, 2, 452, 455, 3, 2, 2, 2, 453,
	451, 3, 2, 2, 2, 453, 454, 3, 2, 2, 2, 454, 456, 3, 2, 2, 2, 455, 453,
	3, 2, 2, 2, 456, 457, 7, 48, 2, 2, 457, 29, 3, 2, 2, 2, 458, 459, 5, 10,
	6, 2, 459, 31, 3, 2, 2, 2, 460, 464, 5, 30, 16, 2, 461, 464, 5, 12, 7,
	2, 462, 464, 7, 5, 2, 2, 463, 460, 3, 2, 2, 2, 463, 461, 3, 2, 2, 2, 463,
	462, 3, 2, 2, 2, 464, 33, 3, 2, 2, 2, 465, 468, 7, 26, 2, 2, 466, 468,
	7, 122, 2, 2, 467, 465, 3, 2, 2, 2, 467, 466, 3, 2, 2, 2, 468, 35, 3, 2,
	2, 2, 469, 470, 5, 34, 18, 2, 470, 472, 5, 32, 17, 2, 471, 473, 5, 4, 3,
	2, 472, 471, 3, 2, 2, 2, 472, 473, 3, 2, 2, 2, 473, 37, 3, 2, 2, 2, 474,
	477, 7, 25, 2, 2, 475, 477, 7, 121, 2, 2, 476, 474, 3, 2, 2, 2, 476, 475,
	3, 2, 2, 2, 477, 39, 3, 2, 2, 2, 478, 479, 5, 38, 20, 2, 479, 481, 5, 32,
	17, 2, 480, 482, 5, 4, 3, 2, 481, 480, 3, 2, 2, 2, 481, 482, 3, 2, 2, 2,
	482, 41, 3, 2, 2, 2, 483, 486, 5, 36, 19, 2, 484, 486, 5, 40, 21, 2, 485,
	483, 3, 2, 2, 2, 485, 484, 3, 2, 2, 2, 486, 43, 3, 2, 2, 2, 487, 488, 7,
	42, 2, 2, 488, 490, 7, 3, 2, 2, 489, 491, 5, 14, 8, 2, 490, 489, 3, 2,
	2, 2, 491, 492, 3, 2, 2, 2, 492, 490, 3, 2, 2, 2, 492, 493, 3, 2, 2, 2,
	493, 494, 3, 2, 2, 2, 494, 495, 7, 4, 2, 2, 495, 45, 3, 2, 2, 2, 496, 500,
	7, 59, 2, 2, 497, 500, 5, 18, 10, 2, 498, 500, 5, 44, 23, 2, 499, 496,
	3, 2, 2, 2, 499, 497, 3, 2, 2, 2, 499, 498, 3, 2, 2, 2, 500, 47, 3, 2,
	2, 2, 501, 502, 7, 45, 2, 2, 502, 503, 7, 72, 2, 2, 503, 504, 7, 40, 2,
	2, 504, 505, 5, 46, 24, 2, 505, 49, 3, 2, 2, 2, 506, 508, 7, 3, 2, 2, 507,
	509, 5, 48, 25, 2, 508, 507, 3, 2, 2, 2, 509, 510, 3, 2, 2, 2, 510, 508,
	3, 2, 2, 2, 510, 511, 3, 2, 2, 2, 511, 512, 3, 2, 2, 2, 512, 513, 7, 4,
	2, 2, 513, 51, 3, 2, 2, 2, 514, 521, 5, 42, 22, 2, 515, 518, 5, 32, 17,
	2, 516, 519, 5, 54, 28, 2, 517, 519, 5, 4, 3, 2, 518, 516, 3, 2, 2, 2,
	518, 517, 3, 2, 2, 2, 518, 519, 3, 2, 2, 2, 519, 521, 3, 2, 2, 2, 520,
	514, 3, 2, 2, 2, 520, 515, 3, 2, 2, 2, 521, 523, 3, 2, 2, 2, 522, 524,
	7, 44, 2, 2, 523, 522, 3, 2, 2, 2, 523, 524, 3, 2, 2, 2, 524, 526, 3, 2,
	2, 2, 525, 527, 5, 28, 15, 2, 526, 525, 3, 2, 2, 2, 526, 527, 3, 2, 2,
	2, 527, 530, 3, 2, 2, 2, 528, 529, 7, 42, 2, 2, 529, 531, 5, 50, 26, 2,
	530, 528, 3, 2, 2, 2, 530, 531, 3, 2, 2, 2, 531, 53, 3, 2, 2, 2, 532, 533,
	7, 51, 2, 2, 533, 534, 7, 58, 2, 2, 534, 536, 7, 24, 2, 2, 535, 537, 7,
	58, 2, 2, 536, 535, 3, 2, 2, 2, 536, 537, 3, 2, 2, 2, 537, 538, 3, 2, 2,
	2, 538, 539, 7, 52, 2, 2, 539, 55, 3, 2, 2, 2, 540, 542, 7, 3, 2, 2, 541,
	543, 5, 58, 30, 2, 542, 541, 3, 2, 2, 2, 543, 544, 3, 2, 2, 2, 544, 542,
	3, 2, 2, 2, 544, 545, 3, 2, 2, 2, 545, 546, 3, 2, 2, 2, 546, 547, 7, 4,
	2, 2, 547, 57, 3, 2, 2, 2, 548, 560, 5, 10, 6, 2, 549, 551, 5, 54, 28,
	2, 550, 549, 3, 2, 2, 2, 550, 551, 3, 2, 2, 2, 551, 552, 3, 2, 2, 2, 552,
	555, 7, 32, 2, 2, 553, 556, 5, 52, 27, 2, 554, 556, 5, 56, 29, 2, 555,
	553, 3, 2, 2, 2, 555, 554, 3, 2, 2, 2, 556, 558, 3, 2, 2, 2, 557, 559,
	7, 59, 2, 2, 558, 557, 3, 2, 2, 2, 558, 559, 3, 2, 2, 2, 559, 561, 3, 2,
	2, 2, 560, 550, 3, 2, 2, 2, 560, 561, 3, 2, 2, 2, 561, 59, 3, 2, 2, 2,
	562, 563, 5, 66, 34, 2, 563, 61, 3, 2, 2, 2, 564, 570, 7, 3, 2, 2, 565,
	571, 7, 61, 2, 2, 566, 571, 5, 58, 30, 2, 567, 571, 5, 48, 25, 2, 568,
	571, 5, 60, 31, 2, 569, 571, 7, 23, 2, 2, 570, 565, 3, 2, 2, 2, 570, 566,
	3, 2, 2, 2, 570, 567, 3, 2, 2, 2, 570, 568, 3, 2, 2, 2, 570, 569, 3, 2,
	2, 2, 571, 572, 3, 2, 2, 2, 572, 570, 3, 2, 2, 2, 572, 573, 3, 2, 2, 2,
	573, 574, 3, 2, 2, 2, 574, 575, 7, 4, 2, 2, 575, 63, 3, 2, 2, 2, 576, 578,
	5, 28, 15, 2, 577, 576, 3, 2, 2, 2, 577, 578, 3, 2, 2, 2, 578, 579, 3,
	2, 2, 2, 579, 582, 7, 42, 2, 2, 580, 583, 7, 23, 2, 2, 581, 583, 5, 62,
	32, 2, 582, 580, 3, 2, 2, 2, 582, 581, 3, 2, 2, 2, 583, 65, 3, 2, 2, 2,
	584, 586, 7, 61, 2, 2, 585, 584, 3, 2, 2, 2, 586, 589, 3, 2, 2, 2, 587,
	585, 3, 2, 2, 2, 587, 588, 3, 2, 2, 2, 588, 590, 3, 2, 2, 2, 589, 587,
	3, 2, 2, 2, 590, 591, 9, 4, 2, 2, 591, 592, 5, 10, 6, 2, 592, 593, 5, 64,
	33, 2, 593, 67, 3, 2, 2, 2, 594, 596, 7, 61, 2, 2, 595, 594, 3, 2, 2, 2,
	596, 599, 3, 2, 2, 2, 597, 595, 3, 2, 2, 2, 597, 598, 3, 2, 2, 2, 598,
	600, 3, 2, 2, 2, 599, 597, 3, 2, 2, 2, 600, 601, 7, 11, 2, 2, 601, 603,
	5, 10, 6, 2, 602, 604, 5, 28, 15, 2, 603, 602, 3, 2, 2, 2, 603, 604, 3,
	2, 2, 2, 604, 605, 3, 2, 2, 2, 605, 617, 7, 42, 2, 2, 606, 618, 7, 23,
	2, 2, 607, 612, 7, 3, 2, 2, 608, 613, 7, 61, 2, 2, 609, 613, 5, 30, 16,
	2, 610, 613, 5, 48, 25, 2, 611, 613, 7, 23, 2, 2, 612, 608, 3, 2, 2, 2,
	612, 609, 3, 2, 2, 2, 612, 610, 3, 2, 2, 2, 612, 611, 3, 2, 2, 2, 613,
	614, 3, 2, 2, 2, 614, 612, 3, 2, 2, 2, 614, 615, 3, 2, 2, 2, 615, 616,
	3, 2, 2, 2, 616, 618, 7, 4, 2, 2, 617, 606, 3, 2, 2, 2, 617, 607, 3, 2,
	2, 2, 618, 69, 3, 2, 2, 2, 619, 620, 5, 10, 6, 2, 620, 71, 3, 2, 2, 2,
	621, 622, 7, 31, 2, 2, 622, 623, 5, 70, 36, 2, 623, 73, 3, 2, 2, 2, 624,
	628, 5, 70, 36, 2, 625, 627, 5, 72, 37, 2, 626, 625, 3, 2, 2, 2, 627, 630,
	3, 2, 2, 2, 628, 626, 3, 2, 2, 2, 628, 629, 3, 2, 2, 2, 629, 75, 3, 2,
	2, 2, 630, 628, 3, 2, 2, 2, 631, 633, 5, 74, 38, 2, 632, 634, 7, 59, 2,
	2, 633, 632, 3, 2, 2, 2, 633, 634, 3, 2, 2, 2, 634, 636, 3, 2, 2, 2, 635,
	637, 5, 28, 15, 2, 636, 635, 3, 2, 2, 2, 636, 637, 3, 2, 2, 2, 637, 77,
	3, 2, 2, 2, 638, 639, 7, 63, 2, 2, 639, 640, 7, 42, 2, 2, 640, 79, 3, 2,
	2, 2, 641, 642, 7, 42, 2, 2, 642, 647, 7, 3, 2, 2, 643, 645, 7, 63, 2,
	2, 644, 646, 5, 28, 15, 2, 645, 644, 3, 2, 2, 2, 645, 646, 3, 2, 2, 2,
	646, 648, 3, 2, 2, 2, 647, 643, 3, 2, 2, 2, 648, 649, 3, 2, 2, 2, 649,
	647, 3, 2, 2, 2, 649, 650, 3, 2, 2, 2, 650, 651, 3, 2, 2, 2, 651, 652,
	7, 4, 2, 2, 652, 81, 3, 2, 2, 2, 653, 654, 9, 5, 2, 2, 654, 656, 7, 63,
	2, 2, 655, 657, 5, 80, 41, 2, 656, 655, 3, 2, 2, 2, 656, 657, 3, 2, 2,
	2, 657, 83, 3, 2, 2, 2, 658, 660, 7, 61, 2, 2, 659, 658, 3, 2, 2, 2, 660,
	663, 3, 2, 2, 2, 661, 659, 3, 2, 2, 2, 661, 662, 3, 2, 2, 2, 662, 664,
	3, 2, 2, 2, 663, 661, 3, 2, 2, 2, 664, 665, 7, 7, 2, 2, 665, 666, 5, 78,
	40, 2, 666, 668, 7, 3, 2, 2, 667, 669, 5, 82, 42, 2, 668, 667, 3, 2, 2,
	2, 669, 670, 3, 2, 2, 2, 670, 668, 3, 2, 2, 2, 670, 671, 3, 2, 2, 2, 671,
	672, 3, 2, 2, 2, 672, 673, 7, 4, 2, 2, 673, 85, 3, 2, 2, 2, 674, 675, 7,
	45, 2, 2, 675, 676, 7, 63, 2, 2, 676, 677, 7, 40, 2, 2, 677, 678, 7, 59,
	2, 2, 678, 679, 7, 60, 2, 2, 679, 87, 3, 2, 2, 2, 680, 681, 7, 49, 2, 2,
	681, 682, 7, 63, 2, 2, 682, 683, 7, 50, 2, 2, 683, 89, 3, 2, 2, 2, 684,
	685, 7, 63, 2, 2, 685, 689, 7, 40, 2, 2, 686, 690, 7, 5, 2, 2, 687, 690,
	5, 10, 6, 2, 688, 690, 5, 88, 45, 2, 689, 686, 3, 2, 2, 2, 689, 687, 3,
	2, 2, 2, 689, 688, 3, 2, 2, 2, 690, 692, 3, 2, 2, 2, 691, 693, 7, 44, 2,
	2, 692, 691, 3, 2, 2, 2, 692, 693, 3, 2, 2, 2, 693, 91, 3, 2, 2, 2, 694,
	695, 7, 44, 2, 2, 695, 700, 5, 90, 46, 2, 696, 697, 7, 46, 2, 2, 697, 699,
	5, 90, 46, 2, 698, 696, 3, 2, 2, 2, 699, 702, 3, 2, 2, 2, 700, 698, 3,
	2, 2, 2, 700, 701, 3, 2, 2, 2, 701, 93, 3, 2, 2, 2, 702, 700, 3, 2, 2,
	2, 703, 706, 5, 10, 6, 2, 704, 706, 7, 58, 2, 2, 705, 703, 3, 2, 2, 2,
	705, 704, 3, 2, 2, 2, 706, 95, 3, 2, 2, 2, 707, 708, 7, 49, 2, 2, 708,
	709, 5, 94, 48, 2, 709, 713, 7, 32, 2, 2, 710, 714, 7, 5, 2, 2, 711, 714,
	5, 10, 6, 2, 712, 714, 5, 12, 7, 2, 713, 710, 3, 2, 2, 2, 713, 711, 3,
	2, 2, 2, 713, 712, 3, 2, 2, 2, 714, 715, 3, 2, 2, 2, 715, 716, 7, 50, 2,
	2, 716, 97, 3, 2, 2, 2, 717, 718, 5, 94, 48, 2, 718, 99, 3, 2, 2, 2, 719,
	722, 7, 41, 2, 2, 720, 723, 5, 98, 50, 2, 721, 723, 5, 96, 49, 2, 722,
	720, 3, 2, 2, 2, 722, 721, 3, 2, 2, 2, 723, 101, 3, 2, 2, 2, 724, 731,
	7, 41, 2, 2, 725, 727, 5, 100, 51, 2, 726, 725, 3, 2, 2, 2, 727, 728, 3,
	2, 2, 2, 728, 726, 3, 2, 2, 2, 728, 729, 3, 2, 2, 2, 729, 731, 3, 2, 2,
	2, 730, 724, 3, 2, 2, 2, 730, 726, 3, 2, 2, 2, 731, 103, 3, 2, 2, 2, 732,
	737, 5, 10, 6, 2, 733, 734, 7, 41, 2, 2, 734, 736, 5, 10, 6, 2, 735, 733,
	3, 2, 2, 2, 736, 739, 3, 2, 2, 2, 737, 735, 3, 2, 2, 2, 737, 738, 3, 2,
	2, 2, 738, 105, 3, 2, 2, 2, 739, 737, 3, 2, 2, 2, 740, 741, 7, 14, 2, 2,
	741, 742, 7, 70, 2, 2, 742, 107, 3, 2, 2, 2, 743, 744, 5, 74, 38, 2, 744,
	109, 3, 2, 2, 2, 745, 746, 5, 10, 6, 2, 746, 111, 3, 2, 2, 2, 747, 750,
	7, 59, 2, 2, 748, 750, 5, 10, 6, 2, 749, 747, 3, 2, 2, 2, 749, 748, 3,
	2, 2, 2, 750, 751, 3, 2, 2, 2, 751, 749, 3, 2, 2, 2, 751, 752, 3, 2, 2,
	2, 752, 760, 3, 2, 2, 2, 753, 754, 5, 10, 6, 2, 754, 757, 7, 32, 2, 2,
	755, 758, 5, 10, 6, 2, 756, 758, 7, 5, 2, 2, 757, 755, 3, 2, 2, 2, 757,
	756, 3, 2, 2, 2, 758, 760, 3, 2, 2, 2, 759, 749, 3, 2, 2, 2, 759, 753,
	3, 2, 2, 2, 760, 113, 3, 2, 2, 2, 761, 762, 7, 51, 2, 2, 762, 767, 5, 112,
	57, 2, 763, 764, 7, 39, 2, 2, 764, 766, 5, 112, 57, 2, 765, 763, 3, 2,
	2, 2, 766, 769, 3, 2, 2, 2, 767, 765, 3, 2, 2, 2, 767, 768, 3, 2, 2, 2,
	768, 770, 3, 2, 2, 2, 769, 767, 3, 2, 2, 2, 770, 771, 7, 52, 2, 2, 771,
	115, 3, 2, 2, 2, 772, 777, 7, 30, 2, 2, 773, 774, 5, 108, 55, 2, 774, 775,
	7, 33, 2, 2, 775, 777, 3, 2, 2, 2, 776, 772, 3, 2, 2, 2, 776, 773, 3, 2,
	2, 2, 777, 778, 3, 2, 2, 2, 778, 780, 5, 110, 56, 2, 779, 781, 5, 114,
	58, 2, 780, 779, 3, 2, 2, 2, 780, 781, 3, 2, 2, 2, 781, 117, 3, 2, 2, 2,
	782, 783, 7, 15, 2, 2, 783, 784, 7, 66, 2, 2, 784, 785, 7, 42, 2, 2, 785,
	789, 7, 3, 2, 2, 786, 788, 5, 146, 74, 2, 787, 786, 3, 2, 2, 2, 788, 791,
	3, 2, 2, 2, 789, 787, 3, 2, 2, 2, 789, 790, 3, 2, 2, 2, 790, 792, 3, 2,
	2, 2, 791, 789, 3, 2, 2, 2, 792, 793, 7, 4, 2, 2, 793, 119, 3, 2, 2, 2,
	794, 796, 7, 19, 2, 2, 795, 797, 7, 66, 2, 2, 796, 795, 3, 2, 2, 2, 796,
	797, 3, 2, 2, 2, 797, 798, 3, 2, 2, 2, 798, 799, 7, 42, 2, 2, 799, 803,
	7, 3, 2, 2, 800, 802, 5, 146, 74, 2, 801, 800, 3, 2, 2, 2, 802, 805, 3,
	2, 2, 2, 803, 801, 3, 2, 2, 2, 803, 804, 3, 2, 2, 2, 804, 806, 3, 2, 2,
	2, 805, 803, 3, 2, 2, 2, 806, 807, 7, 4, 2, 2, 807, 121, 3, 2, 2, 2, 808,
	812, 5, 118, 60, 2, 809, 811, 5, 120, 61, 2, 810, 809, 3, 2, 2, 2, 811,
	814, 3, 2, 2, 2, 812, 810, 3, 2, 2, 2, 812, 813, 3, 2, 2, 2, 813, 123,
	3, 2, 2, 2, 814, 812, 3, 2, 2, 2, 815, 816, 9, 6, 2, 2, 816, 817, 7, 66,
	2, 2, 817, 818, 7, 42, 2, 2, 818, 822, 7, 3, 2, 2, 819, 821, 5, 146, 74,
	2, 820, 819, 3, 2, 2, 2, 821, 824, 3, 2, 2, 2, 822, 820, 3, 2, 2, 2, 822,
	823, 3, 2, 2, 2, 823, 825, 3, 2, 2, 2, 824, 822, 3, 2, 2, 2, 825, 826,
	7, 4, 2, 2, 826, 125, 3, 2, 2, 2, 827, 828, 7, 61, 2, 2, 828, 127, 3, 2,
	2, 2, 829, 830, 5, 10, 6, 2, 830, 831, 7, 42, 2, 2, 831, 833, 7, 3, 2,
	2, 832, 834, 5, 146, 74, 2, 833, 832, 3, 2, 2, 2, 834, 835, 3, 2, 2, 2,
	835, 833, 3, 2, 2, 2, 835, 836, 3, 2, 2, 2, 836, 837, 3, 2, 2, 2, 837,
	838, 7, 4, 2, 2, 838, 129, 3, 2, 2, 2, 839, 841, 9, 7, 2, 2, 840, 839,
	3, 2, 2, 2, 841, 842, 3, 2, 2, 2, 842, 840, 3, 2, 2, 2, 842, 843, 3, 2,
	2, 2, 843, 131, 3, 2, 2, 2, 844, 846, 5, 130, 66, 2, 845, 844, 3, 2, 2,
	2, 845, 846, 3, 2, 2, 2, 846, 847, 3, 2, 2, 2, 847, 848, 7, 42, 2, 2, 848,
	850, 7, 3, 2, 2, 849, 851, 5, 146, 74, 2, 850, 849, 3, 2, 2, 2, 851, 852,
	3, 2, 2, 2, 852, 850, 3, 2, 2, 2, 852, 853, 3, 2, 2, 2, 853, 854, 3, 2,
	2, 2, 854, 855, 7, 4, 2, 2, 855, 133, 3, 2, 2, 2, 856, 857, 7, 27, 2, 2,
	857, 858, 7, 42, 2, 2, 858, 860, 7, 3, 2, 2, 859, 861, 5, 132, 67, 2, 860,
	859, 3, 2, 2, 2, 861, 862, 3, 2, 2, 2, 862, 860, 3, 2, 2, 2, 862, 863,
	3, 2, 2, 2, 863, 864, 3, 2, 2, 2, 864, 865, 7, 4, 2, 2, 865, 135, 3, 2,
	2, 2, 866, 875, 5, 14, 8, 2, 867, 875, 7, 59, 2, 2, 868, 871, 5, 74, 38,
	2, 869, 870, 7, 34, 2, 2, 870, 872, 5, 10, 6, 2, 871, 869, 3, 2, 2, 2,
	871, 872, 3, 2, 2, 2, 872, 875, 3, 2, 2, 2, 873, 875, 7, 23, 2, 2, 874,
	866, 3, 2, 2, 2, 874, 867, 3, 2, 2, 2, 874, 868, 3, 2, 2, 2, 874, 873,
	3, 2, 2, 2, 875, 137, 3, 2, 2, 2, 876, 877, 7, 28, 2, 2, 877, 878, 5, 74,
	38, 2, 878, 139, 3, 2, 2, 2, 879, 882, 5, 12, 7, 2, 880, 882, 5, 58, 30,
	2, 881, 879, 3, 2, 2, 2, 881, 880, 3, 2, 2, 2, 882, 141, 3, 2, 2, 2, 883,
	888, 5, 140, 71, 2, 884, 885, 7, 39, 2, 2, 885, 887, 5, 140, 71, 2, 886,
	884, 3, 2, 2, 2, 887, 890, 3, 2, 2, 2, 888, 886, 3, 2, 2, 2, 888, 889,
	3, 2, 2, 2, 889, 143, 3, 2, 2, 2, 890, 888, 3, 2, 2, 2, 891, 892, 7, 51,
	2, 2, 892, 893, 5, 142, 72, 2, 893, 894, 7, 52, 2, 2, 894, 145, 3, 2, 2,
	2, 895, 905, 5, 122, 62, 2, 896, 905, 5, 124, 63, 2, 897, 905, 5, 106,
	54, 2, 898, 905, 5, 116, 59, 2, 899, 905, 5, 134, 68, 2, 900, 905, 5, 126,
	64, 2, 901, 905, 5, 128, 65, 2, 902, 905, 5, 136, 69, 2, 903, 905, 5, 48,
	25, 2, 904, 895, 3, 2, 2, 2, 904, 896, 3, 2, 2, 2, 904, 897, 3, 2, 2, 2,
	904, 898, 3, 2, 2, 2, 904, 899, 3, 2, 2, 2, 904, 900, 3, 2, 2, 2, 904,
	901, 3, 2, 2, 2, 904, 902, 3, 2, 2, 2, 904, 903, 3, 2, 2, 2, 905, 907,
	3, 2, 2, 2, 906, 908, 5, 28, 15, 2, 907, 906, 3, 2, 2, 2, 907, 908, 3,
	2, 2, 2, 908, 147, 3, 2, 2, 2, 909, 911, 7, 6, 2, 2, 910, 912, 5, 144,
	73, 2, 911, 910, 3, 2, 2, 2, 911, 912, 3, 2, 2, 2, 912, 914, 3, 2, 2, 2,
	913, 915, 5, 92, 47, 2, 914, 913, 3, 2, 2, 2, 914, 915, 3, 2, 2, 2, 915,
	917, 3, 2, 2, 2, 916, 918, 5, 28, 15, 2, 917, 916, 3, 2, 2, 2, 917, 918,
	3, 2, 2, 2, 918, 919, 3, 2, 2, 2, 919, 920, 7, 42, 2, 2, 920, 922, 7, 3,
	2, 2, 921, 923, 5, 146, 74, 2, 922, 921, 3, 2, 2, 2, 923, 924, 3, 2, 2,
	2, 924, 922, 3, 2, 2, 2, 924, 925, 3, 2, 2, 2, 925, 926, 3, 2, 2, 2, 926,
	927, 7, 4, 2, 2, 927, 149, 3, 2, 2, 2, 928, 929, 7, 23, 2, 2, 929, 151,
	3, 2, 2, 2, 930, 954, 7, 23, 2, 2, 931, 933, 5, 104, 53, 2, 932, 934, 7,
	59, 2, 2, 933, 932, 3, 2, 2, 2, 933, 934, 3, 2, 2, 2, 934, 936, 3, 2, 2,
	2, 935, 937, 5, 144, 73, 2, 936, 935, 3, 2, 2, 2, 936, 937, 3, 2, 2, 2,
	937, 939, 3, 2, 2, 2, 938, 940, 5, 28, 15, 2, 939, 938, 3, 2, 2, 2, 939,
	940, 3, 2, 2, 2, 940, 941, 3, 2, 2, 2, 941, 951, 7, 42, 2, 2, 942, 952,
	5, 150, 76, 2, 943, 945, 7, 3, 2, 2, 944, 946, 5, 146, 74, 2, 945, 944,
	3, 2, 2, 2, 946, 947, 3, 2, 2, 2, 947, 945, 3, 2, 2, 2, 947, 948, 3, 2,
	2, 2, 948, 949, 3, 2, 2, 2, 949, 950, 7, 4, 2, 2, 950, 952, 3, 2, 2, 2,
	951, 942, 3, 2, 2, 2, 951, 943, 3, 2, 2, 2, 952, 954, 3, 2, 2, 2, 953,
	930, 3, 2, 2, 2, 953, 931, 3, 2, 2, 2, 954, 153, 3, 2, 2, 2, 955, 957,
	5, 102, 52, 2, 956, 958, 5, 28, 15, 2, 957, 956, 3, 2, 2, 2, 957, 958,
	3, 2, 2, 2, 958, 959, 3, 2, 2, 2, 959, 960, 7, 42, 2, 2, 960, 963, 7, 3,
	2, 2, 961, 964, 5, 148, 75, 2, 962, 964, 5, 154, 78, 2, 963, 961, 3, 2,
	2, 2, 963, 962, 3, 2, 2, 2, 964, 965, 3, 2, 2, 2, 965, 963, 3, 2, 2, 2,
	965, 966, 3, 2, 2, 2, 966, 967, 3, 2, 2, 2, 967, 968, 7, 4, 2, 2, 968,
	155, 3, 2, 2, 2, 969, 970, 5, 10, 6, 2, 970, 973, 7, 40, 2, 2, 971, 974,
	7, 5, 2, 2, 972, 974, 5, 10, 6, 2, 973, 971, 3, 2, 2, 2, 973, 972, 3, 2,
	2, 2, 974, 157, 3, 2, 2, 2, 975, 976, 7, 44, 2, 2, 976, 981, 5, 156, 79,
	2, 977, 978, 7, 46, 2, 2, 978, 980, 5, 156, 79, 2, 979, 977, 3, 2, 2, 2,
	980, 983, 3, 2, 2, 2, 981, 979, 3, 2, 2, 2, 981, 982, 3, 2, 2, 2, 982,
	159, 3, 2, 2, 2, 983, 981, 3, 2, 2, 2, 984, 985, 5, 108, 55, 2, 985, 986,
	7, 33, 2, 2, 986, 987, 5, 110, 56, 2, 987, 161, 3, 2, 2, 2, 988, 994, 5,
	10, 6, 2, 989, 990, 7, 49, 2, 2, 990, 991, 5, 10, 6, 2, 991, 992, 7, 50,
	2, 2, 992, 994, 3, 2, 2, 2, 993, 988, 3, 2, 2, 2, 993, 989, 3, 2, 2, 2,
	994, 163, 3, 2, 2, 2, 995, 996, 7, 41, 2, 2, 996, 998, 5, 162, 82, 2, 997,
	995, 3, 2, 2, 2, 998, 999, 3, 2, 2, 2, 999, 997, 3, 2, 2, 2, 999, 1000,
	3, 2, 2, 2, 1000, 1002, 3, 2, 2, 2, 1001, 1003, 5, 158, 80, 2, 1002, 1001,
	3, 2, 2, 2, 1002, 1003, 3, 2, 2, 2, 1003, 165, 3, 2, 2, 2, 1004, 1005,
	7, 6, 2, 2, 1005, 1006, 5, 164, 83, 2, 1006, 167, 3, 2, 2, 2, 1007, 1008,
	5, 74, 38, 2, 1008, 169, 3, 2, 2, 2, 1009, 1010, 5, 74, 38, 2, 1010, 171,
	3, 2, 2, 2, 1011, 1012, 5, 170, 86, 2, 1012, 1013, 7, 33, 2, 2, 1013, 1014,
	5, 168, 85, 2, 1014, 1015, 7, 34, 2, 2, 1015, 1016, 5, 10, 6, 2, 1016,
	173, 3, 2, 2, 2, 1017, 1018, 5, 10, 6, 2, 1018, 175, 3, 2, 2, 2, 1019,
	1024, 5, 174, 88, 2, 1020, 1024, 5, 160, 81, 2, 1021, 1024, 5, 166, 84,
	2, 1022, 1024, 5, 172, 87, 2, 1023, 1019, 3, 2, 2, 2, 1023, 1020, 3, 2,
	2, 2, 1023, 1021, 3, 2, 2, 2, 1023, 1022, 3, 2, 2, 2, 1024, 1025, 3, 2,
	2, 2, 1025, 1026, 5, 28, 15, 2, 1026, 177, 3, 2, 2, 2, 1027, 1028, 7, 35,
	2, 2, 1028, 1038, 7, 42, 2, 2, 1029, 1039, 7, 23, 2, 2, 1030, 1032, 7,
	3, 2, 2, 1031, 1033, 5, 176, 89, 2, 1032, 1031, 3, 2, 2, 2, 1033, 1034,
	3, 2, 2, 2, 1034, 1032, 3, 2, 2, 2, 1034, 1035, 3, 2, 2, 2, 1035, 1036,
	3, 2, 2, 2, 1036, 1037, 7, 4, 2, 2, 1037, 1039, 3, 2, 2, 2, 1038, 1029,
	3, 2, 2, 2, 1038, 1030, 3, 2, 2, 2, 1039, 179, 3, 2, 2, 2, 1040, 1041,
	7, 29, 2, 2, 1041, 1043, 5, 10, 6, 2, 1042, 1044, 5, 144, 73, 2, 1043,
	1042, 3, 2, 2, 2, 1043, 1044, 3, 2, 2, 2, 1044, 1046, 3, 2, 2, 2, 1045,
	1047, 5, 28, 15, 2, 1046, 1045, 3, 2, 2, 2, 1046, 1047, 3, 2, 2, 2, 1047,
	1048, 3, 2, 2, 2, 1048, 1058, 7, 42, 2, 2, 1049, 1059, 7, 23, 2, 2, 1050,
	1052, 7, 3, 2, 2, 1051, 1053, 5, 146, 74, 2, 1052, 1051, 3, 2, 2, 2, 1053,
	1054, 3, 2, 2, 2, 1054, 1052, 3, 2, 2, 2, 1054, 1055, 3, 2, 2, 2, 1055,
	1056, 3, 2, 2, 2, 1056, 1057, 7, 4, 2, 2, 1057, 1059, 3, 2, 2, 2, 1058,
	1049, 3, 2, 2, 2, 1058, 1050, 3, 2, 2, 2, 1059, 181, 3, 2, 2, 2, 1060,
	1061, 5, 74, 38, 2, 1061, 1062, 7, 34, 2, 2, 1062, 1064, 5, 10, 6, 2, 1063,
	1065, 5, 28, 15, 2, 1064, 1063, 3, 2, 2, 2, 1064, 1065, 3, 2, 2, 2, 1065,
	1066, 3, 2, 2, 2, 1066, 1076, 7, 42, 2, 2, 1067, 1077, 7, 23, 2, 2, 1068,
	1070, 7, 3, 2, 2, 1069, 1071, 5, 146, 74, 2, 1070, 1069, 3, 2, 2, 2, 1071,
	1072, 3, 2, 2, 2, 1072, 1070, 3, 2, 2, 2, 1072, 1073, 3, 2, 2, 2, 1073,
	1074, 3, 2, 2, 2, 1074, 1075, 7, 4, 2, 2, 1075, 1077, 3, 2, 2, 2, 1076,
	1067, 3, 2, 2, 2, 1076, 1068, 3, 2, 2, 2, 1077, 183, 3, 2, 2, 2, 1078,
	1081, 5, 42, 22, 2, 1079, 1081, 5, 32, 17, 2, 1080, 1078, 3, 2, 2, 2, 1080,
	1079, 3, 2, 2, 2, 1081, 185, 3, 2, 2, 2, 1082, 1083, 9, 8, 2, 2, 1083,
	187, 3, 2, 2, 2, 1084, 1086, 9, 9, 2, 2, 1085, 1087, 7, 88, 2, 2, 1086,
	1085, 3, 2, 2, 2, 1086, 1087, 3, 2, 2, 2, 1087, 1088, 3, 2, 2, 2, 1088,
	1089, 7, 140, 2, 2, 1089, 189, 3, 2, 2, 2, 1090, 1091, 5, 306, 154, 2,
	1091, 191, 3, 2, 2, 2, 1092, 1097, 5, 190, 96, 2, 1093, 1094, 7, 94, 2,
	2, 1094, 1096, 5, 190, 96, 2, 1095, 1093, 3, 2, 2, 2, 1096, 1099, 3, 2,
	2, 2, 1097, 1095, 3, 2, 2, 2, 1097, 1098, 3, 2, 2, 2, 1098, 193, 3, 2,
	2, 2, 1099, 1097, 3, 2, 2, 2, 1100, 1101, 9, 10, 2, 2, 1101, 1103, 7, 92,
	2, 2, 1102, 1104, 5, 192, 97, 2, 1103, 1102, 3, 2, 2, 2, 1103, 1104, 3,
	2, 2, 2, 1104, 1105, 3, 2, 2, 2, 1105, 1106, 7, 93, 2, 2, 1106, 195, 3,
	2, 2, 2, 1107, 1109, 5, 306, 154, 2, 1108, 1110, 9, 11, 2, 2, 1109, 1108,
	3, 2, 2, 2, 1109, 1110, 3, 2, 2, 2, 1110, 197, 3, 2, 2, 2, 1111, 1116,
	5, 196, 99, 2, 1112, 1113, 7, 94, 2, 2, 1113, 1115, 5, 196, 99, 2, 1114,
	1112, 3, 2, 2, 2, 1115, 1118, 3, 2, 2, 2, 1116, 1114, 3, 2, 2, 2, 1116,
	1117, 3, 2, 2, 2, 1117, 199, 3, 2, 2, 2, 1118, 1116, 3, 2, 2, 2, 1119,
	1124, 7, 125, 2, 2, 1120, 1121, 7, 82, 2, 2, 1121, 1122, 5, 184, 93, 2,
	1122, 1123, 7, 83, 2, 2, 1123, 1125, 3, 2, 2, 2, 1124, 1120, 3, 2, 2, 2,
	1124, 1125, 3, 2, 2, 2, 1125, 1126, 3, 2, 2, 2, 1126, 1127, 7, 92, 2, 2,
	1127, 1128, 5, 198, 100, 2, 1128, 1129, 7, 111, 2, 2, 1129, 1130, 7, 140,
	2, 2, 1130, 1131, 7, 93, 2, 2, 1131, 201, 3, 2, 2, 2, 1132, 1133, 7, 126,
	2, 2, 1133, 1135, 7, 92, 2, 2, 1134, 1136, 5, 204, 103, 2, 1135, 1134,
	3, 2, 2, 2, 1135, 1136, 3, 2, 2, 2, 1136, 1137, 3, 2, 2, 2, 1137, 1138,
	5, 192, 97, 2, 1138, 1139, 7, 93, 2, 2, 1139, 203, 3, 2, 2, 2, 1140, 1141,
	7, 140, 2, 2, 1141, 1142, 7, 91, 2, 2, 1142, 205, 3, 2, 2, 2, 1143, 1146,
	7, 119, 2, 2, 1144, 1146, 5, 306, 154, 2, 1145, 1143, 3, 2, 2, 2, 1145,
	1144, 3, 2, 2, 2, 1146, 207, 3, 2, 2, 2, 1147, 1148, 7, 133, 2, 2, 1148,
	1149, 5, 206, 104, 2, 1149, 1150, 7, 107, 2, 2, 1150, 1152, 7, 92, 2, 2,
	1151, 1153, 5, 204, 103, 2, 1152, 1151, 3, 2, 2, 2, 1152, 1153, 3, 2, 2,
	2, 1153, 1154, 3, 2, 2, 2, 1154, 1155, 5, 198, 100, 2, 1155, 1156, 7, 93,
	2, 2, 1156, 209, 3, 2, 2, 2, 1157, 1158, 9, 12, 2, 2, 1158, 211, 3, 2,
	2, 2, 1159, 1160, 5, 210, 106, 2, 1160, 1162, 7, 92, 2, 2, 1161, 1163,
	5, 204, 103, 2, 1162, 1161, 3, 2, 2, 2, 1162, 1163, 3, 2, 2, 2, 1163, 1164,
	3, 2, 2, 2, 1164, 1165, 5, 306, 154, 2, 1165, 1166, 7, 93, 2, 2, 1166,
	213, 3, 2, 2, 2, 1167, 1168, 7, 127, 2, 2, 1168, 1169, 7, 92, 2, 2, 1169,
	1170, 5, 306, 154, 2, 1170, 1171, 7, 93, 2, 2, 1171, 215, 3, 2, 2, 2, 1172,
	1173, 7, 128, 2, 2, 1173, 217, 3, 2, 2, 2, 1174, 1175, 7, 129, 2, 2, 1175,
	219, 3, 2, 2, 2, 1176, 1177, 7, 131, 2, 2, 1177, 221, 3, 2, 2, 2, 1178,
	1180, 7, 141, 2, 2, 1179, 1178, 3, 2, 2, 2, 1179, 1180, 3, 2, 2, 2, 1180,
	1181, 3, 2, 2, 2, 1181, 1182, 7, 140, 2, 2, 1182, 223, 3, 2, 2, 2, 1183,
	1185, 7, 100, 2, 2, 1184, 1183, 3, 2, 2, 2, 1184, 1185, 3, 2, 2, 2, 1185,
	1186, 3, 2, 2, 2, 1186, 1188, 7, 77, 2, 2, 1187, 1189, 9, 13, 2, 2, 1188,
	1187, 3, 2, 2, 2, 1188, 1189, 3, 2, 2, 2, 1189, 1190, 3, 2, 2, 2, 1190,
	1193, 5, 222, 112, 2, 1191, 1192, 7, 112, 2, 2, 1192, 1194, 7, 140, 2,
	2, 1193, 1191, 3, 2, 2, 2, 1193, 1194, 3, 2, 2, 2, 1194, 225, 3, 2, 2,
	2, 1195, 1200, 5, 188, 95, 2, 1196, 1200, 5, 224, 113, 2, 1197, 1200, 5,
	248, 125, 2, 1198, 1200, 7, 140, 2, 2, 1199, 1195, 3, 2, 2, 2, 1199, 1196,
	3, 2, 2, 2, 1199, 1197, 3, 2, 2, 2, 1199, 1198, 3, 2, 2, 2, 1200, 227,
	3, 2, 2, 2, 1201, 1202, 7, 80, 2, 2, 1202, 1207, 7, 140, 2, 2, 1203, 1204,
	7, 94, 2, 2, 1204, 1206, 7, 140, 2, 2, 1205, 1203, 3, 2, 2, 2, 1206, 1209,
	3, 2, 2, 2, 1207, 1205, 3, 2, 2, 2, 1207, 1208, 3, 2, 2, 2, 1208, 1210,
	3, 2, 2, 2, 1209, 1207, 3, 2, 2, 2, 1210, 1211, 7, 81, 2, 2, 1211, 229,
	3, 2, 2, 2, 1212, 1214, 7, 102, 2, 2, 1213, 1212, 3, 2, 2, 2, 1213, 1214,
	3, 2, 2, 2, 1214, 1215, 3, 2, 2, 2, 1215, 1217, 7, 101, 2, 2, 1216, 1218,
	5, 228, 115, 2, 1217, 1216, 3, 2, 2, 2, 1217, 1218, 3, 2, 2, 2, 1218, 1219,
	3, 2, 2, 2, 1219, 1220, 7, 83, 2, 2, 1220, 1221, 5, 226, 114, 2, 1221,
	231, 3, 2, 2, 2, 1222, 1234, 5, 188, 95, 2, 1223, 1234, 5, 200, 101, 2,
	1224, 1234, 5, 202, 102, 2, 1225, 1234, 5, 212, 107, 2, 1226, 1234, 5,
	214, 108, 2, 1227, 1234, 5, 220, 111, 2, 1228, 1234, 5, 216, 109, 2, 1229,
	1234, 5, 218, 110, 2, 1230, 1234, 5, 208, 105, 2, 1231, 1234, 5, 224, 113,
	2, 1232, 1234, 5, 230, 116, 2, 1233, 1222, 3, 2, 2, 2, 1233, 1223, 3, 2,
	2, 2, 1233, 1224, 3, 2, 2, 2, 1233, 1225, 3, 2, 2, 2, 1233, 1226, 3, 2,
	2, 2, 1233, 1227, 3, 2, 2, 2, 1233, 1228, 3, 2, 2, 2, 1233, 1229, 3, 2,
	2, 2, 1233, 1230, 3, 2, 2, 2, 1233, 1231, 3, 2, 2, 2, 1233, 1232, 3, 2,
	2, 2, 1234, 233, 3, 2, 2, 2, 1235, 1236, 5, 306, 154, 2, 1236, 235, 3,
	2, 2, 2, 1237, 1242, 5, 234, 118, 2, 1238, 1239, 7, 94, 2, 2, 1239, 1241,
	5, 234, 118, 2, 1240, 1238, 3, 2, 2, 2, 1241, 1244, 3, 2, 2, 2, 1242, 1240,
	3, 2, 2, 2, 1242, 1243, 3, 2, 2, 2, 1243, 237, 3, 2, 2, 2, 1244, 1242,
	3, 2, 2, 2, 1245, 1246, 7, 85, 2, 2, 1246, 1247, 5, 236, 119, 2, 1247,
	1248, 7, 86, 2, 2, 1248, 239, 3, 2, 2, 2, 1249, 1250, 7, 84, 2, 2, 1250,
	241, 3, 2, 2, 2, 1251, 1262, 7, 141, 2, 2, 1252, 1263, 5, 200, 101, 2,
	1253, 1263, 5, 202, 102, 2, 1254, 1263, 5, 212, 107, 2, 1255, 1263, 5,
	214, 108, 2, 1256, 1263, 5, 220, 111, 2, 1257, 1263, 5, 216, 109, 2, 1258,
	1263, 5, 218, 110, 2, 1259, 1263, 5, 208, 105, 2, 1260, 1263, 5, 224, 113,
	2, 1261, 1263, 5, 230, 116, 2, 1262, 1252, 3, 2, 2, 2, 1262, 1253, 3, 2,
	2, 2, 1262, 1254, 3, 2, 2, 2, 1262, 1255, 3, 2, 2, 2, 1262, 1256, 3, 2,
	2, 2, 1262, 1257, 3, 2, 2, 2, 1262, 1258, 3, 2, 2, 2, 1262, 1259, 3, 2,
	2, 2, 1262, 1260, 3, 2, 2, 2, 1262, 1261, 3, 2, 2, 2, 1263, 243, 3, 2,
	2, 2, 1264, 1269, 5, 242, 122, 2, 1265, 1269, 5, 224, 113, 2, 1266, 1269,
	5, 230, 116, 2, 1267, 1269, 5, 188, 95, 2, 1268, 1264, 3, 2, 2, 2, 1268,
	1265, 3, 2, 2, 2, 1268, 1266, 3, 2, 2, 2, 1268, 1267, 3, 2, 2, 2, 1269,
	245, 3, 2, 2, 2, 1270, 1271, 9, 14, 2, 2, 1271, 247, 3, 2, 2, 2, 1272,
	1273, 7, 92, 2, 2, 1273, 1274, 5, 306, 154, 2, 1274, 1275, 7, 93, 2, 2,
	1275, 249, 3, 2, 2, 2, 1276, 1277, 7, 80, 2, 2, 1277, 1278, 5, 236, 119,
	2, 1278, 1279, 7, 81, 2, 2, 1279, 251, 3, 2, 2, 2, 1280, 1289, 5, 194,
	98, 2, 1281, 1289, 5, 238, 120, 2, 1282, 1289, 5, 250, 126, 2, 1283, 1289,
	5, 240, 121, 2, 1284, 1289, 5, 248, 125, 2, 1285, 1289, 5, 186, 94, 2,
	1286, 1289, 5, 244, 123, 2, 1287, 1289, 5, 246, 124, 2, 1288, 1280, 3,
	2, 2, 2, 1288, 1281, 3, 2, 2, 2, 1288, 1282, 3, 2, 2, 2, 1288, 1283, 3,
	2, 2, 2, 1288, 1284, 3, 2, 2, 2, 1288, 1285, 3, 2, 2, 2, 1288, 1286, 3,
	2, 2, 2, 1288, 1287, 3, 2, 2, 2, 1289, 253, 3, 2, 2, 2, 1290, 1294, 5,
	252, 127, 2, 1291, 1293, 5, 232, 117, 2, 1292, 1291, 3, 2, 2, 2, 1293,
	1296, 3, 2, 2, 2, 1294, 1292, 3, 2, 2, 2, 1294, 1295, 3, 2, 2, 2, 1295,
	255, 3, 2, 2, 2, 1296, 1294, 3, 2, 2, 2, 1297, 1298, 7, 89, 2, 2, 1298,
	1299, 5, 260, 131, 2, 1299, 257, 3, 2, 2, 2, 1300, 1302, 5, 254, 128, 2,
	1301, 1303, 5, 256, 129, 2, 1302, 1301, 3, 2, 2, 2, 1302, 1303, 3, 2, 2,
	2, 1303, 259, 3, 2, 2, 2, 1304, 1306, 9, 15, 2, 2, 1305, 1304, 3, 2, 2,
	2, 1305, 1306, 3, 2, 2, 2, 1306, 1307, 3, 2, 2, 2, 1307, 1308, 5, 258,
	130, 2, 1308, 261, 3, 2, 2, 2, 1309, 1310, 9, 16, 2, 2, 1310, 1311, 5,
	260, 131, 2, 1311, 263, 3, 2, 2, 2, 1312, 1316, 5, 260, 131, 2, 1313, 1315,
	5, 262, 132, 2, 1314, 1313, 3, 2, 2, 2, 1315, 1318, 3, 2, 2, 2, 1316, 1314,
	3, 2, 2, 2, 1316, 1317, 3, 2, 2, 2, 1317, 265, 3, 2, 2, 2, 1318, 1316,
	3, 2, 2, 2, 1319, 1320, 9, 17, 2, 2, 1320, 1321, 5, 264, 133, 2, 1321,
	267, 3, 2, 2, 2, 1322, 1326, 5, 264, 133, 2, 1323, 1325, 5, 266, 134, 2,
	1324, 1323, 3, 2, 2, 2, 1325, 1328, 3, 2, 2, 2, 1326, 1324, 3, 2, 2, 2,
	1326, 1327, 3, 2, 2, 2, 1327, 269, 3, 2, 2, 2, 1328, 1326, 3, 2, 2, 2,
	1329, 1330, 9, 18, 2, 2, 1330, 271, 3, 2, 2, 2, 1331, 1337, 5, 268, 135,
	2, 1332, 1333, 5, 270, 136, 2, 1333, 1334, 5, 268, 135, 2, 1334, 1336,
	3, 2, 2, 2, 1335, 1332, 3, 2, 2, 2, 1336, 1339, 3, 2, 2, 2, 1337, 1335,
	3, 2, 2, 2, 1337, 1338, 3, 2, 2, 2, 1338, 273, 3, 2, 2, 2, 1339, 1337,
	3, 2, 2, 2, 1340, 1345, 5, 272, 137, 2, 1341, 1342, 9, 19, 2, 2, 1342,
	1344, 5, 272, 137, 2, 1343, 1341, 3, 2, 2, 2, 1344, 1347, 3, 2, 2, 2, 1345,
	1343, 3, 2, 2, 2, 1345, 1346, 3, 2, 2, 2, 1346, 275, 3, 2, 2, 2, 1347,
	1345, 3, 2, 2, 2, 1348, 1353, 5, 274, 138, 2, 1349, 1350, 7, 103, 2, 2,
	1350, 1352, 5, 274, 138, 2, 1351, 1349, 3, 2, 2, 2, 1352, 1355, 3, 2, 2,
	2, 1353, 1351, 3, 2, 2, 2, 1353, 1354, 3, 2, 2, 2, 1354, 277, 3, 2, 2,
	2, 1355, 1353, 3, 2, 2, 2, 1356, 1361, 5, 276, 139, 2, 1357, 1358, 7, 109,
	2, 2, 1358, 1360, 5, 276, 139, 2, 1359, 1357, 3, 2, 2, 2, 1360, 1363, 3,
	2, 2, 2, 1361, 1359, 3, 2, 2, 2, 1361, 1362, 3, 2, 2, 2, 1362, 279, 3,
	2, 2, 2, 1363, 1361, 3, 2, 2, 2, 1364, 1369, 5, 278, 140, 2, 1365, 1366,
	7, 105, 2, 2, 1366, 1368, 5, 278, 140, 2, 1367, 1365, 3, 2, 2, 2, 1368,
	1371, 3, 2, 2, 2, 1369, 1367, 3, 2, 2, 2, 1369, 1370, 3, 2, 2, 2, 1370,
	281, 3, 2, 2, 2, 1371, 1369, 3, 2, 2, 2, 1372, 1377, 5, 280, 141, 2, 1373,
	1374, 7, 104, 2, 2, 1374, 1376, 5, 280, 141, 2, 1375, 1373, 3, 2, 2, 2,
	1376, 1379, 3, 2, 2, 2, 1377, 1375, 3, 2, 2, 2, 1377, 1378, 3, 2, 2, 2,
	1378, 283, 3, 2, 2, 2, 1379, 1377, 3, 2, 2, 2, 1380, 1385, 5, 282, 142,
	2, 1381, 1382, 7, 120, 2, 2, 1382, 1384, 5, 282, 142, 2, 1383, 1381, 3,
	2, 2, 2, 1384, 1387, 3, 2, 2, 2, 1385, 1383, 3, 2, 2, 2, 1385, 1386, 3,
	2, 2, 2, 1386, 285, 3, 2, 2, 2, 1387, 1385, 3, 2, 2, 2, 1388, 1393, 5,
	284, 143, 2, 1389, 1390, 7, 90, 2, 2, 1390, 1392, 5, 284, 143, 2, 1391,
	1389, 3, 2, 2, 2, 1392, 1395, 3, 2, 2, 2, 1393, 1391, 3, 2, 2, 2, 1393,
	1394, 3, 2, 2, 2, 1394, 287, 3, 2, 2, 2, 1395, 1393, 3, 2, 2, 2, 1396,
	1398, 5, 306, 154, 2, 1397, 1399, 7, 100, 2, 2, 1398, 1397, 3, 2, 2, 2,
	1398, 1399, 3, 2, 2, 2, 1399, 1400, 3, 2, 2, 2, 1400, 1401, 7, 114, 2,
	2, 1401, 1402, 5, 306, 154, 2, 1402, 1403, 7, 115, 2, 2, 1403, 1404, 5,
	306, 154, 2, 1404, 289, 3, 2, 2, 2, 1405, 1406, 5, 306, 154, 2, 1406, 1407,
	8, 146, 1, 2, 1407, 291, 3, 2, 2, 2, 1408, 1409, 5, 306, 154, 2, 1409,
	293, 3, 2, 2, 2, 1410, 1415, 5, 292, 147, 2, 1411, 1412, 7, 94, 2, 2, 1412,
	1414, 5, 292, 147, 2, 1413, 1411, 3, 2, 2, 2, 1414, 1417, 3, 2, 2, 2, 1415,
	1413, 3, 2, 2, 2, 1415, 1416, 3, 2, 2, 2, 1416, 295, 3, 2, 2, 2, 1417,
	1415, 3, 2, 2, 2, 1418, 1419, 5, 294, 148, 2, 1419, 1420, 7, 76, 2, 2,
	1420, 1423, 5, 290, 146, 2, 1421, 1424, 6, 149, 2, 3, 1422, 1424, 7, 144,
	2, 2, 1423, 1421, 3, 2, 2, 2, 1423, 1422, 3, 2, 2, 2, 1424, 297, 3, 2,
	2, 2, 1425, 1426, 7, 115, 2, 2, 1426, 1429, 5, 306, 154, 2, 1427, 1430,
	6, 150, 3, 3, 1428, 1430, 7, 144, 2, 2, 1429, 1427, 3, 2, 2, 2, 1429, 1428,
	3, 2, 2, 2, 1430, 299, 3, 2, 2, 2, 1431, 1432, 5, 306, 154, 2, 1432, 1433,
	7, 78, 2, 2, 1433, 301, 3, 2, 2, 2, 1434, 1436, 5, 300, 151, 2, 1435, 1434,
	3, 2, 2, 2, 1435, 1436, 3, 2, 2, 2, 1436, 1437, 3, 2, 2, 2, 1437, 1438,
	7, 91, 2, 2, 1438, 1439, 7, 144, 2, 2, 1439, 1441, 7, 3, 2, 2, 1440, 1442,
	5, 296, 149, 2, 1441, 1440, 3, 2, 2, 2, 1442, 1443, 3, 2, 2, 2, 1443, 1441,
	3, 2, 2, 2, 1443, 1444, 3, 2, 2, 2, 1444, 1446, 3, 2, 2, 2, 1445, 1447,
	5, 298, 150, 2, 1446, 1445, 3, 2, 2, 2, 1446, 1447, 3, 2, 2, 2, 1447, 1448,
	3, 2, 2, 2, 1448, 1449, 7, 4, 2, 2, 1449, 303, 3, 2, 2, 2, 1450, 1455,
	7, 113, 2, 2, 1451, 1456, 5, 288, 145, 2, 1452, 1453, 5, 302, 152, 2, 1453,
	1454, 8, 153, 1, 2, 1454, 1456, 3, 2, 2, 2, 1455, 1451, 3, 2, 2, 2, 1455,
	1452, 3, 2, 2, 2, 1456, 305, 3, 2, 2, 2, 1457, 1458, 5, 304, 153, 2, 1458,
	1459, 8, 154, 1, 2, 1459, 1462, 3, 2, 2, 2, 1460, 1462, 5, 286, 144, 2,
	1461, 1457, 3, 2, 2, 2, 1461, 1460, 3, 2, 2, 2, 1462, 307, 3, 2, 2, 2,
	1463, 1470, 7, 95, 2, 2, 1464, 1465, 5, 306, 154, 2, 1465, 1466, 8, 155,
	1, 2, 1466, 1471, 3, 2, 2, 2, 1467, 1468, 5, 334, 168, 2, 1468, 1469, 8,
	155, 1, 2, 1469, 1471, 3, 2, 2, 2, 1470, 1464, 3, 2, 2, 2, 1470, 1467,
	3, 2, 2, 2, 1471, 309, 3, 2, 2, 2, 1472, 1473, 7, 140, 2, 2, 1473, 1474,
	5, 308, 155, 2, 1474, 1475, 8, 156, 1, 2, 1475, 311, 3, 2, 2, 2, 1476,
	1477, 7, 116, 2, 2, 1477, 1478, 7, 140, 2, 2, 1478, 1479, 5, 308, 155,
	2, 1479, 1480, 8, 157, 1, 2, 1480, 313, 3, 2, 2, 2, 1481, 1482, 7, 88,
	2, 2, 1482, 1483, 7, 140, 2, 2, 1483, 1484, 5, 308, 155, 2, 1484, 1485,
	8, 158, 1, 2, 1485, 315, 3, 2, 2, 2, 1486, 1487, 7, 139, 2, 2, 1487, 317,
	3, 2, 2, 2, 1488, 1489, 5, 316, 159, 2, 1489, 319, 3, 2, 2, 2, 1490, 1491,
	5, 312, 157, 2, 1491, 1492, 8, 161, 1, 2, 1492, 1500, 3, 2, 2, 2, 1493,
	1494, 5, 314, 158, 2, 1494, 1495, 8, 161, 1, 2, 1495, 1500, 3, 2, 2, 2,
	1496, 1497, 5, 310, 156, 2, 1497, 1498, 8, 161, 1, 2, 1498, 1500, 3, 2,
	2, 2, 1499, 1490, 3, 2, 2, 2, 1499, 1493, 3, 2, 2, 2, 1499, 1496, 3, 2,
	2, 2, 1500, 1503, 3, 2, 2, 2, 1501, 1504, 6, 161, 4, 3, 1502, 1504, 7,
	144, 2, 2, 1503, 1501, 3, 2, 2, 2, 1503, 1502, 3, 2, 2, 2, 1504, 321, 3,
	2, 2, 2, 1505, 1506, 5, 194, 98, 2, 1506, 1507, 7, 141, 2, 2, 1507, 1508,
	7, 110, 2, 2, 1508, 1509, 7, 144, 2, 2, 1509, 323, 3, 2, 2, 2, 1510, 1514,
	5, 318, 160, 2, 1511, 1514, 5, 320, 161, 2, 1512, 1514, 5, 322, 162, 2,
	1513, 1510, 3, 2, 2, 2, 1513, 1511, 3, 2, 2, 2, 1513, 1512, 3, 2, 2, 2,
	1514, 325, 3, 2, 2, 2, 1515, 1519, 5, 34, 18, 2, 1516, 1519, 5, 38, 20,
	2, 1517, 1519, 5, 184, 93, 2, 1518, 1515, 3, 2, 2, 2, 1518, 1516, 3, 2,
	2, 2, 1518, 1517, 3, 2, 2, 2, 1519, 327, 3, 2, 2, 2, 1520, 1521, 5, 184,
	93, 2, 1521, 329, 3, 2, 2, 2, 1522, 1523, 7, 140, 2, 2, 1523, 331, 3, 2,
	2, 2, 1524, 1525, 5, 306, 154, 2, 1525, 333, 3, 2, 2, 2, 1526, 1528, 5,
	332, 167, 2, 1527, 1526, 3, 2, 2, 2, 1527, 1528, 3, 2, 2, 2, 1528, 1529,
	3, 2, 2, 2, 1529, 1534, 7, 77, 2, 2, 1530, 1531, 7, 82, 2, 2, 1531, 1532,
	5, 326, 164, 2, 1532, 1533, 7, 83, 2, 2, 1533, 1535, 3, 2, 2, 2, 1534,
	1530, 3, 2, 2, 2, 1534, 1535, 3, 2, 2, 2, 1535, 1536, 3, 2, 2, 2, 1536,
	1538, 7, 92, 2, 2, 1537, 1539, 5, 330, 166, 2, 1538, 1537, 3, 2, 2, 2,
	1538, 1539, 3, 2, 2, 2, 1539, 1540, 3, 2, 2, 2, 1540, 1541, 7, 91, 2, 2,
	1541, 1542, 7, 144, 2, 2, 1542, 1544, 7, 3, 2, 2, 1543, 1545, 5, 324, 163,
	2, 1544, 1543, 3, 2, 2, 2, 1545, 1546, 3, 2, 2, 2, 1546, 1544, 3, 2, 2,
	2, 1546, 1547, 3, 2, 2, 2, 1547, 1548, 3, 2, 2, 2, 1548, 1549, 7, 4, 2,
	2, 1549, 1550, 7, 93, 2, 2, 1550, 1551, 7, 144, 2, 2, 1551, 335, 3, 2,
	2, 2, 1552, 1553, 7, 3, 2, 2, 1553, 1554, 5, 334, 168, 2, 1554, 1555, 7,
	4, 2, 2, 1555, 337, 3, 2, 2, 2, 1556, 1557, 5, 10, 6, 2, 1557, 1558, 7,
	32, 2, 2, 1558, 1559, 5, 184, 93, 2, 1559, 339, 3, 2, 2, 2, 1560, 1565,
	5, 338, 170, 2, 1561, 1562, 7, 39, 2, 2, 1562, 1564, 5, 338, 170, 2, 1563,
	1561, 3, 2, 2, 2, 1564, 1567, 3, 2, 2, 2, 1565, 1563, 3, 2, 2, 2, 1565,
	1566, 3, 2, 2, 2, 1566, 341, 3, 2, 2, 2, 1567, 1565, 3, 2, 2, 2, 1568,
	1569, 7, 37, 2, 2, 1569, 343, 3, 2, 2, 2, 1570, 1571, 7, 12, 2, 2, 1571,
	1572, 5, 10, 6, 2, 1572, 1573, 7, 51, 2, 2, 1573, 1574, 5, 340, 171, 2,
	1574, 1577, 7, 52, 2, 2, 1575, 1576, 7, 34, 2, 2, 1576, 1578, 5, 328, 165,
	2, 1577, 1575, 3, 2, 2, 2, 1577, 1578, 3, 2, 2, 2, 1578, 1587, 3, 2, 2,
	2, 1579, 1581, 5, 28, 15, 2, 1580, 1579, 3, 2, 2, 2, 1580, 1581, 3, 2,
	2, 2, 1581, 1582, 3, 2, 2, 2, 1582, 1583, 7, 42, 2, 2, 1583, 1588, 5, 336,
	169, 2, 1584, 1585, 5, 342, 172, 2, 1585, 1586, 8, 173, 1, 2, 1586, 1588,
	3, 2, 2, 2, 1587, 1580, 3, 2, 2, 2, 1587, 1584, 3, 2, 2, 2, 1588, 345,
	3, 2, 2, 2, 1589, 1590, 7, 10, 2, 2, 1590, 1592, 5, 10, 6, 2, 1591, 1593,
	5, 28, 15, 2, 1592, 1591, 3, 2, 2, 2, 1592, 1593, 3, 2, 2, 2, 1593, 1594,
	3, 2, 2, 2, 1594, 1595, 7, 42, 2, 2, 1595, 1599, 7, 3, 2, 2, 1596, 1598,
	5, 48, 25, 2, 1597, 1596, 3, 2, 2, 2, 1598, 1601, 3, 2, 2, 2, 1599, 1597,
	3, 2, 2, 2, 1599, 1600, 3, 2, 2, 2, 1600, 1604, 3, 2, 2, 2, 1601, 1599,
	3, 2, 2, 2, 1602, 1605, 5, 32, 17, 2, 1603, 1605, 5, 42, 22, 2, 1604, 1602,
	3, 2, 2, 2, 1604, 1603, 3, 2, 2, 2, 1605, 1606, 3, 2, 2, 2, 1606, 1607,
	7, 4, 2, 2, 1607, 347, 3, 2, 2, 2, 1608, 1624, 7, 3, 2, 2, 1609, 1625,
	5, 346, 174, 2, 1610, 1625, 5, 48, 25, 2, 1611, 1625, 5, 178, 90, 2, 1612,
	1625, 5, 180, 91, 2, 1613, 1625, 5, 84, 43, 2, 1614, 1625, 5, 138, 70,
	2, 1615, 1625, 5, 154, 78, 2, 1616, 1625, 5, 152, 77, 2, 1617, 1625, 5,
	182, 92, 2, 1618, 1625, 7, 61, 2, 2, 1619, 1625, 5, 68, 35, 2, 1620, 1621,
	5, 344, 173, 2, 1621, 1622, 8, 175, 1, 2, 1622, 1625, 3, 2, 2, 2, 1623,
	1625, 5, 66, 34, 2, 1624, 1609, 3, 2, 2, 2, 1624, 1610, 3, 2, 2, 2, 1624,
	1611, 3, 2, 2, 2, 1624, 1612, 3, 2, 2, 2, 1624, 1613, 3, 2, 2, 2, 1624,
	1614, 3, 2, 2, 2, 1624, 1615, 3, 2, 2, 2, 1624, 1616, 3, 2, 2, 2, 1624,
	1617, 3, 2, 2, 2, 1624, 1618, 3, 2, 2, 2, 1624, 1619, 3, 2, 2, 2, 1624,
	1620, 3, 2, 2, 2, 1624, 1623, 3, 2, 2, 2, 1625, 1626, 3, 2, 2, 2, 1626,
	1624, 3, 2, 2, 2, 1626, 1627, 3, 2, 2, 2, 1627, 1630, 3, 2, 2, 2, 1628,
	1631, 6, 175, 5, 3, 1629, 1631, 7, 4, 2, 2, 1630, 1628, 3, 2, 2, 2, 1630,
	1629, 3, 2, 2, 2, 1631, 349, 3, 2, 2, 2, 1632, 1634, 7, 61, 2, 2, 1633,
	1632, 3, 2, 2, 2, 1634, 1637, 3, 2, 2, 2, 1635, 1633, 3, 2, 2, 2, 1635,
	1636, 3, 2, 2, 2, 1636, 1638, 3, 2, 2, 2, 1637, 1635, 3, 2, 2, 2, 1638,
	1639, 5, 76, 39, 2, 1639, 1640, 7, 42, 2, 2, 1640, 1641, 5, 348, 175, 2,
	1641, 351, 3, 2, 2, 2, 1642, 1644, 7, 41, 2, 2, 1643, 1642, 3, 2, 2, 2,
	1643, 1644, 3, 2, 2, 2, 1644, 1645, 3, 2, 2, 2, 1645, 1650, 7, 63, 2, 2,
	1646, 1647, 7, 41, 2, 2, 1647, 1649, 7, 63, 2, 2, 1648, 1646, 3, 2, 2,
	2, 1649, 1652, 3, 2, 2, 2, 1650, 1648, 3, 2, 2, 2, 1650, 1651, 3, 2, 2,
	2, 1651, 353, 3, 2, 2, 2, 1652, 1650, 3, 2, 2, 2, 1653, 1657, 7, 13, 2,
	2, 1654, 1656, 7, 61, 2, 2, 1655, 1654, 3, 2, 2, 2, 1656, 1659, 3, 2, 2,
	2, 1657, 1655, 3, 2, 2, 2, 1657, 1658, 3, 2, 2, 2, 1658, 355, 3, 2, 2,
	2, 1659, 1657, 3, 2, 2, 2, 1660, 1662, 5, 354, 178, 2, 1661, 1660, 3, 2,
	2, 2, 1662, 1663, 3, 2, 2, 2, 1663, 1661, 3, 2, 2, 2, 1663, 1664, 3, 2,
	2, 2, 1664, 357, 3, 2, 2, 2, 1665, 1667, 5, 356, 179, 2, 1666, 1665, 3,
	2, 2, 2, 1666, 1667, 3, 2, 2, 2, 1667, 1669, 3, 2, 2, 2, 1668, 1670, 5,
	350, 176, 2, 1669, 1668, 3, 2, 2, 2, 1670, 1671, 3, 2, 2, 2, 1671, 1669,
	3, 2, 2, 2, 1671, 1672, 3, 2, 2, 2, 1672, 1673, 3, 2, 2, 2, 1673, 1674,
	7, 2, 2, 3, 1674, 359, 3, 2, 2, 2, 182, 366, 373, 382, 396, 409, 420, 430,
	438, 445, 453, 463, 467, 472, 476, 481, 485, 492, 499, 510, 518, 520, 523,
	526, 530, 536, 544, 550, 555, 558, 560, 570, 572, 577, 582, 587, 597, 603,
	612, 614, 617, 628, 633, 636, 645, 649, 656, 661, 670, 689, 692, 700, 705,
	713, 722, 728, 730, 737, 749, 751, 757, 759, 767, 776, 780, 789, 796, 803,
	812, 822, 835, 842, 845, 852, 862, 871, 874, 881, 888, 904, 907, 911, 914,
	917, 924, 933, 936, 939, 947, 951, 953, 957, 963, 965, 973, 981, 993, 999,
	1002, 1023, 1034, 1038, 1043, 1046, 1054, 1058, 1064, 1072, 1076, 1080,
	1086, 1097, 1103, 1109, 1116, 1124, 1135, 1145, 1152, 1162, 1179, 1184,
	1188, 1193, 1199, 1207, 1213, 1217, 1233, 1242, 1262, 1268, 1288, 1294,
	1302, 1305, 1316, 1326, 1337, 1345, 1353, 1361, 1369, 1377, 1385, 1393,
	1398, 1415, 1423, 1429, 1435, 1443, 1446, 1455, 1461, 1470, 1499, 1503,
	1513, 1518, 1527, 1534, 1538, 1546, 1565, 1577, 1580, 1587, 1592, 1599,
	1604, 1624, 1626, 1630, 1635, 1643, 1650, 1657, 1663, 1666, 1671,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "", "'!wrap'", "'!table'", "'!type'", "'!alias'", "'!union'",
	"'!view'", "", "", "", "", "", "", "", "", "", "", "", "'..'", "", "",
	"", "", "'<->'", "", "", "", "", "", "'.. * <- *'", "", "", "", "", "",
	"", "", "", "", "'@'", "", "", "", "", "", "", "", "", "'#'", "'|'", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "'=>'", "'->'", "'=='", "", "", "", "'<'", "'>'", "'{:}'", "", "",
	"'?.'", "", "'**'", "", "", "", "", "", "", "", "", "'%'", "'-'", "", "",
	"'!'", "", "'||'", "'&&'", "", "'by'", "'and'", "", "'*'", "'as'", "'via'",
	"'if'", "'then'", "'else'", "'let'", "'true'", "'false'", "'null'", "",
	"", "", "'asc'", "'desc'", "'rank'", "", "'any'", "", "'snapshot'", "'where'",
	"'count'", "'flatten'", "'first'",
}
var symbolicNames = []string{
	"", "INDENT", "DEDENT", "NativeDataTypes", "HTTP_VERBS", "WRAP", "TABLE",
	"TYPE", "ALIAS", "UNION", "VIEW", "IMPORT", "RETURN", "IF", "FOR_EACH",
	"FOR", "UNTIL", "ELSE", "LOOP", "ALT", "WHILE", "WHATEVER", "DOTDOT", "SEQUENCE_OF",
	"SET_OF", "ONE_OF", "MIXIN", "DISTANCE", "DOT_ARROW", "NAME_SEP", "LESS_COLON",
	"ARROW_LEFT", "ARROW_RIGHT", "COLLECTOR", "PLUS", "ABSTRACT", "TILDE",
	"COMMA", "EQ", "FORWARD_SLASH", "COLON", "DOT", "QN", "AT", "AMP", "SQ_OPEN",
	"SQ_CLOSE", "CURLY_OPEN", "CURLY_CLOSE", "OPEN_PAREN", "CLOSE_PAREN", "EMPTY_COMMENT",
	"HASH", "PIPE", "EMPTY_LINE", "INDENTED_COMMENT", "DIGITS", "QSTRING",
	"NEWLINE", "SYSL_COMMENT", "TEXT_LINE", "Name", "WS", "ErrorChar", "PREDICATE_VALUE",
	"SKIP_WS_ARG", "TEXT_VALUE", "NEWLINE_2", "TEXT", "POP_WS", "VAR_NAME",
	"E_NativeDataTypes", "E_INDENTED_COMMENT", "E_WHATEVER", "E_EQ_RIGHT",
	"E_ARROW_RIGHT", "E_DOUBLE_EQ", "E_REL", "E_SQ_OPEN", "E_SQ_CLOSE", "E_ANGLE_OPEN",
	"E_ANGLE_CLOSE", "E_EMPTY_TUPLE", "E_CURLY_OPEN", "E_CURLY_CLOSE", "E_NULLSAFE_DOT",
	"E_TABLE_OF", "E_POW", "E_COALESCE", "E_COLON", "E_OPEN_PAREN", "E_CLOSE_PAREN",
	"E_COMMA", "E_EQ", "E_PLUS", "E_DIVIDE", "E_MOD", "E_MINUS", "E_QN", "E_TILDE",
	"E_NOT", "E_XOR", "E_LOGIC_OR", "E_DOUBLE_AMP", "E_AMP", "E_BY", "E_AND",
	"E_BITOR", "E_STAR", "E_AS", "E_VIA", "E_IF", "E_THEN", "E_ELSE", "E_LET",
	"E_TRUE", "E_FALSE", "E_NULL", "E_BUTNOT", "E_SEQUENCE_OF", "E_SET_OF",
	"E_ASC", "E_DESC", "E_RELOPS_RANK", "E_RELOPS_AGG", "E_RELOPS_ANY", "E_RELOPS_SINGLE_NULL",
	"E_RELOPS_SNAPSHOT", "E_RELOPS_WHERE", "E_RELOPS_COUNT", "E_RELOPS_FLATTEN",
	"E_RELOPS_FIRST", "E_FUNC", "E_STRING_DBL", "E_STRING_SINGLE", "E_DECIMAL",
	"E_DIGITS", "E_DOT_NAME_NL", "E_Name", "E_DOT", "E_WS", "E_EMPTY_LINE",
	"E_NL",
}

var ruleNames = []string{
	"modifier", "size_spec", "modifier_list", "modifiers", "name_str", "reference",
	"doc_string", "quoted_string", "array_of_strings", "array_of_arrays", "nvp",
	"attributes", "entry", "attribs_or_modifiers", "user_defined_type", "types",
	"set_of", "set_type", "sequence_of", "sequence_type", "collection_type",
	"multi_line_docstring", "annotation_value", "annotation", "annotations",
	"field_type", "array_size", "inplace_tuple", "field", "inplace_table",
	"table_stmts", "table_def", "table", "union", "package_name", "sub_package",
	"app_name", "name_with_attribs", "model_name", "inplace_table_def", "table_refs",
	"facade", "documentation_stmts", "var_in_curly", "query_var", "query_param",
	"http_path_part", "http_path_var_with_type", "http_path_static", "http_path_suffix",
	"http_path", "endpoint_name", "ret_stmt", "target", "target_endpoint",
	"call_arg", "call_args", "call_stmt", "if_stmt", "else_stmt", "if_else",
	"for_stmt", "http_method_comment", "group_stmt", "one_of_case_label", "one_of_cases",
	"one_of_stmt", "text_stmt", "mixin", "param", "param_list", "params", "statements",
	"method_def", "shortcut", "simple_endpoint", "rest_endpoint", "collector_query_var",
	"collector_query_param", "collector_call_stmt", "collector_http_stmt_part",
	"collector_http_stmt_suffix", "collector_http_stmt", "publisher", "subscriber",
	"collector_pubsub_call", "collector_action_stmt", "collector_stmts", "collector",
	"event", "subscribe", "view_type_spec", "literal", "expr_table_of_op",
	"func_arg", "func_args", "expr_func", "rank_expr", "rank_expr_list", "expr_rank_func",
	"expr_agg_func", "e_scope_var", "first_func_target", "expr_first_func",
	"e_single_arg_func", "expr_single_arg_func", "expr_any_func", "expr_single_or_null",
	"expr_snapshot", "expr_count", "expr_navigate_attr", "expr_navigate", "matching_rhs",
	"squiggly_args", "expr_matching", "relop", "list_item", "expr_list", "expr_set",
	"empty_tuple", "atom_dot_relop", "atomT_implied_dot", "atomT_name", "atomT_paren",
	"expr_atom_list", "atomT", "atom", "powerT", "power", "unaryTerm", "termT",
	"term", "binexprT", "binexpr", "e_compare_ops", "expr_rel", "expr_bitand",
	"expr_bitxor", "expr_bitor", "expr_and", "expr_or", "expr_but_not", "expr_coalesce",
	"if_one_liner", "else_block_stmt", "control_item", "if_controls", "cond_block",
	"final_else", "ifvar", "if_multiple_lines", "expr_if_else", "expr", "expr_assign",
	"expr_simple_assign", "expr_let_statement", "expr_table_of_statement",
	"expr_dot_assign", "expr_statement_no_nl", "expr_statement", "expr_inject_stmt",
	"expr_stmt", "transform_return_type", "view_return_type", "transform_scope_var",
	"transform_arg", "transform", "expr_block", "view_param", "view_params",
	"abstract_view", "view", "alias", "app_decl", "application", "path", "import_stmt",
	"imports_decl", "sysl_file",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type SyslParser struct {
	*antlr.BaseParser
}

func NewSyslParser(input antlr.TokenStream) *SyslParser {
	this := new(SyslParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SyslParser.g4"

	return this
}

// SyslParser tokens.
const (
	SyslParserEOF                  = antlr.TokenEOF
	SyslParserINDENT               = 1
	SyslParserDEDENT               = 2
	SyslParserNativeDataTypes      = 3
	SyslParserHTTP_VERBS           = 4
	SyslParserWRAP                 = 5
	SyslParserTABLE                = 6
	SyslParserTYPE                 = 7
	SyslParserALIAS                = 8
	SyslParserUNION                = 9
	SyslParserVIEW                 = 10
	SyslParserIMPORT               = 11
	SyslParserRETURN               = 12
	SyslParserIF                   = 13
	SyslParserFOR_EACH             = 14
	SyslParserFOR                  = 15
	SyslParserUNTIL                = 16
	SyslParserELSE                 = 17
	SyslParserLOOP                 = 18
	SyslParserALT                  = 19
	SyslParserWHILE                = 20
	SyslParserWHATEVER             = 21
	SyslParserDOTDOT               = 22
	SyslParserSEQUENCE_OF          = 23
	SyslParserSET_OF               = 24
	SyslParserONE_OF               = 25
	SyslParserMIXIN                = 26
	SyslParserDISTANCE             = 27
	SyslParserDOT_ARROW            = 28
	SyslParserNAME_SEP             = 29
	SyslParserLESS_COLON           = 30
	SyslParserARROW_LEFT           = 31
	SyslParserARROW_RIGHT          = 32
	SyslParserCOLLECTOR            = 33
	SyslParserPLUS                 = 34
	SyslParserABSTRACT             = 35
	SyslParserTILDE                = 36
	SyslParserCOMMA                = 37
	SyslParserEQ                   = 38
	SyslParserFORWARD_SLASH        = 39
	SyslParserCOLON                = 40
	SyslParserDOT                  = 41
	SyslParserQN                   = 42
	SyslParserAT                   = 43
	SyslParserAMP                  = 44
	SyslParserSQ_OPEN              = 45
	SyslParserSQ_CLOSE             = 46
	SyslParserCURLY_OPEN           = 47
	SyslParserCURLY_CLOSE          = 48
	SyslParserOPEN_PAREN           = 49
	SyslParserCLOSE_PAREN          = 50
	SyslParserEMPTY_COMMENT        = 51
	SyslParserHASH                 = 52
	SyslParserPIPE                 = 53
	SyslParserEMPTY_LINE           = 54
	SyslParserINDENTED_COMMENT     = 55
	SyslParserDIGITS               = 56
	SyslParserQSTRING              = 57
	SyslParserNEWLINE              = 58
	SyslParserSYSL_COMMENT         = 59
	SyslParserTEXT_LINE            = 60
	SyslParserName                 = 61
	SyslParserWS                   = 62
	SyslParserErrorChar            = 63
	SyslParserPREDICATE_VALUE      = 64
	SyslParserSKIP_WS_ARG          = 65
	SyslParserTEXT_VALUE           = 66
	SyslParserNEWLINE_2            = 67
	SyslParserTEXT                 = 68
	SyslParserPOP_WS               = 69
	SyslParserVAR_NAME             = 70
	SyslParserE_NativeDataTypes    = 71
	SyslParserE_INDENTED_COMMENT   = 72
	SyslParserE_WHATEVER           = 73
	SyslParserE_EQ_RIGHT           = 74
	SyslParserE_ARROW_RIGHT        = 75
	SyslParserE_DOUBLE_EQ          = 76
	SyslParserE_REL                = 77
	SyslParserE_SQ_OPEN            = 78
	SyslParserE_SQ_CLOSE           = 79
	SyslParserE_ANGLE_OPEN         = 80
	SyslParserE_ANGLE_CLOSE        = 81
	SyslParserE_EMPTY_TUPLE        = 82
	SyslParserE_CURLY_OPEN         = 83
	SyslParserE_CURLY_CLOSE        = 84
	SyslParserE_NULLSAFE_DOT       = 85
	SyslParserE_TABLE_OF           = 86
	SyslParserE_POW                = 87
	SyslParserE_COALESCE           = 88
	SyslParserE_COLON              = 89
	SyslParserE_OPEN_PAREN         = 90
	SyslParserE_CLOSE_PAREN        = 91
	SyslParserE_COMMA              = 92
	SyslParserE_EQ                 = 93
	SyslParserE_PLUS               = 94
	SyslParserE_DIVIDE             = 95
	SyslParserE_MOD                = 96
	SyslParserE_MINUS              = 97
	SyslParserE_QN                 = 98
	SyslParserE_TILDE              = 99
	SyslParserE_NOT                = 100
	SyslParserE_XOR                = 101
	SyslParserE_LOGIC_OR           = 102
	SyslParserE_DOUBLE_AMP         = 103
	SyslParserE_AMP                = 104
	SyslParserE_BY                 = 105
	SyslParserE_AND                = 106
	SyslParserE_BITOR              = 107
	SyslParserE_STAR               = 108
	SyslParserE_AS                 = 109
	SyslParserE_VIA                = 110
	SyslParserE_IF                 = 111
	SyslParserE_THEN               = 112
	SyslParserE_ELSE               = 113
	SyslParserE_LET                = 114
	SyslParserE_TRUE               = 115
	SyslParserE_FALSE              = 116
	SyslParserE_NULL               = 117
	SyslParserE_BUTNOT             = 118
	SyslParserE_SEQUENCE_OF        = 119
	SyslParserE_SET_OF             = 120
	SyslParserE_ASC                = 121
	SyslParserE_DESC               = 122
	SyslParserE_RELOPS_RANK        = 123
	SyslParserE_RELOPS_AGG         = 124
	SyslParserE_RELOPS_ANY         = 125
	SyslParserE_RELOPS_SINGLE_NULL = 126
	SyslParserE_RELOPS_SNAPSHOT    = 127
	SyslParserE_RELOPS_WHERE       = 128
	SyslParserE_RELOPS_COUNT       = 129
	SyslParserE_RELOPS_FLATTEN     = 130
	SyslParserE_RELOPS_FIRST       = 131
	SyslParserE_FUNC               = 132
	SyslParserE_STRING_DBL         = 133
	SyslParserE_STRING_SINGLE      = 134
	SyslParserE_DECIMAL            = 135
	SyslParserE_DIGITS             = 136
	SyslParserE_DOT_NAME_NL        = 137
	SyslParserE_Name               = 138
	SyslParserE_DOT                = 139
	SyslParserE_WS                 = 140
	SyslParserE_EMPTY_LINE         = 141
	SyslParserE_NL                 = 142
)

// SyslParser rules.
const (
	SyslParserRULE_modifier                   = 0
	SyslParserRULE_size_spec                  = 1
	SyslParserRULE_modifier_list              = 2
	SyslParserRULE_modifiers                  = 3
	SyslParserRULE_name_str                   = 4
	SyslParserRULE_reference                  = 5
	SyslParserRULE_doc_string                 = 6
	SyslParserRULE_quoted_string              = 7
	SyslParserRULE_array_of_strings           = 8
	SyslParserRULE_array_of_arrays            = 9
	SyslParserRULE_nvp                        = 10
	SyslParserRULE_attributes                 = 11
	SyslParserRULE_entry                      = 12
	SyslParserRULE_attribs_or_modifiers       = 13
	SyslParserRULE_user_defined_type          = 14
	SyslParserRULE_types                      = 15
	SyslParserRULE_set_of                     = 16
	SyslParserRULE_set_type                   = 17
	SyslParserRULE_sequence_of                = 18
	SyslParserRULE_sequence_type              = 19
	SyslParserRULE_collection_type            = 20
	SyslParserRULE_multi_line_docstring       = 21
	SyslParserRULE_annotation_value           = 22
	SyslParserRULE_annotation                 = 23
	SyslParserRULE_annotations                = 24
	SyslParserRULE_field_type                 = 25
	SyslParserRULE_array_size                 = 26
	SyslParserRULE_inplace_tuple              = 27
	SyslParserRULE_field                      = 28
	SyslParserRULE_inplace_table              = 29
	SyslParserRULE_table_stmts                = 30
	SyslParserRULE_table_def                  = 31
	SyslParserRULE_table                      = 32
	SyslParserRULE_union                      = 33
	SyslParserRULE_package_name               = 34
	SyslParserRULE_sub_package                = 35
	SyslParserRULE_app_name                   = 36
	SyslParserRULE_name_with_attribs          = 37
	SyslParserRULE_model_name                 = 38
	SyslParserRULE_inplace_table_def          = 39
	SyslParserRULE_table_refs                 = 40
	SyslParserRULE_facade                     = 41
	SyslParserRULE_documentation_stmts        = 42
	SyslParserRULE_var_in_curly               = 43
	SyslParserRULE_query_var                  = 44
	SyslParserRULE_query_param                = 45
	SyslParserRULE_http_path_part             = 46
	SyslParserRULE_http_path_var_with_type    = 47
	SyslParserRULE_http_path_static           = 48
	SyslParserRULE_http_path_suffix           = 49
	SyslParserRULE_http_path                  = 50
	SyslParserRULE_endpoint_name              = 51
	SyslParserRULE_ret_stmt                   = 52
	SyslParserRULE_target                     = 53
	SyslParserRULE_target_endpoint            = 54
	SyslParserRULE_call_arg                   = 55
	SyslParserRULE_call_args                  = 56
	SyslParserRULE_call_stmt                  = 57
	SyslParserRULE_if_stmt                    = 58
	SyslParserRULE_else_stmt                  = 59
	SyslParserRULE_if_else                    = 60
	SyslParserRULE_for_stmt                   = 61
	SyslParserRULE_http_method_comment        = 62
	SyslParserRULE_group_stmt                 = 63
	SyslParserRULE_one_of_case_label          = 64
	SyslParserRULE_one_of_cases               = 65
	SyslParserRULE_one_of_stmt                = 66
	SyslParserRULE_text_stmt                  = 67
	SyslParserRULE_mixin                      = 68
	SyslParserRULE_param                      = 69
	SyslParserRULE_param_list                 = 70
	SyslParserRULE_params                     = 71
	SyslParserRULE_statements                 = 72
	SyslParserRULE_method_def                 = 73
	SyslParserRULE_shortcut                   = 74
	SyslParserRULE_simple_endpoint            = 75
	SyslParserRULE_rest_endpoint              = 76
	SyslParserRULE_collector_query_var        = 77
	SyslParserRULE_collector_query_param      = 78
	SyslParserRULE_collector_call_stmt        = 79
	SyslParserRULE_collector_http_stmt_part   = 80
	SyslParserRULE_collector_http_stmt_suffix = 81
	SyslParserRULE_collector_http_stmt        = 82
	SyslParserRULE_publisher                  = 83
	SyslParserRULE_subscriber                 = 84
	SyslParserRULE_collector_pubsub_call      = 85
	SyslParserRULE_collector_action_stmt      = 86
	SyslParserRULE_collector_stmts            = 87
	SyslParserRULE_collector                  = 88
	SyslParserRULE_event                      = 89
	SyslParserRULE_subscribe                  = 90
	SyslParserRULE_view_type_spec             = 91
	SyslParserRULE_literal                    = 92
	SyslParserRULE_expr_table_of_op           = 93
	SyslParserRULE_func_arg                   = 94
	SyslParserRULE_func_args                  = 95
	SyslParserRULE_expr_func                  = 96
	SyslParserRULE_rank_expr                  = 97
	SyslParserRULE_rank_expr_list             = 98
	SyslParserRULE_expr_rank_func             = 99
	SyslParserRULE_expr_agg_func              = 100
	SyslParserRULE_e_scope_var                = 101
	SyslParserRULE_first_func_target          = 102
	SyslParserRULE_expr_first_func            = 103
	SyslParserRULE_e_single_arg_func          = 104
	SyslParserRULE_expr_single_arg_func       = 105
	SyslParserRULE_expr_any_func              = 106
	SyslParserRULE_expr_single_or_null        = 107
	SyslParserRULE_expr_snapshot              = 108
	SyslParserRULE_expr_count                 = 109
	SyslParserRULE_expr_navigate_attr         = 110
	SyslParserRULE_expr_navigate              = 111
	SyslParserRULE_matching_rhs               = 112
	SyslParserRULE_squiggly_args              = 113
	SyslParserRULE_expr_matching              = 114
	SyslParserRULE_relop                      = 115
	SyslParserRULE_list_item                  = 116
	SyslParserRULE_expr_list                  = 117
	SyslParserRULE_expr_set                   = 118
	SyslParserRULE_empty_tuple                = 119
	SyslParserRULE_atom_dot_relop             = 120
	SyslParserRULE_atomT_implied_dot          = 121
	SyslParserRULE_atomT_name                 = 122
	SyslParserRULE_atomT_paren                = 123
	SyslParserRULE_expr_atom_list             = 124
	SyslParserRULE_atomT                      = 125
	SyslParserRULE_atom                       = 126
	SyslParserRULE_powerT                     = 127
	SyslParserRULE_power                      = 128
	SyslParserRULE_unaryTerm                  = 129
	SyslParserRULE_termT                      = 130
	SyslParserRULE_term                       = 131
	SyslParserRULE_binexprT                   = 132
	SyslParserRULE_binexpr                    = 133
	SyslParserRULE_e_compare_ops              = 134
	SyslParserRULE_expr_rel                   = 135
	SyslParserRULE_expr_bitand                = 136
	SyslParserRULE_expr_bitxor                = 137
	SyslParserRULE_expr_bitor                 = 138
	SyslParserRULE_expr_and                   = 139
	SyslParserRULE_expr_or                    = 140
	SyslParserRULE_expr_but_not               = 141
	SyslParserRULE_expr_coalesce              = 142
	SyslParserRULE_if_one_liner               = 143
	SyslParserRULE_else_block_stmt            = 144
	SyslParserRULE_control_item               = 145
	SyslParserRULE_if_controls                = 146
	SyslParserRULE_cond_block                 = 147
	SyslParserRULE_final_else                 = 148
	SyslParserRULE_ifvar                      = 149
	SyslParserRULE_if_multiple_lines          = 150
	SyslParserRULE_expr_if_else               = 151
	SyslParserRULE_expr                       = 152
	SyslParserRULE_expr_assign                = 153
	SyslParserRULE_expr_simple_assign         = 154
	SyslParserRULE_expr_let_statement         = 155
	SyslParserRULE_expr_table_of_statement    = 156
	SyslParserRULE_expr_dot_assign            = 157
	SyslParserRULE_expr_statement_no_nl       = 158
	SyslParserRULE_expr_statement             = 159
	SyslParserRULE_expr_inject_stmt           = 160
	SyslParserRULE_expr_stmt                  = 161
	SyslParserRULE_transform_return_type      = 162
	SyslParserRULE_view_return_type           = 163
	SyslParserRULE_transform_scope_var        = 164
	SyslParserRULE_transform_arg              = 165
	SyslParserRULE_transform                  = 166
	SyslParserRULE_expr_block                 = 167
	SyslParserRULE_view_param                 = 168
	SyslParserRULE_view_params                = 169
	SyslParserRULE_abstract_view              = 170
	SyslParserRULE_view                       = 171
	SyslParserRULE_alias                      = 172
	SyslParserRULE_app_decl                   = 173
	SyslParserRULE_application                = 174
	SyslParserRULE_path                       = 175
	SyslParserRULE_import_stmt                = 176
	SyslParserRULE_imports_decl               = 177
	SyslParserRULE_sysl_file                  = 178
)

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserTILDE, 0)
}

func (s *ModifierContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *ModifierContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *ModifierContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserPLUS)
}

func (s *ModifierContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserPLUS, i)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (p *SyslParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SyslParserRULE_modifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(358)
		p.Match(SyslParserTILDE)
	}
	{
		p.SetState(359)
		p.Match(SyslParserName)
	}
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserPLUS {
		{
			p.SetState(360)
			p.Match(SyslParserPLUS)
		}
		{
			p.SetState(361)
			p.Match(SyslParserName)
		}

		p.SetState(366)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISize_specContext is an interface to support dynamic dispatch.
type ISize_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSize_specContext differentiates from other interfaces.
	IsSize_specContext()
}

type Size_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySize_specContext() *Size_specContext {
	var p = new(Size_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_size_spec
	return p
}

func (*Size_specContext) IsSize_specContext() {}

func NewSize_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Size_specContext {
	var p = new(Size_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_size_spec

	return p
}

func (s *Size_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Size_specContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Size_specContext) AllDIGITS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDIGITS)
}

func (s *Size_specContext) DIGITS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, i)
}

func (s *Size_specContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Size_specContext) DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserDOT, 0)
}

func (s *Size_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Size_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Size_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSize_spec(s)
	}
}

func (s *Size_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSize_spec(s)
	}
}

func (p *SyslParser) Size_spec() (localctx ISize_specContext) {
	localctx = NewSize_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SyslParserRULE_size_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(367)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(368)
		p.Match(SyslParserDIGITS)
	}
	p.SetState(371)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserDOT {
		{
			p.SetState(369)
			p.Match(SyslParserDOT)
		}
		{
			p.SetState(370)
			p.Match(SyslParserDIGITS)
		}

	}
	{
		p.SetState(373)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IModifier_listContext is an interface to support dynamic dispatch.
type IModifier_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifier_listContext differentiates from other interfaces.
	IsModifier_listContext()
}

type Modifier_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifier_listContext() *Modifier_listContext {
	var p = new(Modifier_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_modifier_list
	return p
}

func (*Modifier_listContext) IsModifier_listContext() {}

func NewModifier_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modifier_listContext {
	var p = new(Modifier_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_modifier_list

	return p
}

func (s *Modifier_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Modifier_listContext) AllModifier() []IModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifierContext)(nil)).Elem())
	var tst = make([]IModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifierContext)
		}
	}

	return tst
}

func (s *Modifier_listContext) Modifier(i int) IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *Modifier_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Modifier_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Modifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modifier_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modifier_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModifier_list(s)
	}
}

func (s *Modifier_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModifier_list(s)
	}
}

func (p *SyslParser) Modifier_list() (localctx IModifier_listContext) {
	localctx = NewModifier_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SyslParserRULE_modifier_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(375)
		p.Modifier()
	}
	p.SetState(380)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(376)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(377)
			p.Modifier()
		}

		p.SetState(382)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IModifiersContext is an interface to support dynamic dispatch.
type IModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifiersContext differentiates from other interfaces.
	IsModifiersContext()
}

type ModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifiersContext() *ModifiersContext {
	var p = new(ModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_modifiers
	return p
}

func (*ModifiersContext) IsModifiersContext() {}

func NewModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifiersContext {
	var p = new(ModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_modifiers

	return p
}

func (s *ModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifiersContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *ModifiersContext) Modifier_list() IModifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifier_listContext)
}

func (s *ModifiersContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *ModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModifiers(s)
	}
}

func (s *ModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModifiers(s)
	}
}

func (p *SyslParser) Modifiers() (localctx IModifiersContext) {
	localctx = NewModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SyslParserRULE_modifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(383)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(384)
		p.Modifier_list()
	}
	{
		p.SetState(385)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IName_strContext is an interface to support dynamic dispatch.
type IName_strContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_strContext differentiates from other interfaces.
	IsName_strContext()
}

type Name_strContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_strContext() *Name_strContext {
	var p = new(Name_strContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_name_str
	return p
}

func (*Name_strContext) IsName_strContext() {}

func NewName_strContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_strContext {
	var p = new(Name_strContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_name_str

	return p
}

func (s *Name_strContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_strContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Name_strContext) TEXT_LINE() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT_LINE, 0)
}

func (s *Name_strContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Name_strContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_strContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_strContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterName_str(s)
	}
}

func (s *Name_strContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitName_str(s)
	}
}

func (p *SyslParser) Name_str() (localctx IName_strContext) {
	localctx = NewName_strContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SyslParserRULE_name_str)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(387)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IReferenceContext is an interface to support dynamic dispatch.
type IReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceContext differentiates from other interfaces.
	IsReferenceContext()
}

type ReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceContext() *ReferenceContext {
	var p = new(ReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_reference
	return p
}

func (*ReferenceContext) IsReferenceContext() {}

func NewReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceContext {
	var p = new(ReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_reference

	return p
}

func (s *ReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *ReferenceContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *ReferenceContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *ReferenceContext) AllE_DOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_DOT)
}

func (s *ReferenceContext) E_DOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, i)
}

func (s *ReferenceContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDOT)
}

func (s *ReferenceContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDOT, i)
}

func (s *ReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterReference(s)
	}
}

func (s *ReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitReference(s)
	}
}

func (p *SyslParser) Reference() (localctx IReferenceContext) {
	localctx = NewReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SyslParserRULE_reference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.App_name()
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserDOT || _la == SyslParserE_DOT {
		p.SetState(390)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SyslParserDOT || _la == SyslParserE_DOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(391)
			p.Name_str()
		}

		p.SetState(394)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDoc_stringContext is an interface to support dynamic dispatch.
type IDoc_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoc_stringContext differentiates from other interfaces.
	IsDoc_stringContext()
}

type Doc_stringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoc_stringContext() *Doc_stringContext {
	var p = new(Doc_stringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_doc_string
	return p
}

func (*Doc_stringContext) IsDoc_stringContext() {}

func NewDoc_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Doc_stringContext {
	var p = new(Doc_stringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_doc_string

	return p
}

func (s *Doc_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Doc_stringContext) PIPE() antlr.TerminalNode {
	return s.GetToken(SyslParserPIPE, 0)
}

func (s *Doc_stringContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT, 0)
}

func (s *Doc_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Doc_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Doc_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterDoc_string(s)
	}
}

func (s *Doc_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitDoc_string(s)
	}
}

func (p *SyslParser) Doc_string() (localctx IDoc_stringContext) {
	localctx = NewDoc_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SyslParserRULE_doc_string)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(396)
		p.Match(SyslParserPIPE)
	}
	{
		p.SetState(397)
		p.Match(SyslParserTEXT)
	}

	return localctx
}

// IQuoted_stringContext is an interface to support dynamic dispatch.
type IQuoted_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuoted_stringContext differentiates from other interfaces.
	IsQuoted_stringContext()
}

type Quoted_stringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuoted_stringContext() *Quoted_stringContext {
	var p = new(Quoted_stringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_quoted_string
	return p
}

func (*Quoted_stringContext) IsQuoted_stringContext() {}

func NewQuoted_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quoted_stringContext {
	var p = new(Quoted_stringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_quoted_string

	return p
}

func (s *Quoted_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Quoted_stringContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Quoted_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quoted_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuoted_string(s)
	}
}

func (s *Quoted_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuoted_string(s)
	}
}

func (p *SyslParser) Quoted_string() (localctx IQuoted_stringContext) {
	localctx = NewQuoted_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SyslParserRULE_quoted_string)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(399)
		p.Match(SyslParserQSTRING)
	}

	return localctx
}

// IArray_of_stringsContext is an interface to support dynamic dispatch.
type IArray_of_stringsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_of_stringsContext differentiates from other interfaces.
	IsArray_of_stringsContext()
}

type Array_of_stringsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_of_stringsContext() *Array_of_stringsContext {
	var p = new(Array_of_stringsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_of_strings
	return p
}

func (*Array_of_stringsContext) IsArray_of_stringsContext() {}

func NewArray_of_stringsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_of_stringsContext {
	var p = new(Array_of_stringsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_of_strings

	return p
}

func (s *Array_of_stringsContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_of_stringsContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Array_of_stringsContext) AllQuoted_string() []IQuoted_stringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem())
	var tst = make([]IQuoted_stringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuoted_stringContext)
		}
	}

	return tst
}

func (s *Array_of_stringsContext) Quoted_string(i int) IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Array_of_stringsContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Array_of_stringsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Array_of_stringsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Array_of_stringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_of_stringsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_of_stringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_of_strings(s)
	}
}

func (s *Array_of_stringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_of_strings(s)
	}
}

func (p *SyslParser) Array_of_strings() (localctx IArray_of_stringsContext) {
	localctx = NewArray_of_stringsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SyslParserRULE_array_of_strings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(401)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(402)
		p.Quoted_string()
	}
	p.SetState(407)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(403)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(404)
			p.Quoted_string()
		}

		p.SetState(409)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(410)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IArray_of_arraysContext is an interface to support dynamic dispatch.
type IArray_of_arraysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_of_arraysContext differentiates from other interfaces.
	IsArray_of_arraysContext()
}

type Array_of_arraysContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_of_arraysContext() *Array_of_arraysContext {
	var p = new(Array_of_arraysContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_of_arrays
	return p
}

func (*Array_of_arraysContext) IsArray_of_arraysContext() {}

func NewArray_of_arraysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_of_arraysContext {
	var p = new(Array_of_arraysContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_of_arrays

	return p
}

func (s *Array_of_arraysContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_of_arraysContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Array_of_arraysContext) AllArray_of_strings() []IArray_of_stringsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem())
	var tst = make([]IArray_of_stringsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArray_of_stringsContext)
		}
	}

	return tst
}

func (s *Array_of_arraysContext) Array_of_strings(i int) IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *Array_of_arraysContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Array_of_arraysContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Array_of_arraysContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Array_of_arraysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_of_arraysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_of_arraysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_of_arrays(s)
	}
}

func (s *Array_of_arraysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_of_arrays(s)
	}
}

func (p *SyslParser) Array_of_arrays() (localctx IArray_of_arraysContext) {
	localctx = NewArray_of_arraysContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SyslParserRULE_array_of_arrays)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(412)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(413)
		p.Array_of_strings()
	}
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(414)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(415)
			p.Array_of_strings()
		}

		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(421)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// INvpContext is an interface to support dynamic dispatch.
type INvpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNvpContext differentiates from other interfaces.
	IsNvpContext()
}

type NvpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNvpContext() *NvpContext {
	var p = new(NvpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_nvp
	return p
}

func (*NvpContext) IsNvpContext() {}

func NewNvpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NvpContext {
	var p = new(NvpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_nvp

	return p
}

func (s *NvpContext) GetParser() antlr.Parser { return s.parser }

func (s *NvpContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *NvpContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *NvpContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *NvpContext) Array_of_strings() IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *NvpContext) Array_of_arrays() IArray_of_arraysContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_arraysContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_arraysContext)
}

func (s *NvpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NvpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NvpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterNvp(s)
	}
}

func (s *NvpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitNvp(s)
	}
}

func (p *SyslParser) Nvp() (localctx INvpContext) {
	localctx = NewNvpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SyslParserRULE_nvp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(423)
		p.Match(SyslParserName)
	}
	{
		p.SetState(424)
		p.Match(SyslParserEQ)
	}
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(425)
			p.Quoted_string()
		}

	case 2:
		{
			p.SetState(426)
			p.Array_of_strings()
		}

	case 3:
		{
			p.SetState(427)
			p.Array_of_arrays()
		}

	}

	return localctx
}

// IAttributesContext is an interface to support dynamic dispatch.
type IAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributesContext differentiates from other interfaces.
	IsAttributesContext()
}

type AttributesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributesContext() *AttributesContext {
	var p = new(AttributesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_attributes
	return p
}

func (*AttributesContext) IsAttributesContext() {}

func NewAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributesContext {
	var p = new(AttributesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_attributes

	return p
}

func (s *AttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributesContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *AttributesContext) AllNvp() []INvpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INvpContext)(nil)).Elem())
	var tst = make([]INvpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INvpContext)
		}
	}

	return tst
}

func (s *AttributesContext) Nvp(i int) INvpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INvpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INvpContext)
}

func (s *AttributesContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *AttributesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *AttributesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *AttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAttributes(s)
	}
}

func (s *AttributesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAttributes(s)
	}
}

func (p *SyslParser) Attributes() (localctx IAttributesContext) {
	localctx = NewAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SyslParserRULE_attributes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(430)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(431)
		p.Nvp()
	}
	p.SetState(436)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(432)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(433)
			p.Nvp()
		}

		p.SetState(438)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(439)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IEntryContext is an interface to support dynamic dispatch.
type IEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntryContext differentiates from other interfaces.
	IsEntryContext()
}

type EntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntryContext() *EntryContext {
	var p = new(EntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_entry
	return p
}

func (*EntryContext) IsEntryContext() {}

func NewEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EntryContext {
	var p = new(EntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_entry

	return p
}

func (s *EntryContext) GetParser() antlr.Parser { return s.parser }

func (s *EntryContext) Nvp() INvpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INvpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INvpContext)
}

func (s *EntryContext) Modifier() IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *EntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEntry(s)
	}
}

func (s *EntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEntry(s)
	}
}

func (p *SyslParser) Entry() (localctx IEntryContext) {
	localctx = NewEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SyslParserRULE_entry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(443)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(441)
			p.Nvp()
		}

	case SyslParserTILDE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(442)
			p.Modifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttribs_or_modifiersContext is an interface to support dynamic dispatch.
type IAttribs_or_modifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribs_or_modifiersContext differentiates from other interfaces.
	IsAttribs_or_modifiersContext()
}

type Attribs_or_modifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribs_or_modifiersContext() *Attribs_or_modifiersContext {
	var p = new(Attribs_or_modifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_attribs_or_modifiers
	return p
}

func (*Attribs_or_modifiersContext) IsAttribs_or_modifiersContext() {}

func NewAttribs_or_modifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribs_or_modifiersContext {
	var p = new(Attribs_or_modifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_attribs_or_modifiers

	return p
}

func (s *Attribs_or_modifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribs_or_modifiersContext) SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_OPEN, 0)
}

func (s *Attribs_or_modifiersContext) AllEntry() []IEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEntryContext)(nil)).Elem())
	var tst = make([]IEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEntryContext)
		}
	}

	return tst
}

func (s *Attribs_or_modifiersContext) Entry(i int) IEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEntryContext)
}

func (s *Attribs_or_modifiersContext) SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserSQ_CLOSE, 0)
}

func (s *Attribs_or_modifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Attribs_or_modifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Attribs_or_modifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribs_or_modifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribs_or_modifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAttribs_or_modifiers(s)
	}
}

func (s *Attribs_or_modifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAttribs_or_modifiers(s)
	}
}

func (p *SyslParser) Attribs_or_modifiers() (localctx IAttribs_or_modifiersContext) {
	localctx = NewAttribs_or_modifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SyslParserRULE_attribs_or_modifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(445)
		p.Match(SyslParserSQ_OPEN)
	}
	{
		p.SetState(446)
		p.Entry()
	}
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(447)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(448)
			p.Entry()
		}

		p.SetState(453)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(454)
		p.Match(SyslParserSQ_CLOSE)
	}

	return localctx
}

// IUser_defined_typeContext is an interface to support dynamic dispatch.
type IUser_defined_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUser_defined_typeContext differentiates from other interfaces.
	IsUser_defined_typeContext()
}

type User_defined_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUser_defined_typeContext() *User_defined_typeContext {
	var p = new(User_defined_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_user_defined_type
	return p
}

func (*User_defined_typeContext) IsUser_defined_typeContext() {}

func NewUser_defined_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *User_defined_typeContext {
	var p = new(User_defined_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_user_defined_type

	return p
}

func (s *User_defined_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *User_defined_typeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *User_defined_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *User_defined_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *User_defined_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUser_defined_type(s)
	}
}

func (s *User_defined_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUser_defined_type(s)
	}
}

func (p *SyslParser) User_defined_type() (localctx IUser_defined_typeContext) {
	localctx = NewUser_defined_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SyslParserRULE_user_defined_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(456)
		p.Name_str()
	}

	return localctx
}

// ITypesContext is an interface to support dynamic dispatch.
type ITypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypesContext differentiates from other interfaces.
	IsTypesContext()
}

type TypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypesContext() *TypesContext {
	var p = new(TypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_types
	return p
}

func (*TypesContext) IsTypesContext() {}

func NewTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypesContext {
	var p = new(TypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_types

	return p
}

func (s *TypesContext) GetParser() antlr.Parser { return s.parser }

func (s *TypesContext) User_defined_type() IUser_defined_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUser_defined_typeContext)
}

func (s *TypesContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *TypesContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *TypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTypes(s)
	}
}

func (s *TypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTypes(s)
	}
}

func (p *SyslParser) Types() (localctx ITypesContext) {
	localctx = NewTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SyslParserRULE_types)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(461)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(458)
			p.User_defined_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(459)
			p.Reference()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(460)
			p.Match(SyslParserNativeDataTypes)
		}

	}

	return localctx
}

// ISet_ofContext is an interface to support dynamic dispatch.
type ISet_ofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_ofContext differentiates from other interfaces.
	IsSet_ofContext()
}

type Set_ofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_ofContext() *Set_ofContext {
	var p = new(Set_ofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_set_of
	return p
}

func (*Set_ofContext) IsSet_ofContext() {}

func NewSet_ofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_ofContext {
	var p = new(Set_ofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_set_of

	return p
}

func (s *Set_ofContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_ofContext) SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserSET_OF, 0)
}

func (s *Set_ofContext) E_SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SET_OF, 0)
}

func (s *Set_ofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_ofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_ofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSet_of(s)
	}
}

func (s *Set_ofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSet_of(s)
	}
}

func (p *SyslParser) Set_of() (localctx ISet_ofContext) {
	localctx = NewSet_ofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SyslParserRULE_set_of)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(465)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(463)
			p.Match(SyslParserSET_OF)
		}

	case SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(464)
			p.Match(SyslParserE_SET_OF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISet_typeContext is an interface to support dynamic dispatch.
type ISet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_typeContext differentiates from other interfaces.
	IsSet_typeContext()
}

type Set_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_typeContext() *Set_typeContext {
	var p = new(Set_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_set_type
	return p
}

func (*Set_typeContext) IsSet_typeContext() {}

func NewSet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_typeContext {
	var p = new(Set_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_set_type

	return p
}

func (s *Set_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_typeContext) Set_of() ISet_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_ofContext)
}

func (s *Set_typeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *Set_typeContext) Size_spec() ISize_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISize_specContext)
}

func (s *Set_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSet_type(s)
	}
}

func (s *Set_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSet_type(s)
	}
}

func (p *SyslParser) Set_type() (localctx ISet_typeContext) {
	localctx = NewSet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SyslParserRULE_set_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(467)
		p.Set_of()
	}
	{
		p.SetState(468)
		p.Types()
	}
	p.SetState(470)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(469)
			p.Size_spec()
		}

	}

	return localctx
}

// ISequence_ofContext is an interface to support dynamic dispatch.
type ISequence_ofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_ofContext differentiates from other interfaces.
	IsSequence_ofContext()
}

type Sequence_ofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_ofContext() *Sequence_ofContext {
	var p = new(Sequence_ofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sequence_of
	return p
}

func (*Sequence_ofContext) IsSequence_ofContext() {}

func NewSequence_ofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_ofContext {
	var p = new(Sequence_ofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sequence_of

	return p
}

func (s *Sequence_ofContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_ofContext) SEQUENCE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserSEQUENCE_OF, 0)
}

func (s *Sequence_ofContext) E_SEQUENCE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SEQUENCE_OF, 0)
}

func (s *Sequence_ofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_ofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_ofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSequence_of(s)
	}
}

func (s *Sequence_ofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSequence_of(s)
	}
}

func (p *SyslParser) Sequence_of() (localctx ISequence_ofContext) {
	localctx = NewSequence_ofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SyslParserRULE_sequence_of)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(474)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSEQUENCE_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(472)
			p.Match(SyslParserSEQUENCE_OF)
		}

	case SyslParserE_SEQUENCE_OF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(473)
			p.Match(SyslParserE_SEQUENCE_OF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISequence_typeContext is an interface to support dynamic dispatch.
type ISequence_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_typeContext differentiates from other interfaces.
	IsSequence_typeContext()
}

type Sequence_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_typeContext() *Sequence_typeContext {
	var p = new(Sequence_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sequence_type
	return p
}

func (*Sequence_typeContext) IsSequence_typeContext() {}

func NewSequence_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_typeContext {
	var p = new(Sequence_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sequence_type

	return p
}

func (s *Sequence_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_typeContext) Sequence_of() ISequence_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_ofContext)
}

func (s *Sequence_typeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *Sequence_typeContext) Size_spec() ISize_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISize_specContext)
}

func (s *Sequence_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSequence_type(s)
	}
}

func (s *Sequence_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSequence_type(s)
	}
}

func (p *SyslParser) Sequence_type() (localctx ISequence_typeContext) {
	localctx = NewSequence_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SyslParserRULE_sequence_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(476)
		p.Sequence_of()
	}
	{
		p.SetState(477)
		p.Types()
	}
	p.SetState(479)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(478)
			p.Size_spec()
		}

	}

	return localctx
}

// ICollection_typeContext is an interface to support dynamic dispatch.
type ICollection_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollection_typeContext differentiates from other interfaces.
	IsCollection_typeContext()
}

type Collection_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollection_typeContext() *Collection_typeContext {
	var p = new(Collection_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collection_type
	return p
}

func (*Collection_typeContext) IsCollection_typeContext() {}

func NewCollection_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collection_typeContext {
	var p = new(Collection_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collection_type

	return p
}

func (s *Collection_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Collection_typeContext) Set_type() ISet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_typeContext)
}

func (s *Collection_typeContext) Sequence_type() ISequence_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_typeContext)
}

func (s *Collection_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collection_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collection_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollection_type(s)
	}
}

func (s *Collection_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollection_type(s)
	}
}

func (p *SyslParser) Collection_type() (localctx ICollection_typeContext) {
	localctx = NewCollection_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SyslParserRULE_collection_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(483)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSET_OF, SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(481)
			p.Set_type()
		}

	case SyslParserSEQUENCE_OF, SyslParserE_SEQUENCE_OF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(482)
			p.Sequence_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMulti_line_docstringContext is an interface to support dynamic dispatch.
type IMulti_line_docstringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMulti_line_docstringContext differentiates from other interfaces.
	IsMulti_line_docstringContext()
}

type Multi_line_docstringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_line_docstringContext() *Multi_line_docstringContext {
	var p = new(Multi_line_docstringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_multi_line_docstring
	return p
}

func (*Multi_line_docstringContext) IsMulti_line_docstringContext() {}

func NewMulti_line_docstringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_line_docstringContext {
	var p = new(Multi_line_docstringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_multi_line_docstring

	return p
}

func (s *Multi_line_docstringContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_line_docstringContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Multi_line_docstringContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Multi_line_docstringContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Multi_line_docstringContext) AllDoc_string() []IDoc_stringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem())
	var tst = make([]IDoc_stringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDoc_stringContext)
		}
	}

	return tst
}

func (s *Multi_line_docstringContext) Doc_string(i int) IDoc_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDoc_stringContext)
}

func (s *Multi_line_docstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_line_docstringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_line_docstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMulti_line_docstring(s)
	}
}

func (s *Multi_line_docstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMulti_line_docstring(s)
	}
}

func (p *SyslParser) Multi_line_docstring() (localctx IMulti_line_docstringContext) {
	localctx = NewMulti_line_docstringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SyslParserRULE_multi_line_docstring)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(486)
		p.Match(SyslParserINDENT)
	}
	p.SetState(488)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserPIPE {
		{
			p.SetState(487)
			p.Doc_string()
		}

		p.SetState(490)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(492)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IAnnotation_valueContext is an interface to support dynamic dispatch.
type IAnnotation_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotation_valueContext differentiates from other interfaces.
	IsAnnotation_valueContext()
}

type Annotation_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotation_valueContext() *Annotation_valueContext {
	var p = new(Annotation_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotation_value
	return p
}

func (*Annotation_valueContext) IsAnnotation_valueContext() {}

func NewAnnotation_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Annotation_valueContext {
	var p = new(Annotation_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotation_value

	return p
}

func (s *Annotation_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Annotation_valueContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Annotation_valueContext) Array_of_strings() IArray_of_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_of_stringsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_of_stringsContext)
}

func (s *Annotation_valueContext) Multi_line_docstring() IMulti_line_docstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulti_line_docstringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulti_line_docstringContext)
}

func (s *Annotation_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Annotation_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Annotation_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotation_value(s)
	}
}

func (s *Annotation_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotation_value(s)
	}
}

func (p *SyslParser) Annotation_value() (localctx IAnnotation_valueContext) {
	localctx = NewAnnotation_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SyslParserRULE_annotation_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(497)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserQSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(494)
			p.Match(SyslParserQSTRING)
		}

	case SyslParserSQ_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(495)
			p.Array_of_strings()
		}

	case SyslParserCOLON:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(496)
			p.Multi_line_docstring()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(SyslParserAT, 0)
}

func (s *AnnotationContext) VAR_NAME() antlr.TerminalNode {
	return s.GetToken(SyslParserVAR_NAME, 0)
}

func (s *AnnotationContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *AnnotationContext) Annotation_value() IAnnotation_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotation_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotation_valueContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *SyslParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SyslParserRULE_annotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(499)
		p.Match(SyslParserAT)
	}
	{
		p.SetState(500)
		p.Match(SyslParserVAR_NAME)
	}
	{
		p.SetState(501)
		p.Match(SyslParserEQ)
	}
	{
		p.SetState(502)
		p.Annotation_value()
	}

	return localctx
}

// IAnnotationsContext is an interface to support dynamic dispatch.
type IAnnotationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationsContext differentiates from other interfaces.
	IsAnnotationsContext()
}

type AnnotationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationsContext() *AnnotationsContext {
	var p = new(AnnotationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_annotations
	return p
}

func (*AnnotationsContext) IsAnnotationsContext() {}

func NewAnnotationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationsContext {
	var p = new(AnnotationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_annotations

	return p
}

func (s *AnnotationsContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationsContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *AnnotationsContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *AnnotationsContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *AnnotationsContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAnnotations(s)
	}
}

func (s *AnnotationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAnnotations(s)
	}
}

func (p *SyslParser) Annotations() (localctx IAnnotationsContext) {
	localctx = NewAnnotationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SyslParserRULE_annotations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(504)
		p.Match(SyslParserINDENT)
	}
	p.SetState(506)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserAT {
		{
			p.SetState(505)
			p.Annotation()
		}

		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(510)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IField_typeContext is an interface to support dynamic dispatch.
type IField_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsField_typeContext differentiates from other interfaces.
	IsField_typeContext()
}

type Field_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_typeContext() *Field_typeContext {
	var p = new(Field_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_field_type
	return p
}

func (*Field_typeContext) IsField_typeContext() {}

func NewField_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_typeContext {
	var p = new(Field_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_field_type

	return p
}

func (s *Field_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_typeContext) Collection_type() ICollection_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *Field_typeContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Field_typeContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Field_typeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Field_typeContext) Annotations() IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *Field_typeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *Field_typeContext) Array_size() IArray_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_sizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_sizeContext)
}

func (s *Field_typeContext) Size_spec() ISize_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISize_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISize_specContext)
}

func (s *Field_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterField_type(s)
	}
}

func (s *Field_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitField_type(s)
	}
}

func (p *SyslParser) Field_type() (localctx IField_typeContext) {
	localctx = NewField_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SyslParserRULE_field_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(518)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
		{
			p.SetState(512)
			p.Collection_type()
		}

	case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(513)
			p.Types()
		}
		p.SetState(516)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(514)
				p.Array_size()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(515)
				p.Size_spec()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(520)
			p.Match(SyslParserQN)
		}

	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(523)
			p.Attribs_or_modifiers()
		}

	}
	p.SetState(528)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserCOLON {
		{
			p.SetState(526)
			p.Match(SyslParserCOLON)
		}
		{
			p.SetState(527)
			p.Annotations()
		}

	}

	return localctx
}

// IArray_sizeContext is an interface to support dynamic dispatch.
type IArray_sizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_sizeContext differentiates from other interfaces.
	IsArray_sizeContext()
}

type Array_sizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_sizeContext() *Array_sizeContext {
	var p = new(Array_sizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_array_size
	return p
}

func (*Array_sizeContext) IsArray_sizeContext() {}

func NewArray_sizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_sizeContext {
	var p = new(Array_sizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_array_size

	return p
}

func (s *Array_sizeContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_sizeContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Array_sizeContext) AllDIGITS() []antlr.TerminalNode {
	return s.GetTokens(SyslParserDIGITS)
}

func (s *Array_sizeContext) DIGITS(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, i)
}

func (s *Array_sizeContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(SyslParserDOTDOT, 0)
}

func (s *Array_sizeContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Array_sizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_sizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_sizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterArray_size(s)
	}
}

func (s *Array_sizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitArray_size(s)
	}
}

func (p *SyslParser) Array_size() (localctx IArray_sizeContext) {
	localctx = NewArray_sizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SyslParserRULE_array_size)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(530)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(531)
		p.Match(SyslParserDIGITS)
	}
	{
		p.SetState(532)
		p.Match(SyslParserDOTDOT)
	}
	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserDIGITS {
		{
			p.SetState(533)
			p.Match(SyslParserDIGITS)
		}

	}
	{
		p.SetState(536)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IInplace_tupleContext is an interface to support dynamic dispatch.
type IInplace_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_tupleContext differentiates from other interfaces.
	IsInplace_tupleContext()
}

type Inplace_tupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_tupleContext() *Inplace_tupleContext {
	var p = new(Inplace_tupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_tuple
	return p
}

func (*Inplace_tupleContext) IsInplace_tupleContext() {}

func NewInplace_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_tupleContext {
	var p = new(Inplace_tupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_tuple

	return p
}

func (s *Inplace_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_tupleContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Inplace_tupleContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Inplace_tupleContext) AllField() []IFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldContext)(nil)).Elem())
	var tst = make([]IFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldContext)
		}
	}

	return tst
}

func (s *Inplace_tupleContext) Field(i int) IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *Inplace_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_tuple(s)
	}
}

func (s *Inplace_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_tuple(s)
	}
}

func (p *SyslParser) Inplace_tuple() (localctx IInplace_tupleContext) {
	localctx = NewInplace_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SyslParserRULE_inplace_tuple)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(538)
		p.Match(SyslParserINDENT)
	}
	p.SetState(540)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name {
		{
			p.SetState(539)
			p.Field()
		}

		p.SetState(542)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(544)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IFieldContext is an interface to support dynamic dispatch.
type IFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldContext differentiates from other interfaces.
	IsFieldContext()
}

type FieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldContext() *FieldContext {
	var p = new(FieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_field
	return p
}

func (*FieldContext) IsFieldContext() {}

func NewFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldContext {
	var p = new(FieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_field

	return p
}

func (s *FieldContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *FieldContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *FieldContext) Field_type() IField_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IField_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IField_typeContext)
}

func (s *FieldContext) Inplace_tuple() IInplace_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_tupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInplace_tupleContext)
}

func (s *FieldContext) Array_size() IArray_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_sizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_sizeContext)
}

func (s *FieldContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *FieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterField(s)
	}
}

func (s *FieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitField(s)
	}
}

func (p *SyslParser) Field() (localctx IFieldContext) {
	localctx = NewFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SyslParserRULE_field)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(546)
		p.Name_str()
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserLESS_COLON || _la == SyslParserOPEN_PAREN {
		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserOPEN_PAREN {
			{
				p.SetState(547)
				p.Array_size()
			}

		}
		{
			p.SetState(550)
			p.Match(SyslParserLESS_COLON)
		}
		p.SetState(553)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserNativeDataTypes, SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserTEXT_LINE, SyslParserName, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF, SyslParserE_Name:
			{
				p.SetState(551)
				p.Field_type()
			}

		case SyslParserINDENT:
			{
				p.SetState(552)
				p.Inplace_tuple()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserQSTRING {
			{
				p.SetState(555)
				p.Match(SyslParserQSTRING)
			}

		}

	}

	return localctx
}

// IInplace_tableContext is an interface to support dynamic dispatch.
type IInplace_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_tableContext differentiates from other interfaces.
	IsInplace_tableContext()
}

type Inplace_tableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_tableContext() *Inplace_tableContext {
	var p = new(Inplace_tableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_table
	return p
}

func (*Inplace_tableContext) IsInplace_tableContext() {}

func NewInplace_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_tableContext {
	var p = new(Inplace_tableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_table

	return p
}

func (s *Inplace_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_tableContext) Table() ITableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *Inplace_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_table(s)
	}
}

func (s *Inplace_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_table(s)
	}
}

func (p *SyslParser) Inplace_table() (localctx IInplace_tableContext) {
	localctx = NewInplace_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SyslParserRULE_inplace_table)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(560)
		p.Table()
	}

	return localctx
}

// ITable_stmtsContext is an interface to support dynamic dispatch.
type ITable_stmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_stmtsContext differentiates from other interfaces.
	IsTable_stmtsContext()
}

type Table_stmtsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_stmtsContext() *Table_stmtsContext {
	var p = new(Table_stmtsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table_stmts
	return p
}

func (*Table_stmtsContext) IsTable_stmtsContext() {}

func NewTable_stmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_stmtsContext {
	var p = new(Table_stmtsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table_stmts

	return p
}

func (s *Table_stmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_stmtsContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Table_stmtsContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Table_stmtsContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *Table_stmtsContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *Table_stmtsContext) AllField() []IFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldContext)(nil)).Elem())
	var tst = make([]IFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldContext)
		}
	}

	return tst
}

func (s *Table_stmtsContext) Field(i int) IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *Table_stmtsContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *Table_stmtsContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *Table_stmtsContext) AllInplace_table() []IInplace_tableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInplace_tableContext)(nil)).Elem())
	var tst = make([]IInplace_tableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInplace_tableContext)
		}
	}

	return tst
}

func (s *Table_stmtsContext) Inplace_table(i int) IInplace_tableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_tableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInplace_tableContext)
}

func (s *Table_stmtsContext) AllWHATEVER() []antlr.TerminalNode {
	return s.GetTokens(SyslParserWHATEVER)
}

func (s *Table_stmtsContext) WHATEVER(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, i)
}

func (s *Table_stmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_stmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_stmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable_stmts(s)
	}
}

func (s *Table_stmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable_stmts(s)
	}
}

func (p *SyslParser) Table_stmts() (localctx ITable_stmtsContext) {
	localctx = NewTable_stmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SyslParserRULE_table_stmts)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(562)
		p.Match(SyslParserINDENT)
	}
	p.SetState(568)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserWHATEVER))) != 0) || (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(SyslParserAT-43))|(1<<(SyslParserSYSL_COMMENT-43))|(1<<(SyslParserTEXT_LINE-43))|(1<<(SyslParserName-43)))) != 0) || _la == SyslParserE_Name {
		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(563)
				p.Match(SyslParserSYSL_COMMENT)
			}

		case 2:
			{
				p.SetState(564)
				p.Field()
			}

		case 3:
			{
				p.SetState(565)
				p.Annotation()
			}

		case 4:
			{
				p.SetState(566)
				p.Inplace_table()
			}

		case 5:
			{
				p.SetState(567)
				p.Match(SyslParserWHATEVER)
			}

		}

		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(572)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// ITable_defContext is an interface to support dynamic dispatch.
type ITable_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_defContext differentiates from other interfaces.
	IsTable_defContext()
}

type Table_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_defContext() *Table_defContext {
	var p = new(Table_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table_def
	return p
}

func (*Table_defContext) IsTable_defContext() {}

func NewTable_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_defContext {
	var p = new(Table_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table_def

	return p
}

func (s *Table_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_defContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Table_defContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *Table_defContext) Table_stmts() ITable_stmtsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_stmtsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_stmtsContext)
}

func (s *Table_defContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Table_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable_def(s)
	}
}

func (s *Table_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable_def(s)
	}
}

func (p *SyslParser) Table_def() (localctx ITable_defContext) {
	localctx = NewTable_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SyslParserRULE_table_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(575)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(574)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(577)
		p.Match(SyslParserCOLON)
	}
	p.SetState(580)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(578)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(579)
			p.Table_stmts()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITableContext is an interface to support dynamic dispatch.
type ITableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableContext differentiates from other interfaces.
	IsTableContext()
}

type TableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableContext() *TableContext {
	var p = new(TableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table
	return p
}

func (*TableContext) IsTableContext() {}

func NewTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableContext {
	var p = new(TableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table

	return p
}

func (s *TableContext) GetParser() antlr.Parser { return s.parser }

func (s *TableContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *TableContext) Table_def() ITable_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_defContext)
}

func (s *TableContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SyslParserTYPE, 0)
}

func (s *TableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SyslParserTABLE, 0)
}

func (s *TableContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *TableContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable(s)
	}
}

func (p *SyslParser) Table() (localctx ITableContext) {
	localctx = NewTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SyslParserRULE_table)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(582)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(587)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(588)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserTABLE || _la == SyslParserTYPE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(589)
		p.Name_str()
	}
	{
		p.SetState(590)
		p.Table_def()
	}

	return localctx
}

// IUnionContext is an interface to support dynamic dispatch.
type IUnionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionContext differentiates from other interfaces.
	IsUnionContext()
}

type UnionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionContext() *UnionContext {
	var p = new(UnionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_union
	return p
}

func (*UnionContext) IsUnionContext() {}

func NewUnionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionContext {
	var p = new(UnionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_union

	return p
}

func (s *UnionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(SyslParserUNION, 0)
}

func (s *UnionContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *UnionContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *UnionContext) AllWHATEVER() []antlr.TerminalNode {
	return s.GetTokens(SyslParserWHATEVER)
}

func (s *UnionContext) WHATEVER(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, i)
}

func (s *UnionContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *UnionContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *UnionContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *UnionContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *UnionContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *UnionContext) AllUser_defined_type() []IUser_defined_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem())
	var tst = make([]IUser_defined_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUser_defined_typeContext)
		}
	}

	return tst
}

func (s *UnionContext) User_defined_type(i int) IUser_defined_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUser_defined_typeContext)
}

func (s *UnionContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *UnionContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *UnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUnion(s)
	}
}

func (s *UnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUnion(s)
	}
}

func (p *SyslParser) Union() (localctx IUnionContext) {
	localctx = NewUnionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SyslParserRULE_union)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(592)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(598)
		p.Match(SyslParserUNION)
	}
	{
		p.SetState(599)
		p.Name_str()
	}
	p.SetState(601)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(600)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(603)
		p.Match(SyslParserCOLON)
	}
	p.SetState(615)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(604)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(605)
			p.Match(SyslParserINDENT)
		}
		p.SetState(610)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserWHATEVER || (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(SyslParserAT-43))|(1<<(SyslParserSYSL_COMMENT-43))|(1<<(SyslParserTEXT_LINE-43))|(1<<(SyslParserName-43)))) != 0) || _la == SyslParserE_Name {
			p.SetState(610)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SyslParserSYSL_COMMENT:
				{
					p.SetState(606)
					p.Match(SyslParserSYSL_COMMENT)
				}

			case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
				{
					p.SetState(607)
					p.User_defined_type()
				}

			case SyslParserAT:
				{
					p.SetState(608)
					p.Annotation()
				}

			case SyslParserWHATEVER:
				{
					p.SetState(609)
					p.Match(SyslParserWHATEVER)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(612)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(614)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPackage_nameContext is an interface to support dynamic dispatch.
type IPackage_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_nameContext differentiates from other interfaces.
	IsPackage_nameContext()
}

type Package_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_nameContext() *Package_nameContext {
	var p = new(Package_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_package_name
	return p
}

func (*Package_nameContext) IsPackage_nameContext() {}

func NewPackage_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_nameContext {
	var p = new(Package_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_package_name

	return p
}

func (s *Package_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_nameContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Package_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPackage_name(s)
	}
}

func (s *Package_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPackage_name(s)
	}
}

func (p *SyslParser) Package_name() (localctx IPackage_nameContext) {
	localctx = NewPackage_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SyslParserRULE_package_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.Name_str()
	}

	return localctx
}

// ISub_packageContext is an interface to support dynamic dispatch.
type ISub_packageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSub_packageContext differentiates from other interfaces.
	IsSub_packageContext()
}

type Sub_packageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySub_packageContext() *Sub_packageContext {
	var p = new(Sub_packageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sub_package
	return p
}

func (*Sub_packageContext) IsSub_packageContext() {}

func NewSub_packageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sub_packageContext {
	var p = new(Sub_packageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sub_package

	return p
}

func (s *Sub_packageContext) GetParser() antlr.Parser { return s.parser }

func (s *Sub_packageContext) NAME_SEP() antlr.TerminalNode {
	return s.GetToken(SyslParserNAME_SEP, 0)
}

func (s *Sub_packageContext) Package_name() IPackage_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_nameContext)
}

func (s *Sub_packageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sub_packageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sub_packageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSub_package(s)
	}
}

func (s *Sub_packageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSub_package(s)
	}
}

func (p *SyslParser) Sub_package() (localctx ISub_packageContext) {
	localctx = NewSub_packageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SyslParserRULE_sub_package)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(619)
		p.Match(SyslParserNAME_SEP)
	}
	{
		p.SetState(620)
		p.Package_name()
	}

	return localctx
}

// IApp_nameContext is an interface to support dynamic dispatch.
type IApp_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsApp_nameContext differentiates from other interfaces.
	IsApp_nameContext()
}

type App_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApp_nameContext() *App_nameContext {
	var p = new(App_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_app_name
	return p
}

func (*App_nameContext) IsApp_nameContext() {}

func NewApp_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *App_nameContext {
	var p = new(App_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_app_name

	return p
}

func (s *App_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *App_nameContext) Package_name() IPackage_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_nameContext)
}

func (s *App_nameContext) AllSub_package() []ISub_packageContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISub_packageContext)(nil)).Elem())
	var tst = make([]ISub_packageContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISub_packageContext)
		}
	}

	return tst
}

func (s *App_nameContext) Sub_package(i int) ISub_packageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISub_packageContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISub_packageContext)
}

func (s *App_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *App_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *App_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApp_name(s)
	}
}

func (s *App_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApp_name(s)
	}
}

func (p *SyslParser) App_name() (localctx IApp_nameContext) {
	localctx = NewApp_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SyslParserRULE_app_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(622)
		p.Package_name()
	}
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(623)
				p.Sub_package()
			}

		}
		p.SetState(628)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())
	}

	return localctx
}

// IName_with_attribsContext is an interface to support dynamic dispatch.
type IName_with_attribsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_with_attribsContext differentiates from other interfaces.
	IsName_with_attribsContext()
}

type Name_with_attribsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_with_attribsContext() *Name_with_attribsContext {
	var p = new(Name_with_attribsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_name_with_attribs
	return p
}

func (*Name_with_attribsContext) IsName_with_attribsContext() {}

func NewName_with_attribsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_with_attribsContext {
	var p = new(Name_with_attribsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_name_with_attribs

	return p
}

func (s *Name_with_attribsContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_with_attribsContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *Name_with_attribsContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Name_with_attribsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Name_with_attribsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_with_attribsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_with_attribsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterName_with_attribs(s)
	}
}

func (s *Name_with_attribsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitName_with_attribs(s)
	}
}

func (p *SyslParser) Name_with_attribs() (localctx IName_with_attribsContext) {
	localctx = NewName_with_attribsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SyslParserRULE_name_with_attribs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(629)
		p.App_name()
	}
	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQSTRING {
		{
			p.SetState(630)
			p.Match(SyslParserQSTRING)
		}

	}
	p.SetState(634)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(633)
			p.Attribs_or_modifiers()
		}

	}

	return localctx
}

// IModel_nameContext is an interface to support dynamic dispatch.
type IModel_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_nameContext differentiates from other interfaces.
	IsModel_nameContext()
}

type Model_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_nameContext() *Model_nameContext {
	var p = new(Model_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_model_name
	return p
}

func (*Model_nameContext) IsModel_nameContext() {}

func NewModel_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_nameContext {
	var p = new(Model_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_model_name

	return p
}

func (s *Model_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_nameContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Model_nameContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Model_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterModel_name(s)
	}
}

func (s *Model_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitModel_name(s)
	}
}

func (p *SyslParser) Model_name() (localctx IModel_nameContext) {
	localctx = NewModel_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SyslParserRULE_model_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(636)
		p.Match(SyslParserName)
	}
	{
		p.SetState(637)
		p.Match(SyslParserCOLON)
	}

	return localctx
}

// IInplace_table_defContext is an interface to support dynamic dispatch.
type IInplace_table_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInplace_table_defContext differentiates from other interfaces.
	IsInplace_table_defContext()
}

type Inplace_table_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInplace_table_defContext() *Inplace_table_defContext {
	var p = new(Inplace_table_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_inplace_table_def
	return p
}

func (*Inplace_table_defContext) IsInplace_table_defContext() {}

func NewInplace_table_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inplace_table_defContext {
	var p = new(Inplace_table_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_inplace_table_def

	return p
}

func (s *Inplace_table_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Inplace_table_defContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Inplace_table_defContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Inplace_table_defContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Inplace_table_defContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *Inplace_table_defContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *Inplace_table_defContext) AllAttribs_or_modifiers() []IAttribs_or_modifiersContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem())
	var tst = make([]IAttribs_or_modifiersContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribs_or_modifiersContext)
		}
	}

	return tst
}

func (s *Inplace_table_defContext) Attribs_or_modifiers(i int) IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Inplace_table_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inplace_table_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inplace_table_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterInplace_table_def(s)
	}
}

func (s *Inplace_table_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitInplace_table_def(s)
	}
}

func (p *SyslParser) Inplace_table_def() (localctx IInplace_table_defContext) {
	localctx = NewInplace_table_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SyslParserRULE_inplace_table_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(639)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(640)
		p.Match(SyslParserINDENT)
	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserName {
		{
			p.SetState(641)
			p.Match(SyslParserName)
		}
		p.SetState(643)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(642)
				p.Attribs_or_modifiers()
			}

		}

		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(649)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// ITable_refsContext is an interface to support dynamic dispatch.
type ITable_refsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_refsContext differentiates from other interfaces.
	IsTable_refsContext()
}

type Table_refsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_refsContext() *Table_refsContext {
	var p = new(Table_refsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_table_refs
	return p
}

func (*Table_refsContext) IsTable_refsContext() {}

func NewTable_refsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_refsContext {
	var p = new(Table_refsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_table_refs

	return p
}

func (s *Table_refsContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_refsContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Table_refsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SyslParserTABLE, 0)
}

func (s *Table_refsContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SyslParserTYPE, 0)
}

func (s *Table_refsContext) UNION() antlr.TerminalNode {
	return s.GetToken(SyslParserUNION, 0)
}

func (s *Table_refsContext) Inplace_table_def() IInplace_table_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInplace_table_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInplace_table_defContext)
}

func (s *Table_refsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_refsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_refsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTable_refs(s)
	}
}

func (s *Table_refsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTable_refs(s)
	}
}

func (p *SyslParser) Table_refs() (localctx ITable_refsContext) {
	localctx = NewTable_refsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SyslParserRULE_table_refs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(651)
	_la = p.GetTokenStream().LA(1)

	if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserUNION))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(652)
		p.Match(SyslParserName)
	}
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserCOLON {
		{
			p.SetState(653)
			p.Inplace_table_def()
		}

	}

	return localctx
}

// IFacadeContext is an interface to support dynamic dispatch.
type IFacadeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFacadeContext differentiates from other interfaces.
	IsFacadeContext()
}

type FacadeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFacadeContext() *FacadeContext {
	var p = new(FacadeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_facade
	return p
}

func (*FacadeContext) IsFacadeContext() {}

func NewFacadeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FacadeContext {
	var p = new(FacadeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_facade

	return p
}

func (s *FacadeContext) GetParser() antlr.Parser { return s.parser }

func (s *FacadeContext) WRAP() antlr.TerminalNode {
	return s.GetToken(SyslParserWRAP, 0)
}

func (s *FacadeContext) Model_name() IModel_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModel_nameContext)
}

func (s *FacadeContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *FacadeContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *FacadeContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *FacadeContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *FacadeContext) AllTable_refs() []ITable_refsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_refsContext)(nil)).Elem())
	var tst = make([]ITable_refsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_refsContext)
		}
	}

	return tst
}

func (s *FacadeContext) Table_refs(i int) ITable_refsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_refsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_refsContext)
}

func (s *FacadeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FacadeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FacadeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFacade(s)
	}
}

func (s *FacadeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFacade(s)
	}
}

func (p *SyslParser) Facade() (localctx IFacadeContext) {
	localctx = NewFacadeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SyslParserRULE_facade)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(659)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(656)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(661)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(662)
		p.Match(SyslParserWRAP)
	}
	{
		p.SetState(663)
		p.Model_name()
	}
	{
		p.SetState(664)
		p.Match(SyslParserINDENT)
	}
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserTABLE)|(1<<SyslParserTYPE)|(1<<SyslParserUNION))) != 0) {
		{
			p.SetState(665)
			p.Table_refs()
		}

		p.SetState(668)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(670)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IDocumentation_stmtsContext is an interface to support dynamic dispatch.
type IDocumentation_stmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDocumentation_stmtsContext differentiates from other interfaces.
	IsDocumentation_stmtsContext()
}

type Documentation_stmtsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDocumentation_stmtsContext() *Documentation_stmtsContext {
	var p = new(Documentation_stmtsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_documentation_stmts
	return p
}

func (*Documentation_stmtsContext) IsDocumentation_stmtsContext() {}

func NewDocumentation_stmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Documentation_stmtsContext {
	var p = new(Documentation_stmtsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_documentation_stmts

	return p
}

func (s *Documentation_stmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *Documentation_stmtsContext) AT() antlr.TerminalNode {
	return s.GetToken(SyslParserAT, 0)
}

func (s *Documentation_stmtsContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Documentation_stmtsContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *Documentation_stmtsContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Documentation_stmtsContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(SyslParserNEWLINE, 0)
}

func (s *Documentation_stmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Documentation_stmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Documentation_stmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterDocumentation_stmts(s)
	}
}

func (s *Documentation_stmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitDocumentation_stmts(s)
	}
}

func (p *SyslParser) Documentation_stmts() (localctx IDocumentation_stmtsContext) {
	localctx = NewDocumentation_stmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SyslParserRULE_documentation_stmts)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(672)
		p.Match(SyslParserAT)
	}
	{
		p.SetState(673)
		p.Match(SyslParserName)
	}
	{
		p.SetState(674)
		p.Match(SyslParserEQ)
	}
	{
		p.SetState(675)
		p.Match(SyslParserQSTRING)
	}
	{
		p.SetState(676)
		p.Match(SyslParserNEWLINE)
	}

	return localctx
}

// IVar_in_curlyContext is an interface to support dynamic dispatch.
type IVar_in_curlyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVar_in_curlyContext differentiates from other interfaces.
	IsVar_in_curlyContext()
}

type Var_in_curlyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_in_curlyContext() *Var_in_curlyContext {
	var p = new(Var_in_curlyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_var_in_curly
	return p
}

func (*Var_in_curlyContext) IsVar_in_curlyContext() {}

func NewVar_in_curlyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_in_curlyContext {
	var p = new(Var_in_curlyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_var_in_curly

	return p
}

func (s *Var_in_curlyContext) GetParser() antlr.Parser { return s.parser }

func (s *Var_in_curlyContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Var_in_curlyContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Var_in_curlyContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Var_in_curlyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_in_curlyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_in_curlyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterVar_in_curly(s)
	}
}

func (s *Var_in_curlyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitVar_in_curly(s)
	}
}

func (p *SyslParser) Var_in_curly() (localctx IVar_in_curlyContext) {
	localctx = NewVar_in_curlyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SyslParserRULE_var_in_curly)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		p.Match(SyslParserCURLY_OPEN)
	}
	{
		p.SetState(679)
		p.Match(SyslParserName)
	}
	{
		p.SetState(680)
		p.Match(SyslParserCURLY_CLOSE)
	}

	return localctx
}

// IQuery_varContext is an interface to support dynamic dispatch.
type IQuery_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuery_varContext differentiates from other interfaces.
	IsQuery_varContext()
}

type Query_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_varContext() *Query_varContext {
	var p = new(Query_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_query_var
	return p
}

func (*Query_varContext) IsQuery_varContext() {}

func NewQuery_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_varContext {
	var p = new(Query_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_query_var

	return p
}

func (s *Query_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_varContext) Name() antlr.TerminalNode {
	return s.GetToken(SyslParserName, 0)
}

func (s *Query_varContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *Query_varContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Query_varContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Query_varContext) Var_in_curly() IVar_in_curlyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVar_in_curlyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVar_in_curlyContext)
}

func (s *Query_varContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Query_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuery_var(s)
	}
}

func (s *Query_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuery_var(s)
	}
}

func (p *SyslParser) Query_var() (localctx IQuery_varContext) {
	localctx = NewQuery_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SyslParserRULE_query_var)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(682)
		p.Match(SyslParserName)
	}
	{
		p.SetState(683)
		p.Match(SyslParserEQ)
	}
	p.SetState(687)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes:
		{
			p.SetState(684)
			p.Match(SyslParserNativeDataTypes)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(685)
			p.Name_str()
		}

	case SyslParserCURLY_OPEN:
		{
			p.SetState(686)
			p.Var_in_curly()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(690)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(689)
			p.Match(SyslParserQN)
		}

	}

	return localctx
}

// IQuery_paramContext is an interface to support dynamic dispatch.
type IQuery_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuery_paramContext differentiates from other interfaces.
	IsQuery_paramContext()
}

type Query_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_paramContext() *Query_paramContext {
	var p = new(Query_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_query_param
	return p
}

func (*Query_paramContext) IsQuery_paramContext() {}

func NewQuery_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_paramContext {
	var p = new(Query_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_query_param

	return p
}

func (s *Query_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_paramContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Query_paramContext) AllQuery_var() []IQuery_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQuery_varContext)(nil)).Elem())
	var tst = make([]IQuery_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQuery_varContext)
		}
	}

	return tst
}

func (s *Query_paramContext) Query_var(i int) IQuery_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQuery_varContext)
}

func (s *Query_paramContext) AllAMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserAMP)
}

func (s *Query_paramContext) AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserAMP, i)
}

func (s *Query_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterQuery_param(s)
	}
}

func (s *Query_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitQuery_param(s)
	}
}

func (p *SyslParser) Query_param() (localctx IQuery_paramContext) {
	localctx = NewQuery_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SyslParserRULE_query_param)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(692)
		p.Match(SyslParserQN)
	}
	{
		p.SetState(693)
		p.Query_var()
	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserAMP {
		{
			p.SetState(694)
			p.Match(SyslParserAMP)
		}
		{
			p.SetState(695)
			p.Query_var()
		}

		p.SetState(700)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IHttp_path_partContext is an interface to support dynamic dispatch.
type IHttp_path_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_partContext differentiates from other interfaces.
	IsHttp_path_partContext()
}

type Http_path_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_partContext() *Http_path_partContext {
	var p = new(Http_path_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_part
	return p
}

func (*Http_path_partContext) IsHttp_path_partContext() {}

func NewHttp_path_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_partContext {
	var p = new(Http_path_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_part

	return p
}

func (s *Http_path_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_partContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Http_path_partContext) DIGITS() antlr.TerminalNode {
	return s.GetToken(SyslParserDIGITS, 0)
}

func (s *Http_path_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_part(s)
	}
}

func (s *Http_path_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_part(s)
	}
}

func (p *SyslParser) Http_path_part() (localctx IHttp_path_partContext) {
	localctx = NewHttp_path_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SyslParserRULE_http_path_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(703)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(701)
			p.Name_str()
		}

	case SyslParserDIGITS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(702)
			p.Match(SyslParserDIGITS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHttp_path_var_with_typeContext is an interface to support dynamic dispatch.
type IHttp_path_var_with_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_var_with_typeContext differentiates from other interfaces.
	IsHttp_path_var_with_typeContext()
}

type Http_path_var_with_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_var_with_typeContext() *Http_path_var_with_typeContext {
	var p = new(Http_path_var_with_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_var_with_type
	return p
}

func (*Http_path_var_with_typeContext) IsHttp_path_var_with_typeContext() {}

func NewHttp_path_var_with_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_var_with_typeContext {
	var p = new(Http_path_var_with_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_var_with_type

	return p
}

func (s *Http_path_var_with_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_var_with_typeContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Http_path_var_with_typeContext) Http_path_part() IHttp_path_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_partContext)
}

func (s *Http_path_var_with_typeContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *Http_path_var_with_typeContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Http_path_var_with_typeContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Http_path_var_with_typeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Http_path_var_with_typeContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *Http_path_var_with_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_var_with_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_var_with_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_var_with_type(s)
	}
}

func (s *Http_path_var_with_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_var_with_type(s)
	}
}

func (p *SyslParser) Http_path_var_with_type() (localctx IHttp_path_var_with_typeContext) {
	localctx = NewHttp_path_var_with_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SyslParserRULE_http_path_var_with_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(705)
		p.Match(SyslParserCURLY_OPEN)
	}
	{
		p.SetState(706)
		p.Http_path_part()
	}
	{
		p.SetState(707)
		p.Match(SyslParserLESS_COLON)
	}
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(708)
			p.Match(SyslParserNativeDataTypes)
		}

	case 2:
		{
			p.SetState(709)
			p.Name_str()
		}

	case 3:
		{
			p.SetState(710)
			p.Reference()
		}

	}
	{
		p.SetState(713)
		p.Match(SyslParserCURLY_CLOSE)
	}

	return localctx
}

// IHttp_path_staticContext is an interface to support dynamic dispatch.
type IHttp_path_staticContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_staticContext differentiates from other interfaces.
	IsHttp_path_staticContext()
}

type Http_path_staticContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_staticContext() *Http_path_staticContext {
	var p = new(Http_path_staticContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_static
	return p
}

func (*Http_path_staticContext) IsHttp_path_staticContext() {}

func NewHttp_path_staticContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_staticContext {
	var p = new(Http_path_staticContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_static

	return p
}

func (s *Http_path_staticContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_staticContext) Http_path_part() IHttp_path_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_partContext)
}

func (s *Http_path_staticContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_staticContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_staticContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_static(s)
	}
}

func (s *Http_path_staticContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_static(s)
	}
}

func (p *SyslParser) Http_path_static() (localctx IHttp_path_staticContext) {
	localctx = NewHttp_path_staticContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SyslParserRULE_http_path_static)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(715)
		p.Http_path_part()
	}

	return localctx
}

// IHttp_path_suffixContext is an interface to support dynamic dispatch.
type IHttp_path_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_path_suffixContext differentiates from other interfaces.
	IsHttp_path_suffixContext()
}

type Http_path_suffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_path_suffixContext() *Http_path_suffixContext {
	var p = new(Http_path_suffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path_suffix
	return p
}

func (*Http_path_suffixContext) IsHttp_path_suffixContext() {}

func NewHttp_path_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_path_suffixContext {
	var p = new(Http_path_suffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path_suffix

	return p
}

func (s *Http_path_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_path_suffixContext) FORWARD_SLASH() antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, 0)
}

func (s *Http_path_suffixContext) Http_path_static() IHttp_path_staticContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_staticContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_staticContext)
}

func (s *Http_path_suffixContext) Http_path_var_with_type() IHttp_path_var_with_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_var_with_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_var_with_typeContext)
}

func (s *Http_path_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_path_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_path_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path_suffix(s)
	}
}

func (s *Http_path_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path_suffix(s)
	}
}

func (p *SyslParser) Http_path_suffix() (localctx IHttp_path_suffixContext) {
	localctx = NewHttp_path_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SyslParserRULE_http_path_suffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(717)
		p.Match(SyslParserFORWARD_SLASH)
	}
	p.SetState(720)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserDIGITS, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(718)
			p.Http_path_static()
		}

	case SyslParserCURLY_OPEN:
		{
			p.SetState(719)
			p.Http_path_var_with_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHttp_pathContext is an interface to support dynamic dispatch.
type IHttp_pathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_pathContext differentiates from other interfaces.
	IsHttp_pathContext()
}

type Http_pathContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_pathContext() *Http_pathContext {
	var p = new(Http_pathContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_path
	return p
}

func (*Http_pathContext) IsHttp_pathContext() {}

func NewHttp_pathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_pathContext {
	var p = new(Http_pathContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_path

	return p
}

func (s *Http_pathContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_pathContext) FORWARD_SLASH() antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, 0)
}

func (s *Http_pathContext) AllHttp_path_suffix() []IHttp_path_suffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHttp_path_suffixContext)(nil)).Elem())
	var tst = make([]IHttp_path_suffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHttp_path_suffixContext)
		}
	}

	return tst
}

func (s *Http_pathContext) Http_path_suffix(i int) IHttp_path_suffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_path_suffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHttp_path_suffixContext)
}

func (s *Http_pathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_pathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_pathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_path(s)
	}
}

func (s *Http_pathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_path(s)
	}
}

func (p *SyslParser) Http_path() (localctx IHttp_pathContext) {
	localctx = NewHttp_pathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SyslParserRULE_http_path)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(722)
			p.Match(SyslParserFORWARD_SLASH)
		}

	case 2:
		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserFORWARD_SLASH {
			{
				p.SetState(723)
				p.Http_path_suffix()
			}

			p.SetState(726)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IEndpoint_nameContext is an interface to support dynamic dispatch.
type IEndpoint_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndpoint_nameContext differentiates from other interfaces.
	IsEndpoint_nameContext()
}

type Endpoint_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndpoint_nameContext() *Endpoint_nameContext {
	var p = new(Endpoint_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_endpoint_name
	return p
}

func (*Endpoint_nameContext) IsEndpoint_nameContext() {}

func NewEndpoint_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Endpoint_nameContext {
	var p = new(Endpoint_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_endpoint_name

	return p
}

func (s *Endpoint_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Endpoint_nameContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Endpoint_nameContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Endpoint_nameContext) AllFORWARD_SLASH() []antlr.TerminalNode {
	return s.GetTokens(SyslParserFORWARD_SLASH)
}

func (s *Endpoint_nameContext) FORWARD_SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, i)
}

func (s *Endpoint_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Endpoint_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Endpoint_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEndpoint_name(s)
	}
}

func (s *Endpoint_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEndpoint_name(s)
	}
}

func (p *SyslParser) Endpoint_name() (localctx IEndpoint_nameContext) {
	localctx = NewEndpoint_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SyslParserRULE_endpoint_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(730)
		p.Name_str()
	}
	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserFORWARD_SLASH {
		{
			p.SetState(731)
			p.Match(SyslParserFORWARD_SLASH)
		}
		{
			p.SetState(732)
			p.Name_str()
		}

		p.SetState(737)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRet_stmtContext is an interface to support dynamic dispatch.
type IRet_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRet_stmtContext differentiates from other interfaces.
	IsRet_stmtContext()
}

type Ret_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRet_stmtContext() *Ret_stmtContext {
	var p = new(Ret_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_ret_stmt
	return p
}

func (*Ret_stmtContext) IsRet_stmtContext() {}

func NewRet_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ret_stmtContext {
	var p = new(Ret_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_ret_stmt

	return p
}

func (s *Ret_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Ret_stmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SyslParserRETURN, 0)
}

func (s *Ret_stmtContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT, 0)
}

func (s *Ret_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ret_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ret_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRet_stmt(s)
	}
}

func (s *Ret_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRet_stmt(s)
	}
}

func (p *SyslParser) Ret_stmt() (localctx IRet_stmtContext) {
	localctx = NewRet_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SyslParserRULE_ret_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.Match(SyslParserRETURN)
	}
	{
		p.SetState(739)
		p.Match(SyslParserTEXT)
	}

	return localctx
}

// ITargetContext is an interface to support dynamic dispatch.
type ITargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTargetContext differentiates from other interfaces.
	IsTargetContext()
}

type TargetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetContext() *TargetContext {
	var p = new(TargetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_target
	return p
}

func (*TargetContext) IsTargetContext() {}

func NewTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetContext {
	var p = new(TargetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_target

	return p
}

func (s *TargetContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *TargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTarget(s)
	}
}

func (s *TargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTarget(s)
	}
}

func (p *SyslParser) Target() (localctx ITargetContext) {
	localctx = NewTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SyslParserRULE_target)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		p.App_name()
	}

	return localctx
}

// ITarget_endpointContext is an interface to support dynamic dispatch.
type ITarget_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTarget_endpointContext differentiates from other interfaces.
	IsTarget_endpointContext()
}

type Target_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTarget_endpointContext() *Target_endpointContext {
	var p = new(Target_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_target_endpoint
	return p
}

func (*Target_endpointContext) IsTarget_endpointContext() {}

func NewTarget_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Target_endpointContext {
	var p = new(Target_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_target_endpoint

	return p
}

func (s *Target_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Target_endpointContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Target_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Target_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Target_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTarget_endpoint(s)
	}
}

func (s *Target_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTarget_endpoint(s)
	}
}

func (p *SyslParser) Target_endpoint() (localctx ITarget_endpointContext) {
	localctx = NewTarget_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SyslParserRULE_target_endpoint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(743)
		p.Name_str()
	}

	return localctx
}

// ICall_argContext is an interface to support dynamic dispatch.
type ICall_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_argContext differentiates from other interfaces.
	IsCall_argContext()
}

type Call_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_argContext() *Call_argContext {
	var p = new(Call_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_arg
	return p
}

func (*Call_argContext) IsCall_argContext() {}

func NewCall_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_argContext {
	var p = new(Call_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_arg

	return p
}

func (s *Call_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_argContext) AllQSTRING() []antlr.TerminalNode {
	return s.GetTokens(SyslParserQSTRING)
}

func (s *Call_argContext) QSTRING(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, i)
}

func (s *Call_argContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Call_argContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Call_argContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *Call_argContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Call_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_arg(s)
	}
}

func (s *Call_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_arg(s)
	}
}

func (p *SyslParser) Call_arg() (localctx ICall_argContext) {
	localctx = NewCall_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SyslParserRULE_call_arg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(747)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(SyslParserQSTRING-57))|(1<<(SyslParserTEXT_LINE-57))|(1<<(SyslParserName-57)))) != 0) || _la == SyslParserE_Name {
			p.SetState(747)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SyslParserQSTRING:
				{
					p.SetState(745)
					p.Match(SyslParserQSTRING)
				}

			case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
				{
					p.SetState(746)
					p.Name_str()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(749)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(751)
			p.Name_str()
		}
		{
			p.SetState(752)
			p.Match(SyslParserLESS_COLON)
		}
		p.SetState(755)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
			{
				p.SetState(753)
				p.Name_str()
			}

		case SyslParserNativeDataTypes:
			{
				p.SetState(754)
				p.Match(SyslParserNativeDataTypes)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// ICall_argsContext is an interface to support dynamic dispatch.
type ICall_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_argsContext differentiates from other interfaces.
	IsCall_argsContext()
}

type Call_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_argsContext() *Call_argsContext {
	var p = new(Call_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_args
	return p
}

func (*Call_argsContext) IsCall_argsContext() {}

func NewCall_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_argsContext {
	var p = new(Call_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_args

	return p
}

func (s *Call_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_argsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *Call_argsContext) AllCall_arg() []ICall_argContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICall_argContext)(nil)).Elem())
	var tst = make([]ICall_argContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICall_argContext)
		}
	}

	return tst
}

func (s *Call_argsContext) Call_arg(i int) ICall_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_argContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICall_argContext)
}

func (s *Call_argsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *Call_argsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Call_argsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Call_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_args(s)
	}
}

func (s *Call_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_args(s)
	}
}

func (p *SyslParser) Call_args() (localctx ICall_argsContext) {
	localctx = NewCall_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SyslParserRULE_call_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(760)
		p.Call_arg()
	}
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(761)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(762)
			p.Call_arg()
		}

		p.SetState(767)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(768)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// ICall_stmtContext is an interface to support dynamic dispatch.
type ICall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCall_stmtContext differentiates from other interfaces.
	IsCall_stmtContext()
}

type Call_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_stmtContext() *Call_stmtContext {
	var p = new(Call_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_call_stmt
	return p
}

func (*Call_stmtContext) IsCall_stmtContext() {}

func NewCall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_stmtContext {
	var p = new(Call_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_call_stmt

	return p
}

func (s *Call_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_stmtContext) Target_endpoint() ITarget_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITarget_endpointContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITarget_endpointContext)
}

func (s *Call_stmtContext) DOT_ARROW() antlr.TerminalNode {
	return s.GetToken(SyslParserDOT_ARROW, 0)
}

func (s *Call_stmtContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Call_stmtContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Call_stmtContext) Call_args() ICall_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_argsContext)
}

func (s *Call_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCall_stmt(s)
	}
}

func (s *Call_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCall_stmt(s)
	}
}

func (p *SyslParser) Call_stmt() (localctx ICall_stmtContext) {
	localctx = NewCall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SyslParserRULE_call_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(774)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserDOT_ARROW:
		{
			p.SetState(770)
			p.Match(SyslParserDOT_ARROW)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(771)
			p.Target()
		}
		{
			p.SetState(772)
			p.Match(SyslParserARROW_LEFT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(776)
		p.Target_endpoint()
	}
	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(777)
			p.Call_args()
		}

	}

	return localctx
}

// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_stmt
	return p
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(SyslParserIF, 0)
}

func (s *If_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *If_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *If_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *If_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *If_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *If_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

func (p *SyslParser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SyslParserRULE_if_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)
		p.Match(SyslParserIF)
	}
	{
		p.SetState(781)
		p.Match(SyslParserPREDICATE_VALUE)
	}
	{
		p.SetState(782)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(783)
		p.Match(SyslParserINDENT)
	}
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(SyslParserAT-43))|(1<<(SyslParserPIPE-43))|(1<<(SyslParserQSTRING-43))|(1<<(SyslParserSYSL_COMMENT-43))|(1<<(SyslParserTEXT_LINE-43))|(1<<(SyslParserName-43)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(784)
			p.Statements()
		}

		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(790)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IElse_stmtContext is an interface to support dynamic dispatch.
type IElse_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElse_stmtContext differentiates from other interfaces.
	IsElse_stmtContext()
}

type Else_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_stmtContext() *Else_stmtContext {
	var p = new(Else_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_else_stmt
	return p
}

func (*Else_stmtContext) IsElse_stmtContext() {}

func NewElse_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_stmtContext {
	var p = new(Else_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_else_stmt

	return p
}

func (s *Else_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserELSE, 0)
}

func (s *Else_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Else_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Else_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Else_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *Else_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Else_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Else_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterElse_stmt(s)
	}
}

func (s *Else_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitElse_stmt(s)
	}
}

func (p *SyslParser) Else_stmt() (localctx IElse_stmtContext) {
	localctx = NewElse_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SyslParserRULE_else_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Match(SyslParserELSE)
	}
	p.SetState(794)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserPREDICATE_VALUE {
		{
			p.SetState(793)
			p.Match(SyslParserPREDICATE_VALUE)
		}

	}
	{
		p.SetState(796)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(797)
		p.Match(SyslParserINDENT)
	}
	p.SetState(801)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(SyslParserAT-43))|(1<<(SyslParserPIPE-43))|(1<<(SyslParserQSTRING-43))|(1<<(SyslParserSYSL_COMMENT-43))|(1<<(SyslParserTEXT_LINE-43))|(1<<(SyslParserName-43)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(798)
			p.Statements()
		}

		p.SetState(803)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(804)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IIf_elseContext is an interface to support dynamic dispatch.
type IIf_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_elseContext differentiates from other interfaces.
	IsIf_elseContext()
}

type If_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_elseContext() *If_elseContext {
	var p = new(If_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_else
	return p
}

func (*If_elseContext) IsIf_elseContext() {}

func NewIf_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_elseContext {
	var p = new(If_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_else

	return p
}

func (s *If_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *If_elseContext) If_stmt() IIf_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *If_elseContext) AllElse_stmt() []IElse_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElse_stmtContext)(nil)).Elem())
	var tst = make([]IElse_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElse_stmtContext)
		}
	}

	return tst
}

func (s *If_elseContext) Else_stmt(i int) IElse_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElse_stmtContext)
}

func (s *If_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_else(s)
	}
}

func (s *If_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_else(s)
	}
}

func (p *SyslParser) If_else() (localctx IIf_elseContext) {
	localctx = NewIf_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SyslParserRULE_if_else)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(806)
		p.If_stmt()
	}
	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserELSE {
		{
			p.SetState(807)
			p.Else_stmt()
		}

		p.SetState(812)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFor_stmtContext is an interface to support dynamic dispatch.
type IFor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_stmtContext differentiates from other interfaces.
	IsFor_stmtContext()
}

type For_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_stmtContext() *For_stmtContext {
	var p = new(For_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_for_stmt
	return p
}

func (*For_stmtContext) IsFor_stmtContext() {}

func NewFor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_stmtContext {
	var p = new(For_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_for_stmt

	return p
}

func (s *For_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_stmtContext) PREDICATE_VALUE() antlr.TerminalNode {
	return s.GetToken(SyslParserPREDICATE_VALUE, 0)
}

func (s *For_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *For_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *For_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *For_stmtContext) ALT() antlr.TerminalNode {
	return s.GetToken(SyslParserALT, 0)
}

func (s *For_stmtContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(SyslParserUNTIL, 0)
}

func (s *For_stmtContext) FOR_EACH() antlr.TerminalNode {
	return s.GetToken(SyslParserFOR_EACH, 0)
}

func (s *For_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(SyslParserFOR, 0)
}

func (s *For_stmtContext) LOOP() antlr.TerminalNode {
	return s.GetToken(SyslParserLOOP, 0)
}

func (s *For_stmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(SyslParserWHILE, 0)
}

func (s *For_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *For_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFor_stmt(s)
	}
}

func (p *SyslParser) For_stmt() (localctx IFor_stmtContext) {
	localctx = NewFor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SyslParserRULE_for_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(813)
	_la = p.GetTokenStream().LA(1)

	if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(814)
		p.Match(SyslParserPREDICATE_VALUE)
	}
	{
		p.SetState(815)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(816)
		p.Match(SyslParserINDENT)
	}
	p.SetState(820)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(SyslParserAT-43))|(1<<(SyslParserPIPE-43))|(1<<(SyslParserQSTRING-43))|(1<<(SyslParserSYSL_COMMENT-43))|(1<<(SyslParserTEXT_LINE-43))|(1<<(SyslParserName-43)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(817)
			p.Statements()
		}

		p.SetState(822)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(823)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IHttp_method_commentContext is an interface to support dynamic dispatch.
type IHttp_method_commentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHttp_method_commentContext differentiates from other interfaces.
	IsHttp_method_commentContext()
}

type Http_method_commentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHttp_method_commentContext() *Http_method_commentContext {
	var p = new(Http_method_commentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_http_method_comment
	return p
}

func (*Http_method_commentContext) IsHttp_method_commentContext() {}

func NewHttp_method_commentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Http_method_commentContext {
	var p = new(Http_method_commentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_http_method_comment

	return p
}

func (s *Http_method_commentContext) GetParser() antlr.Parser { return s.parser }

func (s *Http_method_commentContext) SYSL_COMMENT() antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, 0)
}

func (s *Http_method_commentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Http_method_commentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Http_method_commentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterHttp_method_comment(s)
	}
}

func (s *Http_method_commentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitHttp_method_comment(s)
	}
}

func (p *SyslParser) Http_method_comment() (localctx IHttp_method_commentContext) {
	localctx = NewHttp_method_commentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SyslParserRULE_http_method_comment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(825)
		p.Match(SyslParserSYSL_COMMENT)
	}

	return localctx
}

// IGroup_stmtContext is an interface to support dynamic dispatch.
type IGroup_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_stmtContext differentiates from other interfaces.
	IsGroup_stmtContext()
}

type Group_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_stmtContext() *Group_stmtContext {
	var p = new(Group_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_group_stmt
	return p
}

func (*Group_stmtContext) IsGroup_stmtContext() {}

func NewGroup_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_stmtContext {
	var p = new(Group_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_group_stmt

	return p
}

func (s *Group_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Group_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Group_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Group_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Group_stmtContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Group_stmtContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Group_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterGroup_stmt(s)
	}
}

func (s *Group_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitGroup_stmt(s)
	}
}

func (p *SyslParser) Group_stmt() (localctx IGroup_stmtContext) {
	localctx = NewGroup_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SyslParserRULE_group_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(827)
		p.Name_str()
	}
	{
		p.SetState(828)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(829)
		p.Match(SyslParserINDENT)
	}
	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(SyslParserAT-43))|(1<<(SyslParserPIPE-43))|(1<<(SyslParserQSTRING-43))|(1<<(SyslParserSYSL_COMMENT-43))|(1<<(SyslParserTEXT_LINE-43))|(1<<(SyslParserName-43)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(830)
			p.Statements()
		}

		p.SetState(833)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(835)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IOne_of_case_labelContext is an interface to support dynamic dispatch.
type IOne_of_case_labelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_case_labelContext differentiates from other interfaces.
	IsOne_of_case_labelContext()
}

type One_of_case_labelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_case_labelContext() *One_of_case_labelContext {
	var p = new(One_of_case_labelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_case_label
	return p
}

func (*One_of_case_labelContext) IsOne_of_case_labelContext() {}

func NewOne_of_case_labelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_case_labelContext {
	var p = new(One_of_case_labelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_case_label

	return p
}

func (s *One_of_case_labelContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_case_labelContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *One_of_case_labelContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *One_of_case_labelContext) AllTEXT_LINE() []antlr.TerminalNode {
	return s.GetTokens(SyslParserTEXT_LINE)
}

func (s *One_of_case_labelContext) TEXT_LINE(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserTEXT_LINE, i)
}

func (s *One_of_case_labelContext) AllQSTRING() []antlr.TerminalNode {
	return s.GetTokens(SyslParserQSTRING)
}

func (s *One_of_case_labelContext) QSTRING(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, i)
}

func (s *One_of_case_labelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_case_labelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_case_labelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_case_label(s)
	}
}

func (s *One_of_case_labelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_case_label(s)
	}
}

func (p *SyslParser) One_of_case_label() (localctx IOne_of_case_labelContext) {
	localctx = NewOne_of_case_labelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SyslParserRULE_one_of_case_label)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(838)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(SyslParserQSTRING-57))|(1<<(SyslParserTEXT_LINE-57))|(1<<(SyslParserName-57)))) != 0) {
		p.SetState(837)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(SyslParserQSTRING-57))|(1<<(SyslParserTEXT_LINE-57))|(1<<(SyslParserName-57)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(840)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOne_of_casesContext is an interface to support dynamic dispatch.
type IOne_of_casesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_casesContext differentiates from other interfaces.
	IsOne_of_casesContext()
}

type One_of_casesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_casesContext() *One_of_casesContext {
	var p = new(One_of_casesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_cases
	return p
}

func (*One_of_casesContext) IsOne_of_casesContext() {}

func NewOne_of_casesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_casesContext {
	var p = new(One_of_casesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_cases

	return p
}

func (s *One_of_casesContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_casesContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *One_of_casesContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *One_of_casesContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *One_of_casesContext) One_of_case_label() IOne_of_case_labelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_case_labelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOne_of_case_labelContext)
}

func (s *One_of_casesContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *One_of_casesContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *One_of_casesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_casesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_casesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_cases(s)
	}
}

func (s *One_of_casesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_cases(s)
	}
}

func (p *SyslParser) One_of_cases() (localctx IOne_of_casesContext) {
	localctx = NewOne_of_casesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SyslParserRULE_one_of_cases)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(843)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(SyslParserQSTRING-57))|(1<<(SyslParserTEXT_LINE-57))|(1<<(SyslParserName-57)))) != 0 {
		{
			p.SetState(842)
			p.One_of_case_label()
		}

	}
	{
		p.SetState(845)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(846)
		p.Match(SyslParserINDENT)
	}
	p.SetState(848)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(SyslParserAT-43))|(1<<(SyslParserPIPE-43))|(1<<(SyslParserQSTRING-43))|(1<<(SyslParserSYSL_COMMENT-43))|(1<<(SyslParserTEXT_LINE-43))|(1<<(SyslParserName-43)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(847)
			p.Statements()
		}

		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(852)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IOne_of_stmtContext is an interface to support dynamic dispatch.
type IOne_of_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOne_of_stmtContext differentiates from other interfaces.
	IsOne_of_stmtContext()
}

type One_of_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOne_of_stmtContext() *One_of_stmtContext {
	var p = new(One_of_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_one_of_stmt
	return p
}

func (*One_of_stmtContext) IsOne_of_stmtContext() {}

func NewOne_of_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *One_of_stmtContext {
	var p = new(One_of_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_one_of_stmt

	return p
}

func (s *One_of_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *One_of_stmtContext) ONE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserONE_OF, 0)
}

func (s *One_of_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *One_of_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *One_of_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *One_of_stmtContext) AllOne_of_cases() []IOne_of_casesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOne_of_casesContext)(nil)).Elem())
	var tst = make([]IOne_of_casesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOne_of_casesContext)
		}
	}

	return tst
}

func (s *One_of_stmtContext) One_of_cases(i int) IOne_of_casesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_casesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOne_of_casesContext)
}

func (s *One_of_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_of_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *One_of_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterOne_of_stmt(s)
	}
}

func (s *One_of_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitOne_of_stmt(s)
	}
}

func (p *SyslParser) One_of_stmt() (localctx IOne_of_stmtContext) {
	localctx = NewOne_of_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SyslParserRULE_one_of_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(854)
		p.Match(SyslParserONE_OF)
	}
	{
		p.SetState(855)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(856)
		p.Match(SyslParserINDENT)
	}
	p.SetState(858)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(SyslParserCOLON-40))|(1<<(SyslParserQSTRING-40))|(1<<(SyslParserTEXT_LINE-40))|(1<<(SyslParserName-40)))) != 0) {
		{
			p.SetState(857)
			p.One_of_cases()
		}

		p.SetState(860)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(862)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IText_stmtContext is an interface to support dynamic dispatch.
type IText_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_stmtContext differentiates from other interfaces.
	IsText_stmtContext()
}

type Text_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_stmtContext() *Text_stmtContext {
	var p = new(Text_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_text_stmt
	return p
}

func (*Text_stmtContext) IsText_stmtContext() {}

func NewText_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_stmtContext {
	var p = new(Text_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_text_stmt

	return p
}

func (s *Text_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_stmtContext) Doc_string() IDoc_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoc_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoc_stringContext)
}

func (s *Text_stmtContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Text_stmtContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *Text_stmtContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *Text_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Text_stmtContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *Text_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterText_stmt(s)
	}
}

func (s *Text_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitText_stmt(s)
	}
}

func (p *SyslParser) Text_stmt() (localctx IText_stmtContext) {
	localctx = NewText_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SyslParserRULE_text_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(872)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserPIPE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(864)
			p.Doc_string()
		}

	case SyslParserQSTRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(865)
			p.Match(SyslParserQSTRING)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(866)
			p.App_name()
		}
		p.SetState(869)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserARROW_RIGHT {
			{
				p.SetState(867)
				p.Match(SyslParserARROW_RIGHT)
			}
			{
				p.SetState(868)
				p.Name_str()
			}

		}

	case SyslParserWHATEVER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(871)
			p.Match(SyslParserWHATEVER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMixinContext is an interface to support dynamic dispatch.
type IMixinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMixinContext differentiates from other interfaces.
	IsMixinContext()
}

type MixinContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMixinContext() *MixinContext {
	var p = new(MixinContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_mixin
	return p
}

func (*MixinContext) IsMixinContext() {}

func NewMixinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MixinContext {
	var p = new(MixinContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_mixin

	return p
}

func (s *MixinContext) GetParser() antlr.Parser { return s.parser }

func (s *MixinContext) MIXIN() antlr.TerminalNode {
	return s.GetToken(SyslParserMIXIN, 0)
}

func (s *MixinContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *MixinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MixinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MixinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMixin(s)
	}
}

func (s *MixinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMixin(s)
	}
}

func (p *SyslParser) Mixin() (localctx IMixinContext) {
	localctx = NewMixinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SyslParserRULE_mixin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(874)
		p.Match(SyslParserMIXIN)
	}
	{
		p.SetState(875)
		p.App_name()
	}

	return localctx
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_param
	return p
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *ParamContext) Field() IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *SyslParser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SyslParserRULE_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(877)
			p.Reference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(878)
			p.Field()
		}

	}

	return localctx
}

// IParam_listContext is an interface to support dynamic dispatch.
type IParam_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_listContext differentiates from other interfaces.
	IsParam_listContext()
}

type Param_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_listContext() *Param_listContext {
	var p = new(Param_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_param_list
	return p
}

func (*Param_listContext) IsParam_listContext() {}

func NewParam_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_listContext {
	var p = new(Param_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_param_list

	return p
}

func (s *Param_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_listContext) AllParam() []IParamContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParamContext)(nil)).Elem())
	var tst = make([]IParamContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParamContext)
		}
	}

	return tst
}

func (s *Param_listContext) Param(i int) IParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *Param_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *Param_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *Param_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParam_list(s)
	}
}

func (s *Param_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParam_list(s)
	}
}

func (p *SyslParser) Param_list() (localctx IParam_listContext) {
	localctx = NewParam_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SyslParserRULE_param_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(881)
		p.Param()
	}
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(882)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(883)
			p.Param()
		}

		p.SetState(888)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParamsContext is an interface to support dynamic dispatch.
type IParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamsContext differentiates from other interfaces.
	IsParamsContext()
}

type ParamsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamsContext() *ParamsContext {
	var p = new(ParamsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_params
	return p
}

func (*ParamsContext) IsParamsContext() {}

func NewParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamsContext {
	var p = new(ParamsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_params

	return p
}

func (s *ParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *ParamsContext) Param_list() IParam_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_listContext)
}

func (s *ParamsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *ParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterParams(s)
	}
}

func (s *ParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitParams(s)
	}
}

func (p *SyslParser) Params() (localctx IParamsContext) {
	localctx = NewParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SyslParserRULE_params)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(889)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(890)
		p.Param_list()
	}
	{
		p.SetState(891)
		p.Match(SyslParserCLOSE_PAREN)
	}

	return localctx
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_statements
	return p
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) If_else() IIf_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_elseContext)
}

func (s *StatementsContext) For_stmt() IFor_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *StatementsContext) Ret_stmt() IRet_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRet_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRet_stmtContext)
}

func (s *StatementsContext) Call_stmt() ICall_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICall_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICall_stmtContext)
}

func (s *StatementsContext) One_of_stmt() IOne_of_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOne_of_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOne_of_stmtContext)
}

func (s *StatementsContext) Http_method_comment() IHttp_method_commentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_method_commentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_method_commentContext)
}

func (s *StatementsContext) Group_stmt() IGroup_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_stmtContext)
}

func (s *StatementsContext) Text_stmt() IText_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_stmtContext)
}

func (s *StatementsContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *StatementsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *SyslParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SyslParserRULE_statements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(902)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(893)
			p.If_else()
		}

	case 2:
		{
			p.SetState(894)
			p.For_stmt()
		}

	case 3:
		{
			p.SetState(895)
			p.Ret_stmt()
		}

	case 4:
		{
			p.SetState(896)
			p.Call_stmt()
		}

	case 5:
		{
			p.SetState(897)
			p.One_of_stmt()
		}

	case 6:
		{
			p.SetState(898)
			p.Http_method_comment()
		}

	case 7:
		{
			p.SetState(899)
			p.Group_stmt()
		}

	case 8:
		{
			p.SetState(900)
			p.Text_stmt()
		}

	case 9:
		{
			p.SetState(901)
			p.Annotation()
		}

	}
	p.SetState(905)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(904)
			p.Attribs_or_modifiers()
		}

	}

	return localctx
}

// IMethod_defContext is an interface to support dynamic dispatch.
type IMethod_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_defContext differentiates from other interfaces.
	IsMethod_defContext()
}

type Method_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_defContext() *Method_defContext {
	var p = new(Method_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_method_def
	return p
}

func (*Method_defContext) IsMethod_defContext() {}

func NewMethod_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_defContext {
	var p = new(Method_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_method_def

	return p
}

func (s *Method_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_defContext) HTTP_VERBS() antlr.TerminalNode {
	return s.GetToken(SyslParserHTTP_VERBS, 0)
}

func (s *Method_defContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Method_defContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Method_defContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Method_defContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *Method_defContext) Query_param() IQuery_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuery_paramContext)
}

func (s *Method_defContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Method_defContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Method_defContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Method_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Method_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMethod_def(s)
	}
}

func (s *Method_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMethod_def(s)
	}
}

func (p *SyslParser) Method_def() (localctx IMethod_defContext) {
	localctx = NewMethod_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SyslParserRULE_method_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(907)
		p.Match(SyslParserHTTP_VERBS)
	}
	p.SetState(909)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(908)
			p.Params()
		}

	}
	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(911)
			p.Query_param()
		}

	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(914)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(917)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(918)
		p.Match(SyslParserINDENT)
	}
	p.SetState(920)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(SyslParserAT-43))|(1<<(SyslParserPIPE-43))|(1<<(SyslParserQSTRING-43))|(1<<(SyslParserSYSL_COMMENT-43))|(1<<(SyslParserTEXT_LINE-43))|(1<<(SyslParserName-43)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(919)
			p.Statements()
		}

		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(924)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IShortcutContext is an interface to support dynamic dispatch.
type IShortcutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShortcutContext differentiates from other interfaces.
	IsShortcutContext()
}

type ShortcutContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShortcutContext() *ShortcutContext {
	var p = new(ShortcutContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_shortcut
	return p
}

func (*ShortcutContext) IsShortcutContext() {}

func NewShortcutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShortcutContext {
	var p = new(ShortcutContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_shortcut

	return p
}

func (s *ShortcutContext) GetParser() antlr.Parser { return s.parser }

func (s *ShortcutContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *ShortcutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortcutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShortcutContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterShortcut(s)
	}
}

func (s *ShortcutContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitShortcut(s)
	}
}

func (p *SyslParser) Shortcut() (localctx IShortcutContext) {
	localctx = NewShortcutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SyslParserRULE_shortcut)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(926)
		p.Match(SyslParserWHATEVER)
	}

	return localctx
}

// ISimple_endpointContext is an interface to support dynamic dispatch.
type ISimple_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_endpointContext differentiates from other interfaces.
	IsSimple_endpointContext()
}

type Simple_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_endpointContext() *Simple_endpointContext {
	var p = new(Simple_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_simple_endpoint
	return p
}

func (*Simple_endpointContext) IsSimple_endpointContext() {}

func NewSimple_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_endpointContext {
	var p = new(Simple_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_simple_endpoint

	return p
}

func (s *Simple_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_endpointContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *Simple_endpointContext) Endpoint_name() IEndpoint_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndpoint_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndpoint_nameContext)
}

func (s *Simple_endpointContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Simple_endpointContext) Shortcut() IShortcutContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShortcutContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShortcutContext)
}

func (s *Simple_endpointContext) QSTRING() antlr.TerminalNode {
	return s.GetToken(SyslParserQSTRING, 0)
}

func (s *Simple_endpointContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *Simple_endpointContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Simple_endpointContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Simple_endpointContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Simple_endpointContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *Simple_endpointContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *Simple_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSimple_endpoint(s)
	}
}

func (s *Simple_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSimple_endpoint(s)
	}
}

func (p *SyslParser) Simple_endpoint() (localctx ISimple_endpointContext) {
	localctx = NewSimple_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SyslParserRULE_simple_endpoint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(951)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(928)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(929)
			p.Endpoint_name()
		}
		p.SetState(931)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserQSTRING {
			{
				p.SetState(930)
				p.Match(SyslParserQSTRING)
			}

		}
		p.SetState(934)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserOPEN_PAREN {
			{
				p.SetState(933)
				p.Params()
			}

		}
		p.SetState(937)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(936)
				p.Attribs_or_modifiers()
			}

		}
		{
			p.SetState(939)
			p.Match(SyslParserCOLON)
		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserWHATEVER:
			{
				p.SetState(940)
				p.Shortcut()
			}

		case SyslParserINDENT:
			{
				p.SetState(941)
				p.Match(SyslParserINDENT)
			}
			p.SetState(943)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(SyslParserAT-43))|(1<<(SyslParserPIPE-43))|(1<<(SyslParserQSTRING-43))|(1<<(SyslParserSYSL_COMMENT-43))|(1<<(SyslParserTEXT_LINE-43))|(1<<(SyslParserName-43)))) != 0) || _la == SyslParserE_Name {
				{
					p.SetState(942)
					p.Statements()
				}

				p.SetState(945)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(947)
				p.Match(SyslParserDEDENT)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRest_endpointContext is an interface to support dynamic dispatch.
type IRest_endpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRest_endpointContext differentiates from other interfaces.
	IsRest_endpointContext()
}

type Rest_endpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRest_endpointContext() *Rest_endpointContext {
	var p = new(Rest_endpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rest_endpoint
	return p
}

func (*Rest_endpointContext) IsRest_endpointContext() {}

func NewRest_endpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rest_endpointContext {
	var p = new(Rest_endpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rest_endpoint

	return p
}

func (s *Rest_endpointContext) GetParser() antlr.Parser { return s.parser }

func (s *Rest_endpointContext) Http_path() IHttp_pathContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHttp_pathContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHttp_pathContext)
}

func (s *Rest_endpointContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *Rest_endpointContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Rest_endpointContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Rest_endpointContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Rest_endpointContext) AllMethod_def() []IMethod_defContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMethod_defContext)(nil)).Elem())
	var tst = make([]IMethod_defContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMethod_defContext)
		}
	}

	return tst
}

func (s *Rest_endpointContext) Method_def(i int) IMethod_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_defContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMethod_defContext)
}

func (s *Rest_endpointContext) AllRest_endpoint() []IRest_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem())
	var tst = make([]IRest_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRest_endpointContext)
		}
	}

	return tst
}

func (s *Rest_endpointContext) Rest_endpoint(i int) IRest_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRest_endpointContext)
}

func (s *Rest_endpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rest_endpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rest_endpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRest_endpoint(s)
	}
}

func (s *Rest_endpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRest_endpoint(s)
	}
}

func (p *SyslParser) Rest_endpoint() (localctx IRest_endpointContext) {
	localctx = NewRest_endpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SyslParserRULE_rest_endpoint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(953)
		p.Http_path()
	}
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(954)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(957)
		p.Match(SyslParserCOLON)
	}

	{
		p.SetState(958)
		p.Match(SyslParserINDENT)
	}
	p.SetState(961)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserHTTP_VERBS || _la == SyslParserFORWARD_SLASH {
		p.SetState(961)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SyslParserHTTP_VERBS:
			{
				p.SetState(959)
				p.Method_def()
			}

		case SyslParserFORWARD_SLASH:
			{
				p.SetState(960)
				p.Rest_endpoint()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(963)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(965)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// ICollector_query_varContext is an interface to support dynamic dispatch.
type ICollector_query_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_query_varContext differentiates from other interfaces.
	IsCollector_query_varContext()
}

type Collector_query_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_query_varContext() *Collector_query_varContext {
	var p = new(Collector_query_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_query_var
	return p
}

func (*Collector_query_varContext) IsCollector_query_varContext() {}

func NewCollector_query_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_query_varContext {
	var p = new(Collector_query_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_query_var

	return p
}

func (s *Collector_query_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_query_varContext) AllName_str() []IName_strContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_strContext)(nil)).Elem())
	var tst = make([]IName_strContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_strContext)
		}
	}

	return tst
}

func (s *Collector_query_varContext) Name_str(i int) IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_query_varContext) EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserEQ, 0)
}

func (s *Collector_query_varContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Collector_query_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_query_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_query_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_query_var(s)
	}
}

func (s *Collector_query_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_query_var(s)
	}
}

func (p *SyslParser) Collector_query_var() (localctx ICollector_query_varContext) {
	localctx = NewCollector_query_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SyslParserRULE_collector_query_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(967)
		p.Name_str()
	}
	{
		p.SetState(968)
		p.Match(SyslParserEQ)
	}
	p.SetState(971)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes:
		{
			p.SetState(969)
			p.Match(SyslParserNativeDataTypes)
		}

	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(970)
			p.Name_str()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICollector_query_paramContext is an interface to support dynamic dispatch.
type ICollector_query_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_query_paramContext differentiates from other interfaces.
	IsCollector_query_paramContext()
}

type Collector_query_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_query_paramContext() *Collector_query_paramContext {
	var p = new(Collector_query_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_query_param
	return p
}

func (*Collector_query_paramContext) IsCollector_query_paramContext() {}

func NewCollector_query_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_query_paramContext {
	var p = new(Collector_query_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_query_param

	return p
}

func (s *Collector_query_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_query_paramContext) QN() antlr.TerminalNode {
	return s.GetToken(SyslParserQN, 0)
}

func (s *Collector_query_paramContext) AllCollector_query_var() []ICollector_query_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_query_varContext)(nil)).Elem())
	var tst = make([]ICollector_query_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_query_varContext)
		}
	}

	return tst
}

func (s *Collector_query_paramContext) Collector_query_var(i int) ICollector_query_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_query_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_query_varContext)
}

func (s *Collector_query_paramContext) AllAMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserAMP)
}

func (s *Collector_query_paramContext) AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserAMP, i)
}

func (s *Collector_query_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_query_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_query_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_query_param(s)
	}
}

func (s *Collector_query_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_query_param(s)
	}
}

func (p *SyslParser) Collector_query_param() (localctx ICollector_query_paramContext) {
	localctx = NewCollector_query_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SyslParserRULE_collector_query_param)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(973)
		p.Match(SyslParserQN)
	}
	{
		p.SetState(974)
		p.Collector_query_var()
	}
	p.SetState(979)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserAMP {
		{
			p.SetState(975)
			p.Match(SyslParserAMP)
		}
		{
			p.SetState(976)
			p.Collector_query_var()
		}

		p.SetState(981)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICollector_call_stmtContext is an interface to support dynamic dispatch.
type ICollector_call_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_call_stmtContext differentiates from other interfaces.
	IsCollector_call_stmtContext()
}

type Collector_call_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_call_stmtContext() *Collector_call_stmtContext {
	var p = new(Collector_call_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_call_stmt
	return p
}

func (*Collector_call_stmtContext) IsCollector_call_stmtContext() {}

func NewCollector_call_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_call_stmtContext {
	var p = new(Collector_call_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_call_stmt

	return p
}

func (s *Collector_call_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_call_stmtContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Collector_call_stmtContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Collector_call_stmtContext) Target_endpoint() ITarget_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITarget_endpointContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITarget_endpointContext)
}

func (s *Collector_call_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_call_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_call_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_call_stmt(s)
	}
}

func (s *Collector_call_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_call_stmt(s)
	}
}

func (p *SyslParser) Collector_call_stmt() (localctx ICollector_call_stmtContext) {
	localctx = NewCollector_call_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SyslParserRULE_collector_call_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(982)
		p.Target()
	}
	{
		p.SetState(983)
		p.Match(SyslParserARROW_LEFT)
	}
	{
		p.SetState(984)
		p.Target_endpoint()
	}

	return localctx
}

// ICollector_http_stmt_partContext is an interface to support dynamic dispatch.
type ICollector_http_stmt_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmt_partContext differentiates from other interfaces.
	IsCollector_http_stmt_partContext()
}

type Collector_http_stmt_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmt_partContext() *Collector_http_stmt_partContext {
	var p = new(Collector_http_stmt_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt_part
	return p
}

func (*Collector_http_stmt_partContext) IsCollector_http_stmt_partContext() {}

func NewCollector_http_stmt_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmt_partContext {
	var p = new(Collector_http_stmt_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt_part

	return p
}

func (s *Collector_http_stmt_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmt_partContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_http_stmt_partContext) CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_OPEN, 0)
}

func (s *Collector_http_stmt_partContext) CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserCURLY_CLOSE, 0)
}

func (s *Collector_http_stmt_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmt_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmt_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt_part(s)
	}
}

func (s *Collector_http_stmt_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt_part(s)
	}
}

func (p *SyslParser) Collector_http_stmt_part() (localctx ICollector_http_stmt_partContext) {
	localctx = NewCollector_http_stmt_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SyslParserRULE_collector_http_stmt_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(991)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(986)
			p.Name_str()
		}

	case SyslParserCURLY_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(987)
			p.Match(SyslParserCURLY_OPEN)
		}
		{
			p.SetState(988)
			p.Name_str()
		}
		{
			p.SetState(989)
			p.Match(SyslParserCURLY_CLOSE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICollector_http_stmt_suffixContext is an interface to support dynamic dispatch.
type ICollector_http_stmt_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmt_suffixContext differentiates from other interfaces.
	IsCollector_http_stmt_suffixContext()
}

type Collector_http_stmt_suffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmt_suffixContext() *Collector_http_stmt_suffixContext {
	var p = new(Collector_http_stmt_suffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt_suffix
	return p
}

func (*Collector_http_stmt_suffixContext) IsCollector_http_stmt_suffixContext() {}

func NewCollector_http_stmt_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmt_suffixContext {
	var p = new(Collector_http_stmt_suffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt_suffix

	return p
}

func (s *Collector_http_stmt_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmt_suffixContext) AllFORWARD_SLASH() []antlr.TerminalNode {
	return s.GetTokens(SyslParserFORWARD_SLASH)
}

func (s *Collector_http_stmt_suffixContext) FORWARD_SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, i)
}

func (s *Collector_http_stmt_suffixContext) AllCollector_http_stmt_part() []ICollector_http_stmt_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_http_stmt_partContext)(nil)).Elem())
	var tst = make([]ICollector_http_stmt_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_http_stmt_partContext)
		}
	}

	return tst
}

func (s *Collector_http_stmt_suffixContext) Collector_http_stmt_part(i int) ICollector_http_stmt_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmt_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmt_partContext)
}

func (s *Collector_http_stmt_suffixContext) Collector_query_param() ICollector_query_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_query_paramContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_query_paramContext)
}

func (s *Collector_http_stmt_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmt_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmt_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt_suffix(s)
	}
}

func (s *Collector_http_stmt_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt_suffix(s)
	}
}

func (p *SyslParser) Collector_http_stmt_suffix() (localctx ICollector_http_stmt_suffixContext) {
	localctx = NewCollector_http_stmt_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SyslParserRULE_collector_http_stmt_suffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(995)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserFORWARD_SLASH {
		{
			p.SetState(993)
			p.Match(SyslParserFORWARD_SLASH)
		}
		{
			p.SetState(994)
			p.Collector_http_stmt_part()
		}

		p.SetState(997)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1000)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserQN {
		{
			p.SetState(999)
			p.Collector_query_param()
		}

	}

	return localctx
}

// ICollector_http_stmtContext is an interface to support dynamic dispatch.
type ICollector_http_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_http_stmtContext differentiates from other interfaces.
	IsCollector_http_stmtContext()
}

type Collector_http_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_http_stmtContext() *Collector_http_stmtContext {
	var p = new(Collector_http_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_http_stmt
	return p
}

func (*Collector_http_stmtContext) IsCollector_http_stmtContext() {}

func NewCollector_http_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_http_stmtContext {
	var p = new(Collector_http_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_http_stmt

	return p
}

func (s *Collector_http_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_http_stmtContext) HTTP_VERBS() antlr.TerminalNode {
	return s.GetToken(SyslParserHTTP_VERBS, 0)
}

func (s *Collector_http_stmtContext) Collector_http_stmt_suffix() ICollector_http_stmt_suffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmt_suffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmt_suffixContext)
}

func (s *Collector_http_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_http_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_http_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_http_stmt(s)
	}
}

func (s *Collector_http_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_http_stmt(s)
	}
}

func (p *SyslParser) Collector_http_stmt() (localctx ICollector_http_stmtContext) {
	localctx = NewCollector_http_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SyslParserRULE_collector_http_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1002)
		p.Match(SyslParserHTTP_VERBS)
	}
	{
		p.SetState(1003)
		p.Collector_http_stmt_suffix()
	}

	return localctx
}

// IPublisherContext is an interface to support dynamic dispatch.
type IPublisherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPublisherContext differentiates from other interfaces.
	IsPublisherContext()
}

type PublisherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPublisherContext() *PublisherContext {
	var p = new(PublisherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_publisher
	return p
}

func (*PublisherContext) IsPublisherContext() {}

func NewPublisherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PublisherContext {
	var p = new(PublisherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_publisher

	return p
}

func (s *PublisherContext) GetParser() antlr.Parser { return s.parser }

func (s *PublisherContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *PublisherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PublisherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PublisherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPublisher(s)
	}
}

func (s *PublisherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPublisher(s)
	}
}

func (p *SyslParser) Publisher() (localctx IPublisherContext) {
	localctx = NewPublisherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SyslParserRULE_publisher)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1005)
		p.App_name()
	}

	return localctx
}

// ISubscriberContext is an interface to support dynamic dispatch.
type ISubscriberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriberContext differentiates from other interfaces.
	IsSubscriberContext()
}

type SubscriberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriberContext() *SubscriberContext {
	var p = new(SubscriberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_subscriber
	return p
}

func (*SubscriberContext) IsSubscriberContext() {}

func NewSubscriberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriberContext {
	var p = new(SubscriberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_subscriber

	return p
}

func (s *SubscriberContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriberContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *SubscriberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSubscriber(s)
	}
}

func (s *SubscriberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSubscriber(s)
	}
}

func (p *SyslParser) Subscriber() (localctx ISubscriberContext) {
	localctx = NewSubscriberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SyslParserRULE_subscriber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1007)
		p.App_name()
	}

	return localctx
}

// ICollector_pubsub_callContext is an interface to support dynamic dispatch.
type ICollector_pubsub_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_pubsub_callContext differentiates from other interfaces.
	IsCollector_pubsub_callContext()
}

type Collector_pubsub_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_pubsub_callContext() *Collector_pubsub_callContext {
	var p = new(Collector_pubsub_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_pubsub_call
	return p
}

func (*Collector_pubsub_callContext) IsCollector_pubsub_callContext() {}

func NewCollector_pubsub_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_pubsub_callContext {
	var p = new(Collector_pubsub_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_pubsub_call

	return p
}

func (s *Collector_pubsub_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_pubsub_callContext) Subscriber() ISubscriberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubscriberContext)
}

func (s *Collector_pubsub_callContext) ARROW_LEFT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_LEFT, 0)
}

func (s *Collector_pubsub_callContext) Publisher() IPublisherContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPublisherContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPublisherContext)
}

func (s *Collector_pubsub_callContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *Collector_pubsub_callContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_pubsub_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_pubsub_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_pubsub_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_pubsub_call(s)
	}
}

func (s *Collector_pubsub_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_pubsub_call(s)
	}
}

func (p *SyslParser) Collector_pubsub_call() (localctx ICollector_pubsub_callContext) {
	localctx = NewCollector_pubsub_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SyslParserRULE_collector_pubsub_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1009)
		p.Subscriber()
	}
	{
		p.SetState(1010)
		p.Match(SyslParserARROW_LEFT)
	}
	{
		p.SetState(1011)
		p.Publisher()
	}
	{
		p.SetState(1012)
		p.Match(SyslParserARROW_RIGHT)
	}
	{
		p.SetState(1013)
		p.Name_str()
	}

	return localctx
}

// ICollector_action_stmtContext is an interface to support dynamic dispatch.
type ICollector_action_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_action_stmtContext differentiates from other interfaces.
	IsCollector_action_stmtContext()
}

type Collector_action_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_action_stmtContext() *Collector_action_stmtContext {
	var p = new(Collector_action_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_action_stmt
	return p
}

func (*Collector_action_stmtContext) IsCollector_action_stmtContext() {}

func NewCollector_action_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_action_stmtContext {
	var p = new(Collector_action_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_action_stmt

	return p
}

func (s *Collector_action_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_action_stmtContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *Collector_action_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_action_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_action_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_action_stmt(s)
	}
}

func (s *Collector_action_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_action_stmt(s)
	}
}

func (p *SyslParser) Collector_action_stmt() (localctx ICollector_action_stmtContext) {
	localctx = NewCollector_action_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SyslParserRULE_collector_action_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1015)
		p.Name_str()
	}

	return localctx
}

// ICollector_stmtsContext is an interface to support dynamic dispatch.
type ICollector_stmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollector_stmtsContext differentiates from other interfaces.
	IsCollector_stmtsContext()
}

type Collector_stmtsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollector_stmtsContext() *Collector_stmtsContext {
	var p = new(Collector_stmtsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector_stmts
	return p
}

func (*Collector_stmtsContext) IsCollector_stmtsContext() {}

func NewCollector_stmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collector_stmtsContext {
	var p = new(Collector_stmtsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector_stmts

	return p
}

func (s *Collector_stmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *Collector_stmtsContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *Collector_stmtsContext) Collector_action_stmt() ICollector_action_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_action_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_action_stmtContext)
}

func (s *Collector_stmtsContext) Collector_call_stmt() ICollector_call_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_call_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_call_stmtContext)
}

func (s *Collector_stmtsContext) Collector_http_stmt() ICollector_http_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_http_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_http_stmtContext)
}

func (s *Collector_stmtsContext) Collector_pubsub_call() ICollector_pubsub_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_pubsub_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollector_pubsub_callContext)
}

func (s *Collector_stmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collector_stmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collector_stmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector_stmts(s)
	}
}

func (s *Collector_stmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector_stmts(s)
	}
}

func (p *SyslParser) Collector_stmts() (localctx ICollector_stmtsContext) {
	localctx = NewCollector_stmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SyslParserRULE_collector_stmts)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1017)
			p.Collector_action_stmt()
		}

	case 2:
		{
			p.SetState(1018)
			p.Collector_call_stmt()
		}

	case 3:
		{
			p.SetState(1019)
			p.Collector_http_stmt()
		}

	case 4:
		{
			p.SetState(1020)
			p.Collector_pubsub_call()
		}

	}
	{
		p.SetState(1023)
		p.Attribs_or_modifiers()
	}

	return localctx
}

// ICollectorContext is an interface to support dynamic dispatch.
type ICollectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollectorContext differentiates from other interfaces.
	IsCollectorContext()
}

type CollectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectorContext() *CollectorContext {
	var p = new(CollectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_collector
	return p
}

func (*CollectorContext) IsCollectorContext() {}

func NewCollectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectorContext {
	var p = new(CollectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_collector

	return p
}

func (s *CollectorContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectorContext) COLLECTOR() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLLECTOR, 0)
}

func (s *CollectorContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *CollectorContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *CollectorContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *CollectorContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *CollectorContext) AllCollector_stmts() []ICollector_stmtsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollector_stmtsContext)(nil)).Elem())
	var tst = make([]ICollector_stmtsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollector_stmtsContext)
		}
	}

	return tst
}

func (s *CollectorContext) Collector_stmts(i int) ICollector_stmtsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollector_stmtsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollector_stmtsContext)
}

func (s *CollectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCollector(s)
	}
}

func (s *CollectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCollector(s)
	}
}

func (p *SyslParser) Collector() (localctx ICollectorContext) {
	localctx = NewCollectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SyslParserRULE_collector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1025)
		p.Match(SyslParserCOLLECTOR)
	}
	{
		p.SetState(1026)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1036)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1027)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1028)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1030)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SyslParserHTTP_VERBS || _la == SyslParserTEXT_LINE || _la == SyslParserName || _la == SyslParserE_Name {
			{
				p.SetState(1029)
				p.Collector_stmts()
			}

			p.SetState(1032)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1034)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEventContext is an interface to support dynamic dispatch.
type IEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEventContext differentiates from other interfaces.
	IsEventContext()
}

type EventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventContext() *EventContext {
	var p = new(EventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_event
	return p
}

func (*EventContext) IsEventContext() {}

func NewEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventContext {
	var p = new(EventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_event

	return p
}

func (s *EventContext) GetParser() antlr.Parser { return s.parser }

func (s *EventContext) DISTANCE() antlr.TerminalNode {
	return s.GetToken(SyslParserDISTANCE, 0)
}

func (s *EventContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *EventContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *EventContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *EventContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *EventContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *EventContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *EventContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *EventContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *EventContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *EventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEvent(s)
	}
}

func (s *EventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEvent(s)
	}
}

func (p *SyslParser) Event() (localctx IEventContext) {
	localctx = NewEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SyslParserRULE_event)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1038)
		p.Match(SyslParserDISTANCE)
	}
	{
		p.SetState(1039)
		p.Name_str()
	}
	p.SetState(1041)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserOPEN_PAREN {
		{
			p.SetState(1040)
			p.Params()
		}

	}
	p.SetState(1044)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1043)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1046)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1056)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1047)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1048)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1050)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(SyslParserAT-43))|(1<<(SyslParserPIPE-43))|(1<<(SyslParserQSTRING-43))|(1<<(SyslParserSYSL_COMMENT-43))|(1<<(SyslParserTEXT_LINE-43))|(1<<(SyslParserName-43)))) != 0) || _la == SyslParserE_Name {
			{
				p.SetState(1049)
				p.Statements()
			}

			p.SetState(1052)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1054)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISubscribeContext is an interface to support dynamic dispatch.
type ISubscribeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscribeContext differentiates from other interfaces.
	IsSubscribeContext()
}

type SubscribeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscribeContext() *SubscribeContext {
	var p = new(SubscribeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_subscribe
	return p
}

func (*SubscribeContext) IsSubscribeContext() {}

func NewSubscribeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscribeContext {
	var p = new(SubscribeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_subscribe

	return p
}

func (s *SubscribeContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscribeContext) App_name() IApp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_nameContext)
}

func (s *SubscribeContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *SubscribeContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *SubscribeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *SubscribeContext) WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserWHATEVER, 0)
}

func (s *SubscribeContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *SubscribeContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *SubscribeContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *SubscribeContext) AllStatements() []IStatementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementsContext)(nil)).Elem())
	var tst = make([]IStatementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementsContext)
		}
	}

	return tst
}

func (s *SubscribeContext) Statements(i int) IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *SubscribeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscribeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscribeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSubscribe(s)
	}
}

func (s *SubscribeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSubscribe(s)
	}
}

func (p *SyslParser) Subscribe() (localctx ISubscribeContext) {
	localctx = NewSubscribeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SyslParserRULE_subscribe)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1058)
		p.App_name()
	}
	{
		p.SetState(1059)
		p.Match(SyslParserARROW_RIGHT)
	}
	{
		p.SetState(1060)
		p.Name_str()
	}
	p.SetState(1062)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1061)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1064)
		p.Match(SyslParserCOLON)
	}
	p.SetState(1074)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserWHATEVER:
		{
			p.SetState(1065)
			p.Match(SyslParserWHATEVER)
		}

	case SyslParserINDENT:
		{
			p.SetState(1066)
			p.Match(SyslParserINDENT)
		}
		p.SetState(1068)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SyslParserRETURN)|(1<<SyslParserIF)|(1<<SyslParserFOR_EACH)|(1<<SyslParserFOR)|(1<<SyslParserUNTIL)|(1<<SyslParserLOOP)|(1<<SyslParserALT)|(1<<SyslParserWHILE)|(1<<SyslParserWHATEVER)|(1<<SyslParserONE_OF)|(1<<SyslParserDOT_ARROW))) != 0) || (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(SyslParserAT-43))|(1<<(SyslParserPIPE-43))|(1<<(SyslParserQSTRING-43))|(1<<(SyslParserSYSL_COMMENT-43))|(1<<(SyslParserTEXT_LINE-43))|(1<<(SyslParserName-43)))) != 0) || _la == SyslParserE_Name {
			{
				p.SetState(1067)
				p.Statements()
			}

			p.SetState(1070)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1072)
			p.Match(SyslParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IView_type_specContext is an interface to support dynamic dispatch.
type IView_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_type_specContext differentiates from other interfaces.
	IsView_type_specContext()
}

type View_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_type_specContext() *View_type_specContext {
	var p = new(View_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_type_spec
	return p
}

func (*View_type_specContext) IsView_type_specContext() {}

func NewView_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_type_specContext {
	var p = new(View_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_type_spec

	return p
}

func (s *View_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *View_type_specContext) Collection_type() ICollection_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *View_type_specContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *View_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_type_spec(s)
	}
}

func (s *View_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_type_spec(s)
	}
}

func (p *SyslParser) View_type_spec() (localctx IView_type_specContext) {
	localctx = NewView_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SyslParserRULE_view_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1078)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1076)
			p.Collection_type()
		}

	case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1077)
			p.Types()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) E_DIGITS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DIGITS, 0)
}

func (s *LiteralContext) E_DECIMAL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DECIMAL, 0)
}

func (s *LiteralContext) E_STRING_DBL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STRING_DBL, 0)
}

func (s *LiteralContext) E_STRING_SINGLE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STRING_SINGLE, 0)
}

func (s *LiteralContext) E_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULL, 0)
}

func (s *LiteralContext) E_TRUE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TRUE, 0)
}

func (s *LiteralContext) E_FALSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_FALSE, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *SyslParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SyslParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1080)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-115)&-(0x1f+1)) == 0 && ((1<<uint((_la-115)))&((1<<(SyslParserE_TRUE-115))|(1<<(SyslParserE_FALSE-115))|(1<<(SyslParserE_NULL-115))|(1<<(SyslParserE_STRING_DBL-115))|(1<<(SyslParserE_STRING_SINGLE-115))|(1<<(SyslParserE_DECIMAL-115))|(1<<(SyslParserE_DIGITS-115)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_table_of_opContext is an interface to support dynamic dispatch.
type IExpr_table_of_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_table_of_opContext differentiates from other interfaces.
	IsExpr_table_of_opContext()
}

type Expr_table_of_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_table_of_opContext() *Expr_table_of_opContext {
	var p = new(Expr_table_of_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_table_of_op
	return p
}

func (*Expr_table_of_opContext) IsExpr_table_of_opContext() {}

func NewExpr_table_of_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_table_of_opContext {
	var p = new(Expr_table_of_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_table_of_op

	return p
}

func (s *Expr_table_of_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_table_of_opContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_table_of_opContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_table_of_opContext) E_NULLSAFE_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULLSAFE_DOT, 0)
}

func (s *Expr_table_of_opContext) E_TABLE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TABLE_OF, 0)
}

func (s *Expr_table_of_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_table_of_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_table_of_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_table_of_op(s)
	}
}

func (s *Expr_table_of_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_table_of_op(s)
	}
}

func (p *SyslParser) Expr_table_of_op() (localctx IExpr_table_of_opContext) {
	localctx = NewExpr_table_of_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SyslParserRULE_expr_table_of_op)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1082)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_NULLSAFE_DOT || _la == SyslParserE_DOT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(1084)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_TABLE_OF {
		{
			p.SetState(1083)
			p.Match(SyslParserE_TABLE_OF)
		}

	}
	{
		p.SetState(1086)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// IFunc_argContext is an interface to support dynamic dispatch.
type IFunc_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunc_argContext differentiates from other interfaces.
	IsFunc_argContext()
}

type Func_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_argContext() *Func_argContext {
	var p = new(Func_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_func_arg
	return p
}

func (*Func_argContext) IsFunc_argContext() {}

func NewFunc_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_argContext {
	var p = new(Func_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_func_arg

	return p
}

func (s *Func_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_argContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Func_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFunc_arg(s)
	}
}

func (s *Func_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFunc_arg(s)
	}
}

func (p *SyslParser) Func_arg() (localctx IFunc_argContext) {
	localctx = NewFunc_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SyslParserRULE_func_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1088)
		p.Expr()
	}

	return localctx
}

// IFunc_argsContext is an interface to support dynamic dispatch.
type IFunc_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunc_argsContext differentiates from other interfaces.
	IsFunc_argsContext()
}

type Func_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_argsContext() *Func_argsContext {
	var p = new(Func_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_func_args
	return p
}

func (*Func_argsContext) IsFunc_argsContext() {}

func NewFunc_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_argsContext {
	var p = new(Func_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_func_args

	return p
}

func (s *Func_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_argsContext) AllFunc_arg() []IFunc_argContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunc_argContext)(nil)).Elem())
	var tst = make([]IFunc_argContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunc_argContext)
		}
	}

	return tst
}

func (s *Func_argsContext) Func_arg(i int) IFunc_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunc_argContext)
}

func (s *Func_argsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Func_argsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Func_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFunc_args(s)
	}
}

func (s *Func_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFunc_args(s)
	}
}

func (p *SyslParser) Func_args() (localctx IFunc_argsContext) {
	localctx = NewFunc_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SyslParserRULE_func_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1090)
		p.Func_arg()
	}
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1091)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1092)
			p.Func_arg()
		}

		p.SetState(1097)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_funcContext is an interface to support dynamic dispatch.
type IExpr_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_funcContext differentiates from other interfaces.
	IsExpr_funcContext()
}

type Expr_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_funcContext() *Expr_funcContext {
	var p = new(Expr_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_func
	return p
}

func (*Expr_funcContext) IsExpr_funcContext() {}

func NewExpr_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_funcContext {
	var p = new(Expr_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_func

	return p
}

func (s *Expr_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_funcContext) E_FUNC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_FUNC, 0)
}

func (s *Expr_funcContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_funcContext) NativeDataTypes() antlr.TerminalNode {
	return s.GetToken(SyslParserNativeDataTypes, 0)
}

func (s *Expr_funcContext) Func_args() IFunc_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_argsContext)
}

func (s *Expr_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_func(s)
	}
}

func (s *Expr_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_func(s)
	}
}

func (p *SyslParser) Expr_func() (localctx IExpr_funcContext) {
	localctx = NewExpr_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, SyslParserRULE_expr_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1098)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserNativeDataTypes || _la == SyslParserE_FUNC || _la == SyslParserE_Name) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1099)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1101)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserNativeDataTypes || (((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(SyslParserE_WHATEVER-73))|(1<<(SyslParserE_ARROW_RIGHT-73))|(1<<(SyslParserE_SQ_OPEN-73))|(1<<(SyslParserE_EMPTY_TUPLE-73))|(1<<(SyslParserE_CURLY_OPEN-73))|(1<<(SyslParserE_NULLSAFE_DOT-73))|(1<<(SyslParserE_OPEN_PAREN-73))|(1<<(SyslParserE_PLUS-73))|(1<<(SyslParserE_MINUS-73))|(1<<(SyslParserE_QN-73))|(1<<(SyslParserE_TILDE-73))|(1<<(SyslParserE_NOT-73)))) != 0) || (((_la-111)&-(0x1f+1)) == 0 && ((1<<uint((_la-111)))&((1<<(SyslParserE_IF-111))|(1<<(SyslParserE_TRUE-111))|(1<<(SyslParserE_FALSE-111))|(1<<(SyslParserE_NULL-111))|(1<<(SyslParserE_FUNC-111))|(1<<(SyslParserE_STRING_DBL-111))|(1<<(SyslParserE_STRING_SINGLE-111))|(1<<(SyslParserE_DECIMAL-111))|(1<<(SyslParserE_DIGITS-111))|(1<<(SyslParserE_Name-111))|(1<<(SyslParserE_DOT-111)))) != 0) {
		{
			p.SetState(1100)
			p.Func_args()
		}

	}
	{
		p.SetState(1103)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IRank_exprContext is an interface to support dynamic dispatch.
type IRank_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRank_exprContext differentiates from other interfaces.
	IsRank_exprContext()
}

type Rank_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRank_exprContext() *Rank_exprContext {
	var p = new(Rank_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rank_expr
	return p
}

func (*Rank_exprContext) IsRank_exprContext() {}

func NewRank_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rank_exprContext {
	var p = new(Rank_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rank_expr

	return p
}

func (s *Rank_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Rank_exprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Rank_exprContext) E_ASC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ASC, 0)
}

func (s *Rank_exprContext) E_DESC() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DESC, 0)
}

func (s *Rank_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rank_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rank_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRank_expr(s)
	}
}

func (s *Rank_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRank_expr(s)
	}
}

func (p *SyslParser) Rank_expr() (localctx IRank_exprContext) {
	localctx = NewRank_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, SyslParserRULE_rank_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1105)
		p.Expr()
	}
	p.SetState(1107)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ASC || _la == SyslParserE_DESC {
		p.SetState(1106)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SyslParserE_ASC || _la == SyslParserE_DESC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IRank_expr_listContext is an interface to support dynamic dispatch.
type IRank_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRank_expr_listContext differentiates from other interfaces.
	IsRank_expr_listContext()
}

type Rank_expr_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRank_expr_listContext() *Rank_expr_listContext {
	var p = new(Rank_expr_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_rank_expr_list
	return p
}

func (*Rank_expr_listContext) IsRank_expr_listContext() {}

func NewRank_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rank_expr_listContext {
	var p = new(Rank_expr_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_rank_expr_list

	return p
}

func (s *Rank_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Rank_expr_listContext) AllRank_expr() []IRank_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRank_exprContext)(nil)).Elem())
	var tst = make([]IRank_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRank_exprContext)
		}
	}

	return tst
}

func (s *Rank_expr_listContext) Rank_expr(i int) IRank_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRank_exprContext)
}

func (s *Rank_expr_listContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Rank_expr_listContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Rank_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rank_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rank_expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRank_expr_list(s)
	}
}

func (s *Rank_expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRank_expr_list(s)
	}
}

func (p *SyslParser) Rank_expr_list() (localctx IRank_expr_listContext) {
	localctx = NewRank_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, SyslParserRULE_rank_expr_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1109)
		p.Rank_expr()
	}
	p.SetState(1114)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1110)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1111)
			p.Rank_expr()
		}

		p.SetState(1116)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_rank_funcContext is an interface to support dynamic dispatch.
type IExpr_rank_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_rank_funcContext differentiates from other interfaces.
	IsExpr_rank_funcContext()
}

type Expr_rank_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_rank_funcContext() *Expr_rank_funcContext {
	var p = new(Expr_rank_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_rank_func
	return p
}

func (*Expr_rank_funcContext) IsExpr_rank_funcContext() {}

func NewExpr_rank_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_rank_funcContext {
	var p = new(Expr_rank_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_rank_func

	return p
}

func (s *Expr_rank_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_rank_funcContext) E_RELOPS_RANK() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_RANK, 0)
}

func (s *Expr_rank_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_rank_funcContext) Rank_expr_list() IRank_expr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_expr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRank_expr_listContext)
}

func (s *Expr_rank_funcContext) E_AS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_AS, 0)
}

func (s *Expr_rank_funcContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_rank_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_rank_funcContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *Expr_rank_funcContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *Expr_rank_funcContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *Expr_rank_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_rank_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_rank_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_rank_func(s)
	}
}

func (s *Expr_rank_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_rank_func(s)
	}
}

func (p *SyslParser) Expr_rank_func() (localctx IExpr_rank_funcContext) {
	localctx = NewExpr_rank_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, SyslParserRULE_expr_rank_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1117)
		p.Match(SyslParserE_RELOPS_RANK)
	}
	p.SetState(1122)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ANGLE_OPEN {
		{
			p.SetState(1118)
			p.Match(SyslParserE_ANGLE_OPEN)
		}
		{
			p.SetState(1119)
			p.View_type_spec()
		}
		{
			p.SetState(1120)
			p.Match(SyslParserE_ANGLE_CLOSE)
		}

	}
	{
		p.SetState(1124)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1125)
		p.Rank_expr_list()
	}
	{
		p.SetState(1126)
		p.Match(SyslParserE_AS)
	}
	{
		p.SetState(1127)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1128)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_agg_funcContext is an interface to support dynamic dispatch.
type IExpr_agg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_agg_funcContext differentiates from other interfaces.
	IsExpr_agg_funcContext()
}

type Expr_agg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_agg_funcContext() *Expr_agg_funcContext {
	var p = new(Expr_agg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_agg_func
	return p
}

func (*Expr_agg_funcContext) IsExpr_agg_funcContext() {}

func NewExpr_agg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_agg_funcContext {
	var p = new(Expr_agg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_agg_func

	return p
}

func (s *Expr_agg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_agg_funcContext) E_RELOPS_AGG() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_AGG, 0)
}

func (s *Expr_agg_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_agg_funcContext) Func_args() IFunc_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunc_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunc_argsContext)
}

func (s *Expr_agg_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_agg_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_agg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_agg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_agg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_agg_func(s)
	}
}

func (s *Expr_agg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_agg_func(s)
	}
}

func (p *SyslParser) Expr_agg_func() (localctx IExpr_agg_funcContext) {
	localctx = NewExpr_agg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, SyslParserRULE_expr_agg_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1130)
		p.Match(SyslParserE_RELOPS_AGG)
	}
	{
		p.SetState(1131)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1133)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1132)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1135)
		p.Func_args()
	}
	{
		p.SetState(1136)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IE_scope_varContext is an interface to support dynamic dispatch.
type IE_scope_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_scope_varContext differentiates from other interfaces.
	IsE_scope_varContext()
}

type E_scope_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_scope_varContext() *E_scope_varContext {
	var p = new(E_scope_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_scope_var
	return p
}

func (*E_scope_varContext) IsE_scope_varContext() {}

func NewE_scope_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_scope_varContext {
	var p = new(E_scope_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_scope_var

	return p
}

func (s *E_scope_varContext) GetParser() antlr.Parser { return s.parser }

func (s *E_scope_varContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *E_scope_varContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *E_scope_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_scope_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_scope_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_scope_var(s)
	}
}

func (s *E_scope_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_scope_var(s)
	}
}

func (p *SyslParser) E_scope_var() (localctx IE_scope_varContext) {
	localctx = NewE_scope_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, SyslParserRULE_e_scope_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1138)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1139)
		p.Match(SyslParserE_COLON)
	}

	return localctx
}

// IFirst_func_targetContext is an interface to support dynamic dispatch.
type IFirst_func_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFirst_func_targetContext differentiates from other interfaces.
	IsFirst_func_targetContext()
}

type First_func_targetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFirst_func_targetContext() *First_func_targetContext {
	var p = new(First_func_targetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_first_func_target
	return p
}

func (*First_func_targetContext) IsFirst_func_targetContext() {}

func NewFirst_func_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *First_func_targetContext {
	var p = new(First_func_targetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_first_func_target

	return p
}

func (s *First_func_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *First_func_targetContext) E_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NULL, 0)
}

func (s *First_func_targetContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *First_func_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *First_func_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *First_func_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFirst_func_target(s)
	}
}

func (s *First_func_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFirst_func_target(s)
	}
}

func (p *SyslParser) First_func_target() (localctx IFirst_func_targetContext) {
	localctx = NewFirst_func_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, SyslParserRULE_first_func_target)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1143)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1141)
			p.Match(SyslParserE_NULL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1142)
			p.Expr()
		}

	}

	return localctx
}

// IExpr_first_funcContext is an interface to support dynamic dispatch.
type IExpr_first_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_first_funcContext differentiates from other interfaces.
	IsExpr_first_funcContext()
}

type Expr_first_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_first_funcContext() *Expr_first_funcContext {
	var p = new(Expr_first_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_first_func
	return p
}

func (*Expr_first_funcContext) IsExpr_first_funcContext() {}

func NewExpr_first_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_first_funcContext {
	var p = new(Expr_first_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_first_func

	return p
}

func (s *Expr_first_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_first_funcContext) E_RELOPS_FIRST() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_FIRST, 0)
}

func (s *Expr_first_funcContext) First_func_target() IFirst_func_targetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFirst_func_targetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFirst_func_targetContext)
}

func (s *Expr_first_funcContext) E_BY() antlr.TerminalNode {
	return s.GetToken(SyslParserE_BY, 0)
}

func (s *Expr_first_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_first_funcContext) Rank_expr_list() IRank_expr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRank_expr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRank_expr_listContext)
}

func (s *Expr_first_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_first_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_first_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_first_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_first_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_first_func(s)
	}
}

func (s *Expr_first_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_first_func(s)
	}
}

func (p *SyslParser) Expr_first_func() (localctx IExpr_first_funcContext) {
	localctx = NewExpr_first_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, SyslParserRULE_expr_first_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1145)
		p.Match(SyslParserE_RELOPS_FIRST)
	}
	{
		p.SetState(1146)
		p.First_func_target()
	}
	{
		p.SetState(1147)
		p.Match(SyslParserE_BY)
	}
	{
		p.SetState(1148)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1150)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1149)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1152)
		p.Rank_expr_list()
	}
	{
		p.SetState(1153)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IE_single_arg_funcContext is an interface to support dynamic dispatch.
type IE_single_arg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_single_arg_funcContext differentiates from other interfaces.
	IsE_single_arg_funcContext()
}

type E_single_arg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_single_arg_funcContext() *E_single_arg_funcContext {
	var p = new(E_single_arg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_single_arg_func
	return p
}

func (*E_single_arg_funcContext) IsE_single_arg_funcContext() {}

func NewE_single_arg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_single_arg_funcContext {
	var p = new(E_single_arg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_single_arg_func

	return p
}

func (s *E_single_arg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *E_single_arg_funcContext) E_RELOPS_WHERE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_WHERE, 0)
}

func (s *E_single_arg_funcContext) E_RELOPS_FLATTEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_FLATTEN, 0)
}

func (s *E_single_arg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_single_arg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_single_arg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_single_arg_func(s)
	}
}

func (s *E_single_arg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_single_arg_func(s)
	}
}

func (p *SyslParser) E_single_arg_func() (localctx IE_single_arg_funcContext) {
	localctx = NewE_single_arg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, SyslParserRULE_e_single_arg_func)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1155)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_RELOPS_WHERE || _la == SyslParserE_RELOPS_FLATTEN) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_single_arg_funcContext is an interface to support dynamic dispatch.
type IExpr_single_arg_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_single_arg_funcContext differentiates from other interfaces.
	IsExpr_single_arg_funcContext()
}

type Expr_single_arg_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_single_arg_funcContext() *Expr_single_arg_funcContext {
	var p = new(Expr_single_arg_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_single_arg_func
	return p
}

func (*Expr_single_arg_funcContext) IsExpr_single_arg_funcContext() {}

func NewExpr_single_arg_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_single_arg_funcContext {
	var p = new(Expr_single_arg_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_single_arg_func

	return p
}

func (s *Expr_single_arg_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_single_arg_funcContext) E_single_arg_func() IE_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_single_arg_funcContext)
}

func (s *Expr_single_arg_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_single_arg_funcContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_single_arg_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_single_arg_funcContext) E_scope_var() IE_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IE_scope_varContext)
}

func (s *Expr_single_arg_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_single_arg_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_single_arg_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_single_arg_func(s)
	}
}

func (s *Expr_single_arg_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_single_arg_func(s)
	}
}

func (p *SyslParser) Expr_single_arg_func() (localctx IExpr_single_arg_funcContext) {
	localctx = NewExpr_single_arg_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, SyslParserRULE_expr_single_arg_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1157)
		p.E_single_arg_func()
	}
	{
		p.SetState(1158)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1160)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1159)
			p.E_scope_var()
		}

	}
	{
		p.SetState(1162)
		p.Expr()
	}
	{
		p.SetState(1163)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_any_funcContext is an interface to support dynamic dispatch.
type IExpr_any_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_any_funcContext differentiates from other interfaces.
	IsExpr_any_funcContext()
}

type Expr_any_funcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_any_funcContext() *Expr_any_funcContext {
	var p = new(Expr_any_funcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_any_func
	return p
}

func (*Expr_any_funcContext) IsExpr_any_funcContext() {}

func NewExpr_any_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_any_funcContext {
	var p = new(Expr_any_funcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_any_func

	return p
}

func (s *Expr_any_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_any_funcContext) E_RELOPS_ANY() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_ANY, 0)
}

func (s *Expr_any_funcContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *Expr_any_funcContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_any_funcContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *Expr_any_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_any_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_any_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_any_func(s)
	}
}

func (s *Expr_any_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_any_func(s)
	}
}

func (p *SyslParser) Expr_any_func() (localctx IExpr_any_funcContext) {
	localctx = NewExpr_any_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, SyslParserRULE_expr_any_func)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1165)
		p.Match(SyslParserE_RELOPS_ANY)
	}
	{
		p.SetState(1166)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1167)
		p.Expr()
	}
	{
		p.SetState(1168)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_single_or_nullContext is an interface to support dynamic dispatch.
type IExpr_single_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_single_or_nullContext differentiates from other interfaces.
	IsExpr_single_or_nullContext()
}

type Expr_single_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_single_or_nullContext() *Expr_single_or_nullContext {
	var p = new(Expr_single_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_single_or_null
	return p
}

func (*Expr_single_or_nullContext) IsExpr_single_or_nullContext() {}

func NewExpr_single_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_single_or_nullContext {
	var p = new(Expr_single_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_single_or_null

	return p
}

func (s *Expr_single_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_single_or_nullContext) E_RELOPS_SINGLE_NULL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_SINGLE_NULL, 0)
}

func (s *Expr_single_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_single_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_single_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_single_or_null(s)
	}
}

func (s *Expr_single_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_single_or_null(s)
	}
}

func (p *SyslParser) Expr_single_or_null() (localctx IExpr_single_or_nullContext) {
	localctx = NewExpr_single_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, SyslParserRULE_expr_single_or_null)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1170)
		p.Match(SyslParserE_RELOPS_SINGLE_NULL)
	}

	return localctx
}

// IExpr_snapshotContext is an interface to support dynamic dispatch.
type IExpr_snapshotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_snapshotContext differentiates from other interfaces.
	IsExpr_snapshotContext()
}

type Expr_snapshotContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_snapshotContext() *Expr_snapshotContext {
	var p = new(Expr_snapshotContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_snapshot
	return p
}

func (*Expr_snapshotContext) IsExpr_snapshotContext() {}

func NewExpr_snapshotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_snapshotContext {
	var p = new(Expr_snapshotContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_snapshot

	return p
}

func (s *Expr_snapshotContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_snapshotContext) E_RELOPS_SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_SNAPSHOT, 0)
}

func (s *Expr_snapshotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_snapshotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_snapshotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_snapshot(s)
	}
}

func (s *Expr_snapshotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_snapshot(s)
	}
}

func (p *SyslParser) Expr_snapshot() (localctx IExpr_snapshotContext) {
	localctx = NewExpr_snapshotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, SyslParserRULE_expr_snapshot)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1172)
		p.Match(SyslParserE_RELOPS_SNAPSHOT)
	}

	return localctx
}

// IExpr_countContext is an interface to support dynamic dispatch.
type IExpr_countContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_countContext differentiates from other interfaces.
	IsExpr_countContext()
}

type Expr_countContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_countContext() *Expr_countContext {
	var p = new(Expr_countContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_count
	return p
}

func (*Expr_countContext) IsExpr_countContext() {}

func NewExpr_countContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_countContext {
	var p = new(Expr_countContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_count

	return p
}

func (s *Expr_countContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_countContext) E_RELOPS_COUNT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_RELOPS_COUNT, 0)
}

func (s *Expr_countContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_countContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_countContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_count(s)
	}
}

func (s *Expr_countContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_count(s)
	}
}

func (p *SyslParser) Expr_count() (localctx IExpr_countContext) {
	localctx = NewExpr_countContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, SyslParserRULE_expr_count)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1174)
		p.Match(SyslParserE_RELOPS_COUNT)
	}

	return localctx
}

// IExpr_navigate_attrContext is an interface to support dynamic dispatch.
type IExpr_navigate_attrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_navigate_attrContext differentiates from other interfaces.
	IsExpr_navigate_attrContext()
}

type Expr_navigate_attrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_navigate_attrContext() *Expr_navigate_attrContext {
	var p = new(Expr_navigate_attrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_navigate_attr
	return p
}

func (*Expr_navigate_attrContext) IsExpr_navigate_attrContext() {}

func NewExpr_navigate_attrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_navigate_attrContext {
	var p = new(Expr_navigate_attrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_navigate_attr

	return p
}

func (s *Expr_navigate_attrContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_navigate_attrContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_navigate_attrContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_navigate_attrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_navigate_attrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_navigate_attrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_navigate_attr(s)
	}
}

func (s *Expr_navigate_attrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_navigate_attr(s)
	}
}

func (p *SyslParser) Expr_navigate_attr() (localctx IExpr_navigate_attrContext) {
	localctx = NewExpr_navigate_attrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, SyslParserRULE_expr_navigate_attr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1177)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_DOT {
		{
			p.SetState(1176)
			p.Match(SyslParserE_DOT)
		}

	}
	{
		p.SetState(1179)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// IExpr_navigateContext is an interface to support dynamic dispatch.
type IExpr_navigateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_navigateContext differentiates from other interfaces.
	IsExpr_navigateContext()
}

type Expr_navigateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_navigateContext() *Expr_navigateContext {
	var p = new(Expr_navigateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_navigate
	return p
}

func (*Expr_navigateContext) IsExpr_navigateContext() {}

func NewExpr_navigateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_navigateContext {
	var p = new(Expr_navigateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_navigate

	return p
}

func (s *Expr_navigateContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_navigateContext) E_ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ARROW_RIGHT, 0)
}

func (s *Expr_navigateContext) Expr_navigate_attr() IExpr_navigate_attrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigate_attrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigate_attrContext)
}

func (s *Expr_navigateContext) E_QN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_QN, 0)
}

func (s *Expr_navigateContext) E_VIA() antlr.TerminalNode {
	return s.GetToken(SyslParserE_VIA, 0)
}

func (s *Expr_navigateContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_navigateContext) E_SET_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SET_OF, 0)
}

func (s *Expr_navigateContext) E_SEQUENCE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SEQUENCE_OF, 0)
}

func (s *Expr_navigateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_navigateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_navigateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_navigate(s)
	}
}

func (s *Expr_navigateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_navigate(s)
	}
}

func (p *SyslParser) Expr_navigate() (localctx IExpr_navigateContext) {
	localctx = NewExpr_navigateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, SyslParserRULE_expr_navigate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1182)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_QN {
		{
			p.SetState(1181)
			p.Match(SyslParserE_QN)
		}

	}
	{
		p.SetState(1184)
		p.Match(SyslParserE_ARROW_RIGHT)
	}
	p.SetState(1186)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_SEQUENCE_OF || _la == SyslParserE_SET_OF {
		p.SetState(1185)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SyslParserE_SEQUENCE_OF || _la == SyslParserE_SET_OF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(1188)
		p.Expr_navigate_attr()
	}
	p.SetState(1191)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1189)
			p.Match(SyslParserE_VIA)
		}
		{
			p.SetState(1190)
			p.Match(SyslParserE_Name)
		}

	}

	return localctx
}

// IMatching_rhsContext is an interface to support dynamic dispatch.
type IMatching_rhsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatching_rhsContext differentiates from other interfaces.
	IsMatching_rhsContext()
}

type Matching_rhsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatching_rhsContext() *Matching_rhsContext {
	var p = new(Matching_rhsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_matching_rhs
	return p
}

func (*Matching_rhsContext) IsMatching_rhsContext() {}

func NewMatching_rhsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Matching_rhsContext {
	var p = new(Matching_rhsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_matching_rhs

	return p
}

func (s *Matching_rhsContext) GetParser() antlr.Parser { return s.parser }

func (s *Matching_rhsContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *Matching_rhsContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *Matching_rhsContext) AtomT_paren() IAtomT_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_parenContext)
}

func (s *Matching_rhsContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Matching_rhsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Matching_rhsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Matching_rhsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterMatching_rhs(s)
	}
}

func (s *Matching_rhsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitMatching_rhs(s)
	}
}

func (p *SyslParser) Matching_rhs() (localctx IMatching_rhsContext) {
	localctx = NewMatching_rhsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, SyslParserRULE_matching_rhs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1197)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_NULLSAFE_DOT, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1193)
			p.Expr_table_of_op()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1194)
			p.Expr_navigate()
		}

	case SyslParserE_OPEN_PAREN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1195)
			p.AtomT_paren()
		}

	case SyslParserE_Name:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1196)
			p.Match(SyslParserE_Name)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISquiggly_argsContext is an interface to support dynamic dispatch.
type ISquiggly_argsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSquiggly_argsContext differentiates from other interfaces.
	IsSquiggly_argsContext()
}

type Squiggly_argsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySquiggly_argsContext() *Squiggly_argsContext {
	var p = new(Squiggly_argsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_squiggly_args
	return p
}

func (*Squiggly_argsContext) IsSquiggly_argsContext() {}

func NewSquiggly_argsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Squiggly_argsContext {
	var p = new(Squiggly_argsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_squiggly_args

	return p
}

func (s *Squiggly_argsContext) GetParser() antlr.Parser { return s.parser }

func (s *Squiggly_argsContext) E_SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_OPEN, 0)
}

func (s *Squiggly_argsContext) AllE_Name() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_Name)
}

func (s *Squiggly_argsContext) E_Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, i)
}

func (s *Squiggly_argsContext) E_SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_CLOSE, 0)
}

func (s *Squiggly_argsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Squiggly_argsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Squiggly_argsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Squiggly_argsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Squiggly_argsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSquiggly_args(s)
	}
}

func (s *Squiggly_argsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSquiggly_args(s)
	}
}

func (p *SyslParser) Squiggly_args() (localctx ISquiggly_argsContext) {
	localctx = NewSquiggly_argsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, SyslParserRULE_squiggly_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1199)
		p.Match(SyslParserE_SQ_OPEN)
	}
	{
		p.SetState(1200)
		p.Match(SyslParserE_Name)
	}
	p.SetState(1205)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1201)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1202)
			p.Match(SyslParserE_Name)
		}

		p.SetState(1207)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1208)
		p.Match(SyslParserE_SQ_CLOSE)
	}

	return localctx
}

// IExpr_matchingContext is an interface to support dynamic dispatch.
type IExpr_matchingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_matchingContext differentiates from other interfaces.
	IsExpr_matchingContext()
}

type Expr_matchingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_matchingContext() *Expr_matchingContext {
	var p = new(Expr_matchingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_matching
	return p
}

func (*Expr_matchingContext) IsExpr_matchingContext() {}

func NewExpr_matchingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_matchingContext {
	var p = new(Expr_matchingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_matching

	return p
}

func (s *Expr_matchingContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_matchingContext) E_TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TILDE, 0)
}

func (s *Expr_matchingContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *Expr_matchingContext) Matching_rhs() IMatching_rhsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMatching_rhsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMatching_rhsContext)
}

func (s *Expr_matchingContext) E_NOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NOT, 0)
}

func (s *Expr_matchingContext) Squiggly_args() ISquiggly_argsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISquiggly_argsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISquiggly_argsContext)
}

func (s *Expr_matchingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_matchingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_matchingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_matching(s)
	}
}

func (s *Expr_matchingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_matching(s)
	}
}

func (p *SyslParser) Expr_matching() (localctx IExpr_matchingContext) {
	localctx = NewExpr_matchingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, SyslParserRULE_expr_matching)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1211)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_NOT {
		{
			p.SetState(1210)
			p.Match(SyslParserE_NOT)
		}

	}
	{
		p.SetState(1213)
		p.Match(SyslParserE_TILDE)
	}
	p.SetState(1215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_SQ_OPEN {
		{
			p.SetState(1214)
			p.Squiggly_args()
		}

	}
	{
		p.SetState(1217)
		p.Match(SyslParserE_ANGLE_CLOSE)
	}
	{
		p.SetState(1218)
		p.Matching_rhs()
	}

	return localctx
}

// IRelopContext is an interface to support dynamic dispatch.
type IRelopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelopContext differentiates from other interfaces.
	IsRelopContext()
}

type RelopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelopContext() *RelopContext {
	var p = new(RelopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_relop
	return p
}

func (*RelopContext) IsRelopContext() {}

func NewRelopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelopContext {
	var p = new(RelopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_relop

	return p
}

func (s *RelopContext) GetParser() antlr.Parser { return s.parser }

func (s *RelopContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *RelopContext) Expr_rank_func() IExpr_rank_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_rank_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_rank_funcContext)
}

func (s *RelopContext) Expr_agg_func() IExpr_agg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_agg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_funcContext)
}

func (s *RelopContext) Expr_single_arg_func() IExpr_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_arg_funcContext)
}

func (s *RelopContext) Expr_any_func() IExpr_any_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_any_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_any_funcContext)
}

func (s *RelopContext) Expr_count() IExpr_countContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_countContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_countContext)
}

func (s *RelopContext) Expr_single_or_null() IExpr_single_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_or_nullContext)
}

func (s *RelopContext) Expr_snapshot() IExpr_snapshotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_snapshotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_snapshotContext)
}

func (s *RelopContext) Expr_first_func() IExpr_first_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_first_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_first_funcContext)
}

func (s *RelopContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *RelopContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *RelopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterRelop(s)
	}
}

func (s *RelopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitRelop(s)
	}
}

func (p *SyslParser) Relop() (localctx IRelopContext) {
	localctx = NewRelopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, SyslParserRULE_relop)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1231)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_NULLSAFE_DOT, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1220)
			p.Expr_table_of_op()
		}

	case SyslParserE_RELOPS_RANK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1221)
			p.Expr_rank_func()
		}

	case SyslParserE_RELOPS_AGG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1222)
			p.Expr_agg_func()
		}

	case SyslParserE_RELOPS_WHERE, SyslParserE_RELOPS_FLATTEN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1223)
			p.Expr_single_arg_func()
		}

	case SyslParserE_RELOPS_ANY:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1224)
			p.Expr_any_func()
		}

	case SyslParserE_RELOPS_COUNT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1225)
			p.Expr_count()
		}

	case SyslParserE_RELOPS_SINGLE_NULL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1226)
			p.Expr_single_or_null()
		}

	case SyslParserE_RELOPS_SNAPSHOT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1227)
			p.Expr_snapshot()
		}

	case SyslParserE_RELOPS_FIRST:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1228)
			p.Expr_first_func()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1229)
			p.Expr_navigate()
		}

	case SyslParserE_TILDE, SyslParserE_NOT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1230)
			p.Expr_matching()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_itemContext is an interface to support dynamic dispatch.
type IList_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_itemContext differentiates from other interfaces.
	IsList_itemContext()
}

type List_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_itemContext() *List_itemContext {
	var p = new(List_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_list_item
	return p
}

func (*List_itemContext) IsList_itemContext() {}

func NewList_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_itemContext {
	var p = new(List_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_list_item

	return p
}

func (s *List_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *List_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *List_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterList_item(s)
	}
}

func (s *List_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitList_item(s)
	}
}

func (p *SyslParser) List_item() (localctx IList_itemContext) {
	localctx = NewList_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, SyslParserRULE_list_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1233)
		p.Expr()
	}

	return localctx
}

// IExpr_listContext is an interface to support dynamic dispatch.
type IExpr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_listContext differentiates from other interfaces.
	IsExpr_listContext()
}

type Expr_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_listContext() *Expr_listContext {
	var p = new(Expr_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_list
	return p
}

func (*Expr_listContext) IsExpr_listContext() {}

func NewExpr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_listContext {
	var p = new(Expr_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_list

	return p
}

func (s *Expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_listContext) AllList_item() []IList_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_itemContext)(nil)).Elem())
	var tst = make([]IList_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_itemContext)
		}
	}

	return tst
}

func (s *Expr_listContext) List_item(i int) IList_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_itemContext)
}

func (s *Expr_listContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *Expr_listContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *Expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_list(s)
	}
}

func (s *Expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_list(s)
	}
}

func (p *SyslParser) Expr_list() (localctx IExpr_listContext) {
	localctx = NewExpr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, SyslParserRULE_expr_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1235)
		p.List_item()
	}
	p.SetState(1240)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1236)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1237)
			p.List_item()
		}

		p.SetState(1242)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpr_setContext is an interface to support dynamic dispatch.
type IExpr_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_setContext differentiates from other interfaces.
	IsExpr_setContext()
}

type Expr_setContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_setContext() *Expr_setContext {
	var p = new(Expr_setContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_set
	return p
}

func (*Expr_setContext) IsExpr_setContext() {}

func NewExpr_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_setContext {
	var p = new(Expr_setContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_set

	return p
}

func (s *Expr_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_setContext) E_CURLY_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CURLY_OPEN, 0)
}

func (s *Expr_setContext) Expr_list() IExpr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Expr_setContext) E_CURLY_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CURLY_CLOSE, 0)
}

func (s *Expr_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_set(s)
	}
}

func (s *Expr_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_set(s)
	}
}

func (p *SyslParser) Expr_set() (localctx IExpr_setContext) {
	localctx = NewExpr_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, SyslParserRULE_expr_set)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1243)
		p.Match(SyslParserE_CURLY_OPEN)
	}
	{
		p.SetState(1244)
		p.Expr_list()
	}
	{
		p.SetState(1245)
		p.Match(SyslParserE_CURLY_CLOSE)
	}

	return localctx
}

// IEmpty_tupleContext is an interface to support dynamic dispatch.
type IEmpty_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmpty_tupleContext differentiates from other interfaces.
	IsEmpty_tupleContext()
}

type Empty_tupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_tupleContext() *Empty_tupleContext {
	var p = new(Empty_tupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_empty_tuple
	return p
}

func (*Empty_tupleContext) IsEmpty_tupleContext() {}

func NewEmpty_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_tupleContext {
	var p = new(Empty_tupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_empty_tuple

	return p
}

func (s *Empty_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Empty_tupleContext) E_EMPTY_TUPLE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EMPTY_TUPLE, 0)
}

func (s *Empty_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterEmpty_tuple(s)
	}
}

func (s *Empty_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitEmpty_tuple(s)
	}
}

func (p *SyslParser) Empty_tuple() (localctx IEmpty_tupleContext) {
	localctx = NewEmpty_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, SyslParserRULE_empty_tuple)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1247)
		p.Match(SyslParserE_EMPTY_TUPLE)
	}

	return localctx
}

// IAtom_dot_relopContext is an interface to support dynamic dispatch.
type IAtom_dot_relopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtom_dot_relopContext differentiates from other interfaces.
	IsAtom_dot_relopContext()
}

type Atom_dot_relopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_dot_relopContext() *Atom_dot_relopContext {
	var p = new(Atom_dot_relopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atom_dot_relop
	return p
}

func (*Atom_dot_relopContext) IsAtom_dot_relopContext() {}

func NewAtom_dot_relopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_dot_relopContext {
	var p = new(Atom_dot_relopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atom_dot_relop

	return p
}

func (s *Atom_dot_relopContext) GetParser() antlr.Parser { return s.parser }

func (s *Atom_dot_relopContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Atom_dot_relopContext) Expr_rank_func() IExpr_rank_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_rank_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_rank_funcContext)
}

func (s *Atom_dot_relopContext) Expr_agg_func() IExpr_agg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_agg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_funcContext)
}

func (s *Atom_dot_relopContext) Expr_single_arg_func() IExpr_single_arg_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_arg_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_arg_funcContext)
}

func (s *Atom_dot_relopContext) Expr_any_func() IExpr_any_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_any_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_any_funcContext)
}

func (s *Atom_dot_relopContext) Expr_count() IExpr_countContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_countContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_countContext)
}

func (s *Atom_dot_relopContext) Expr_single_or_null() IExpr_single_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_single_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_single_or_nullContext)
}

func (s *Atom_dot_relopContext) Expr_snapshot() IExpr_snapshotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_snapshotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_snapshotContext)
}

func (s *Atom_dot_relopContext) Expr_first_func() IExpr_first_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_first_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_first_funcContext)
}

func (s *Atom_dot_relopContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *Atom_dot_relopContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *Atom_dot_relopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_dot_relopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atom_dot_relopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtom_dot_relop(s)
	}
}

func (s *Atom_dot_relopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtom_dot_relop(s)
	}
}

func (p *SyslParser) Atom_dot_relop() (localctx IAtom_dot_relopContext) {
	localctx = NewAtom_dot_relopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, SyslParserRULE_atom_dot_relop)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1249)
		p.Match(SyslParserE_DOT)
	}
	p.SetState(1260)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_RELOPS_RANK:
		{
			p.SetState(1250)
			p.Expr_rank_func()
		}

	case SyslParserE_RELOPS_AGG:
		{
			p.SetState(1251)
			p.Expr_agg_func()
		}

	case SyslParserE_RELOPS_WHERE, SyslParserE_RELOPS_FLATTEN:
		{
			p.SetState(1252)
			p.Expr_single_arg_func()
		}

	case SyslParserE_RELOPS_ANY:
		{
			p.SetState(1253)
			p.Expr_any_func()
		}

	case SyslParserE_RELOPS_COUNT:
		{
			p.SetState(1254)
			p.Expr_count()
		}

	case SyslParserE_RELOPS_SINGLE_NULL:
		{
			p.SetState(1255)
			p.Expr_single_or_null()
		}

	case SyslParserE_RELOPS_SNAPSHOT:
		{
			p.SetState(1256)
			p.Expr_snapshot()
		}

	case SyslParserE_RELOPS_FIRST:
		{
			p.SetState(1257)
			p.Expr_first_func()
		}

	case SyslParserE_ARROW_RIGHT, SyslParserE_QN:
		{
			p.SetState(1258)
			p.Expr_navigate()
		}

	case SyslParserE_TILDE, SyslParserE_NOT:
		{
			p.SetState(1259)
			p.Expr_matching()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAtomT_implied_dotContext is an interface to support dynamic dispatch.
type IAtomT_implied_dotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_implied_dotContext differentiates from other interfaces.
	IsAtomT_implied_dotContext()
}

type AtomT_implied_dotContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_implied_dotContext() *AtomT_implied_dotContext {
	var p = new(AtomT_implied_dotContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_implied_dot
	return p
}

func (*AtomT_implied_dotContext) IsAtomT_implied_dotContext() {}

func NewAtomT_implied_dotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_implied_dotContext {
	var p = new(AtomT_implied_dotContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_implied_dot

	return p
}

func (s *AtomT_implied_dotContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_implied_dotContext) Atom_dot_relop() IAtom_dot_relopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_dot_relopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_dot_relopContext)
}

func (s *AtomT_implied_dotContext) Expr_navigate() IExpr_navigateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_navigateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_navigateContext)
}

func (s *AtomT_implied_dotContext) Expr_matching() IExpr_matchingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_matchingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_matchingContext)
}

func (s *AtomT_implied_dotContext) Expr_table_of_op() IExpr_table_of_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_opContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_opContext)
}

func (s *AtomT_implied_dotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_implied_dotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_implied_dotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_implied_dot(s)
	}
}

func (s *AtomT_implied_dotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_implied_dot(s)
	}
}

func (p *SyslParser) AtomT_implied_dot() (localctx IAtomT_implied_dotContext) {
	localctx = NewAtomT_implied_dotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, SyslParserRULE_atomT_implied_dot)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1266)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1262)
			p.Atom_dot_relop()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1263)
			p.Expr_navigate()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1264)
			p.Expr_matching()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1265)
			p.Expr_table_of_op()
		}

	}

	return localctx
}

// IAtomT_nameContext is an interface to support dynamic dispatch.
type IAtomT_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_nameContext differentiates from other interfaces.
	IsAtomT_nameContext()
}

type AtomT_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_nameContext() *AtomT_nameContext {
	var p = new(AtomT_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_name
	return p
}

func (*AtomT_nameContext) IsAtomT_nameContext() {}

func NewAtomT_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_nameContext {
	var p = new(AtomT_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_name

	return p
}

func (s *AtomT_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_nameContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *AtomT_nameContext) E_WHATEVER() antlr.TerminalNode {
	return s.GetToken(SyslParserE_WHATEVER, 0)
}

func (s *AtomT_nameContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *AtomT_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_name(s)
	}
}

func (s *AtomT_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_name(s)
	}
}

func (p *SyslParser) AtomT_name() (localctx IAtomT_nameContext) {
	localctx = NewAtomT_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, SyslParserRULE_atomT_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1268)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_WHATEVER || _la == SyslParserE_Name || _la == SyslParserE_DOT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IAtomT_parenContext is an interface to support dynamic dispatch.
type IAtomT_parenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomT_parenContext differentiates from other interfaces.
	IsAtomT_parenContext()
}

type AtomT_parenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomT_parenContext() *AtomT_parenContext {
	var p = new(AtomT_parenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT_paren
	return p
}

func (*AtomT_parenContext) IsAtomT_parenContext() {}

func NewAtomT_parenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomT_parenContext {
	var p = new(AtomT_parenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT_paren

	return p
}

func (s *AtomT_parenContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomT_parenContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *AtomT_parenContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AtomT_parenContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *AtomT_parenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomT_parenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomT_parenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT_paren(s)
	}
}

func (s *AtomT_parenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT_paren(s)
	}
}

func (p *SyslParser) AtomT_paren() (localctx IAtomT_parenContext) {
	localctx = NewAtomT_parenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, SyslParserRULE_atomT_paren)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1270)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	{
		p.SetState(1271)
		p.Expr()
	}
	{
		p.SetState(1272)
		p.Match(SyslParserE_CLOSE_PAREN)
	}

	return localctx
}

// IExpr_atom_listContext is an interface to support dynamic dispatch.
type IExpr_atom_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_atom_listContext differentiates from other interfaces.
	IsExpr_atom_listContext()
}

type Expr_atom_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_atom_listContext() *Expr_atom_listContext {
	var p = new(Expr_atom_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_atom_list
	return p
}

func (*Expr_atom_listContext) IsExpr_atom_listContext() {}

func NewExpr_atom_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_atom_listContext {
	var p = new(Expr_atom_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_atom_list

	return p
}

func (s *Expr_atom_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_atom_listContext) E_SQ_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_OPEN, 0)
}

func (s *Expr_atom_listContext) Expr_list() IExpr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Expr_atom_listContext) E_SQ_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_SQ_CLOSE, 0)
}

func (s *Expr_atom_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_atom_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_atom_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_atom_list(s)
	}
}

func (s *Expr_atom_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_atom_list(s)
	}
}

func (p *SyslParser) Expr_atom_list() (localctx IExpr_atom_listContext) {
	localctx = NewExpr_atom_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, SyslParserRULE_expr_atom_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1274)
		p.Match(SyslParserE_SQ_OPEN)
	}
	{
		p.SetState(1275)
		p.Expr_list()
	}
	{
		p.SetState(1276)
		p.Match(SyslParserE_SQ_CLOSE)
	}

	return localctx
}

// IAtomTContext is an interface to support dynamic dispatch.
type IAtomTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomTContext differentiates from other interfaces.
	IsAtomTContext()
}

type AtomTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomTContext() *AtomTContext {
	var p = new(AtomTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atomT
	return p
}

func (*AtomTContext) IsAtomTContext() {}

func NewAtomTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomTContext {
	var p = new(AtomTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atomT

	return p
}

func (s *AtomTContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomTContext) Expr_func() IExpr_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *AtomTContext) Expr_set() IExpr_setContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_setContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_setContext)
}

func (s *AtomTContext) Expr_atom_list() IExpr_atom_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_atom_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_atom_listContext)
}

func (s *AtomTContext) Empty_tuple() IEmpty_tupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmpty_tupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmpty_tupleContext)
}

func (s *AtomTContext) AtomT_paren() IAtomT_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_parenContext)
}

func (s *AtomTContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AtomTContext) AtomT_implied_dot() IAtomT_implied_dotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_implied_dotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_implied_dotContext)
}

func (s *AtomTContext) AtomT_name() IAtomT_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomT_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomT_nameContext)
}

func (s *AtomTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtomT(s)
	}
}

func (s *AtomTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtomT(s)
	}
}

func (p *SyslParser) AtomT() (localctx IAtomTContext) {
	localctx = NewAtomTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, SyslParserRULE_atomT)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1286)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1278)
			p.Expr_func()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1279)
			p.Expr_set()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1280)
			p.Expr_atom_list()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1281)
			p.Empty_tuple()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1282)
			p.AtomT_paren()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1283)
			p.Literal()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1284)
			p.AtomT_implied_dot()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1285)
			p.AtomT_name()
		}

	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) AtomT() IAtomTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomTContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomTContext)
}

func (s *AtomContext) AllRelop() []IRelopContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelopContext)(nil)).Elem())
	var tst = make([]IRelopContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelopContext)
		}
	}

	return tst
}

func (s *AtomContext) Relop(i int) IRelopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelopContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelopContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *SyslParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, SyslParserRULE_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1288)
		p.AtomT()
	}
	p.SetState(1292)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1289)
				p.Relop()
			}

		}
		p.SetState(1294)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext())
	}

	return localctx
}

// IPowerTContext is an interface to support dynamic dispatch.
type IPowerTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerTContext differentiates from other interfaces.
	IsPowerTContext()
}

type PowerTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerTContext() *PowerTContext {
	var p = new(PowerTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_powerT
	return p
}

func (*PowerTContext) IsPowerTContext() {}

func NewPowerTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerTContext {
	var p = new(PowerTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_powerT

	return p
}

func (s *PowerTContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerTContext) E_POW() antlr.TerminalNode {
	return s.GetToken(SyslParserE_POW, 0)
}

func (s *PowerTContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *PowerTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPowerT(s)
	}
}

func (s *PowerTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPowerT(s)
	}
}

func (p *SyslParser) PowerT() (localctx IPowerTContext) {
	localctx = NewPowerTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, SyslParserRULE_powerT)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1295)
		p.Match(SyslParserE_POW)
	}
	{
		p.SetState(1296)
		p.UnaryTerm()
	}

	return localctx
}

// IPowerContext is an interface to support dynamic dispatch.
type IPowerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerContext differentiates from other interfaces.
	IsPowerContext()
}

type PowerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerContext() *PowerContext {
	var p = new(PowerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_power
	return p
}

func (*PowerContext) IsPowerContext() {}

func NewPowerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerContext {
	var p = new(PowerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_power

	return p
}

func (s *PowerContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PowerContext) PowerT() IPowerTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerTContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowerTContext)
}

func (s *PowerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPower(s)
	}
}

func (s *PowerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPower(s)
	}
}

func (p *SyslParser) Power() (localctx IPowerContext) {
	localctx = NewPowerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, SyslParserRULE_power)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1298)
		p.Atom()
	}
	p.SetState(1300)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1299)
			p.PowerT()
		}

	}

	return localctx
}

// IUnaryTermContext is an interface to support dynamic dispatch.
type IUnaryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryTermContext differentiates from other interfaces.
	IsUnaryTermContext()
}

type UnaryTermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryTermContext() *UnaryTermContext {
	var p = new(UnaryTermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_unaryTerm
	return p
}

func (*UnaryTermContext) IsUnaryTermContext() {}

func NewUnaryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryTermContext {
	var p = new(UnaryTermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_unaryTerm

	return p
}

func (s *UnaryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryTermContext) Power() IPowerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowerContext)
}

func (s *UnaryTermContext) E_PLUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_PLUS, 0)
}

func (s *UnaryTermContext) E_MINUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MINUS, 0)
}

func (s *UnaryTermContext) E_NOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NOT, 0)
}

func (s *UnaryTermContext) E_TILDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TILDE, 0)
}

func (s *UnaryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterUnaryTerm(s)
	}
}

func (s *UnaryTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitUnaryTerm(s)
	}
}

func (p *SyslParser) UnaryTerm() (localctx IUnaryTermContext) {
	localctx = NewUnaryTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, SyslParserRULE_unaryTerm)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1303)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) == 1 {
		p.SetState(1302)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-94)&-(0x1f+1)) == 0 && ((1<<uint((_la-94)))&((1<<(SyslParserE_PLUS-94))|(1<<(SyslParserE_MINUS-94))|(1<<(SyslParserE_TILDE-94))|(1<<(SyslParserE_NOT-94)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(1305)
		p.Power()
	}

	return localctx
}

// ITermTContext is an interface to support dynamic dispatch.
type ITermTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermTContext differentiates from other interfaces.
	IsTermTContext()
}

type TermTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermTContext() *TermTContext {
	var p = new(TermTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_termT
	return p
}

func (*TermTContext) IsTermTContext() {}

func NewTermTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermTContext {
	var p = new(TermTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_termT

	return p
}

func (s *TermTContext) GetParser() antlr.Parser { return s.parser }

func (s *TermTContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *TermTContext) E_STAR() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STAR, 0)
}

func (s *TermTContext) E_DIVIDE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DIVIDE, 0)
}

func (s *TermTContext) E_MOD() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MOD, 0)
}

func (s *TermTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTermT(s)
	}
}

func (s *TermTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTermT(s)
	}
}

func (p *SyslParser) TermT() (localctx ITermTContext) {
	localctx = NewTermTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, SyslParserRULE_termT)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1307)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-95)&-(0x1f+1)) == 0 && ((1<<uint((_la-95)))&((1<<(SyslParserE_DIVIDE-95))|(1<<(SyslParserE_MOD-95))|(1<<(SyslParserE_STAR-95)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1308)
		p.UnaryTerm()
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) UnaryTerm() IUnaryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryTermContext)
}

func (s *TermContext) AllTermT() []ITermTContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermTContext)(nil)).Elem())
	var tst = make([]ITermTContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermTContext)
		}
	}

	return tst
}

func (s *TermContext) TermT(i int) ITermTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermTContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermTContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (p *SyslParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, SyslParserRULE_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1310)
		p.UnaryTerm()
	}
	p.SetState(1314)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1311)
				p.TermT()
			}

		}
		p.SetState(1316)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())
	}

	return localctx
}

// IBinexprTContext is an interface to support dynamic dispatch.
type IBinexprTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinexprTContext differentiates from other interfaces.
	IsBinexprTContext()
}

type BinexprTContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinexprTContext() *BinexprTContext {
	var p = new(BinexprTContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_binexprT
	return p
}

func (*BinexprTContext) IsBinexprTContext() {}

func NewBinexprTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinexprTContext {
	var p = new(BinexprTContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_binexprT

	return p
}

func (s *BinexprTContext) GetParser() antlr.Parser { return s.parser }

func (s *BinexprTContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *BinexprTContext) E_PLUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_PLUS, 0)
}

func (s *BinexprTContext) E_MINUS() antlr.TerminalNode {
	return s.GetToken(SyslParserE_MINUS, 0)
}

func (s *BinexprTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinexprTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinexprTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterBinexprT(s)
	}
}

func (s *BinexprTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitBinexprT(s)
	}
}

func (p *SyslParser) BinexprT() (localctx IBinexprTContext) {
	localctx = NewBinexprTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, SyslParserRULE_binexprT)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1317)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SyslParserE_PLUS || _la == SyslParserE_MINUS) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1318)
		p.Term()
	}

	return localctx
}

// IBinexprContext is an interface to support dynamic dispatch.
type IBinexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinexprContext differentiates from other interfaces.
	IsBinexprContext()
}

type BinexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinexprContext() *BinexprContext {
	var p = new(BinexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_binexpr
	return p
}

func (*BinexprContext) IsBinexprContext() {}

func NewBinexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinexprContext {
	var p = new(BinexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_binexpr

	return p
}

func (s *BinexprContext) GetParser() antlr.Parser { return s.parser }

func (s *BinexprContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *BinexprContext) AllBinexprT() []IBinexprTContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinexprTContext)(nil)).Elem())
	var tst = make([]IBinexprTContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinexprTContext)
		}
	}

	return tst
}

func (s *BinexprContext) BinexprT(i int) IBinexprTContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinexprTContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinexprTContext)
}

func (s *BinexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterBinexpr(s)
	}
}

func (s *BinexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitBinexpr(s)
	}
}

func (p *SyslParser) Binexpr() (localctx IBinexprContext) {
	localctx = NewBinexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, SyslParserRULE_binexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1320)
		p.Term()
	}
	p.SetState(1324)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1321)
				p.BinexprT()
			}

		}
		p.SetState(1326)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())
	}

	return localctx
}

// IE_compare_opsContext is an interface to support dynamic dispatch.
type IE_compare_opsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsE_compare_opsContext differentiates from other interfaces.
	IsE_compare_opsContext()
}

type E_compare_opsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyE_compare_opsContext() *E_compare_opsContext {
	var p = new(E_compare_opsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_e_compare_ops
	return p
}

func (*E_compare_opsContext) IsE_compare_opsContext() {}

func NewE_compare_opsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *E_compare_opsContext {
	var p = new(E_compare_opsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_e_compare_ops

	return p
}

func (s *E_compare_opsContext) GetParser() antlr.Parser { return s.parser }

func (s *E_compare_opsContext) E_REL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_REL, 0)
}

func (s *E_compare_opsContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *E_compare_opsContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *E_compare_opsContext) E_DOUBLE_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_EQ, 0)
}

func (s *E_compare_opsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *E_compare_opsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *E_compare_opsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterE_compare_ops(s)
	}
}

func (s *E_compare_opsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitE_compare_ops(s)
	}
}

func (p *SyslParser) E_compare_ops() (localctx IE_compare_opsContext) {
	localctx = NewE_compare_opsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, SyslParserRULE_e_compare_ops)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1327)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(SyslParserE_DOUBLE_EQ-76))|(1<<(SyslParserE_REL-76))|(1<<(SyslParserE_ANGLE_OPEN-76))|(1<<(SyslParserE_ANGLE_CLOSE-76)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IExpr_relContext is an interface to support dynamic dispatch.
type IExpr_relContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_relContext differentiates from other interfaces.
	IsExpr_relContext()
}

type Expr_relContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_relContext() *Expr_relContext {
	var p = new(Expr_relContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_rel
	return p
}

func (*Expr_relContext) IsExpr_relContext() {}

func NewExpr_relContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_relContext {
	var p = new(Expr_relContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_rel

	return p
}

func (s *Expr_relContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_relContext) AllBinexpr() []IBinexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinexprContext)(nil)).Elem())
	var tst = make([]IBinexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinexprContext)
		}
	}

	return tst
}

func (s *Expr_relContext) Binexpr(i int) IBinexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinexprContext)
}

func (s *Expr_relContext) AllE_compare_ops() []IE_compare_opsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IE_compare_opsContext)(nil)).Elem())
	var tst = make([]IE_compare_opsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IE_compare_opsContext)
		}
	}

	return tst
}

func (s *Expr_relContext) E_compare_ops(i int) IE_compare_opsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IE_compare_opsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IE_compare_opsContext)
}

func (s *Expr_relContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_relContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_relContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_rel(s)
	}
}

func (s *Expr_relContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_rel(s)
	}
}

func (p *SyslParser) Expr_rel() (localctx IExpr_relContext) {
	localctx = NewExpr_relContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, SyslParserRULE_expr_rel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1329)
		p.Binexpr()
	}
	p.SetState(1335)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1330)
				p.E_compare_ops()
			}
			{
				p.SetState(1331)
				p.Binexpr()
			}

		}
		p.SetState(1337)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitandContext is an interface to support dynamic dispatch.
type IExpr_bitandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitandContext differentiates from other interfaces.
	IsExpr_bitandContext()
}

type Expr_bitandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitandContext() *Expr_bitandContext {
	var p = new(Expr_bitandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitand
	return p
}

func (*Expr_bitandContext) IsExpr_bitandContext() {}

func NewExpr_bitandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitandContext {
	var p = new(Expr_bitandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitand

	return p
}

func (s *Expr_bitandContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitandContext) AllExpr_rel() []IExpr_relContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_relContext)(nil)).Elem())
	var tst = make([]IExpr_relContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_relContext)
		}
	}

	return tst
}

func (s *Expr_bitandContext) Expr_rel(i int) IExpr_relContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_relContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_relContext)
}

func (s *Expr_bitandContext) AllE_AMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_AMP)
}

func (s *Expr_bitandContext) E_AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_AMP, i)
}

func (s *Expr_bitandContext) AllE_AND() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_AND)
}

func (s *Expr_bitandContext) E_AND(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_AND, i)
}

func (s *Expr_bitandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitand(s)
	}
}

func (s *Expr_bitandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitand(s)
	}
}

func (p *SyslParser) Expr_bitand() (localctx IExpr_bitandContext) {
	localctx = NewExpr_bitandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, SyslParserRULE_expr_bitand)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1338)
		p.Expr_rel()
	}
	p.SetState(1343)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1339)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SyslParserE_AMP || _la == SyslParserE_AND) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
			{
				p.SetState(1340)
				p.Expr_rel()
			}

		}
		p.SetState(1345)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitxorContext is an interface to support dynamic dispatch.
type IExpr_bitxorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitxorContext differentiates from other interfaces.
	IsExpr_bitxorContext()
}

type Expr_bitxorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitxorContext() *Expr_bitxorContext {
	var p = new(Expr_bitxorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitxor
	return p
}

func (*Expr_bitxorContext) IsExpr_bitxorContext() {}

func NewExpr_bitxorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitxorContext {
	var p = new(Expr_bitxorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitxor

	return p
}

func (s *Expr_bitxorContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitxorContext) AllExpr_bitand() []IExpr_bitandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitandContext)(nil)).Elem())
	var tst = make([]IExpr_bitandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitandContext)
		}
	}

	return tst
}

func (s *Expr_bitxorContext) Expr_bitand(i int) IExpr_bitandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitandContext)
}

func (s *Expr_bitxorContext) AllE_XOR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_XOR)
}

func (s *Expr_bitxorContext) E_XOR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_XOR, i)
}

func (s *Expr_bitxorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitxorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitxorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitxor(s)
	}
}

func (s *Expr_bitxorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitxor(s)
	}
}

func (p *SyslParser) Expr_bitxor() (localctx IExpr_bitxorContext) {
	localctx = NewExpr_bitxorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, SyslParserRULE_expr_bitxor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1346)
		p.Expr_bitand()
	}
	p.SetState(1351)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1347)
				p.Match(SyslParserE_XOR)
			}
			{
				p.SetState(1348)
				p.Expr_bitand()
			}

		}
		p.SetState(1353)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_bitorContext is an interface to support dynamic dispatch.
type IExpr_bitorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_bitorContext differentiates from other interfaces.
	IsExpr_bitorContext()
}

type Expr_bitorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_bitorContext() *Expr_bitorContext {
	var p = new(Expr_bitorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_bitor
	return p
}

func (*Expr_bitorContext) IsExpr_bitorContext() {}

func NewExpr_bitorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_bitorContext {
	var p = new(Expr_bitorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_bitor

	return p
}

func (s *Expr_bitorContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_bitorContext) AllExpr_bitxor() []IExpr_bitxorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitxorContext)(nil)).Elem())
	var tst = make([]IExpr_bitxorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitxorContext)
		}
	}

	return tst
}

func (s *Expr_bitorContext) Expr_bitxor(i int) IExpr_bitxorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitxorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitxorContext)
}

func (s *Expr_bitorContext) AllE_BITOR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_BITOR)
}

func (s *Expr_bitorContext) E_BITOR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_BITOR, i)
}

func (s *Expr_bitorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_bitorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_bitorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_bitor(s)
	}
}

func (s *Expr_bitorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_bitor(s)
	}
}

func (p *SyslParser) Expr_bitor() (localctx IExpr_bitorContext) {
	localctx = NewExpr_bitorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, SyslParserRULE_expr_bitor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1354)
		p.Expr_bitxor()
	}
	p.SetState(1359)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1355)
				p.Match(SyslParserE_BITOR)
			}
			{
				p.SetState(1356)
				p.Expr_bitxor()
			}

		}
		p.SetState(1361)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_andContext is an interface to support dynamic dispatch.
type IExpr_andContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_andContext differentiates from other interfaces.
	IsExpr_andContext()
}

type Expr_andContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_andContext() *Expr_andContext {
	var p = new(Expr_andContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_and
	return p
}

func (*Expr_andContext) IsExpr_andContext() {}

func NewExpr_andContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_andContext {
	var p = new(Expr_andContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_and

	return p
}

func (s *Expr_andContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_andContext) AllExpr_bitor() []IExpr_bitorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_bitorContext)(nil)).Elem())
	var tst = make([]IExpr_bitorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_bitorContext)
		}
	}

	return tst
}

func (s *Expr_andContext) Expr_bitor(i int) IExpr_bitorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_bitorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_bitorContext)
}

func (s *Expr_andContext) AllE_DOUBLE_AMP() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_DOUBLE_AMP)
}

func (s *Expr_andContext) E_DOUBLE_AMP(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_AMP, i)
}

func (s *Expr_andContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_andContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_andContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_and(s)
	}
}

func (s *Expr_andContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_and(s)
	}
}

func (p *SyslParser) Expr_and() (localctx IExpr_andContext) {
	localctx = NewExpr_andContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, SyslParserRULE_expr_and)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1362)
		p.Expr_bitor()
	}
	p.SetState(1367)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1363)
				p.Match(SyslParserE_DOUBLE_AMP)
			}
			{
				p.SetState(1364)
				p.Expr_bitor()
			}

		}
		p.SetState(1369)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_orContext is an interface to support dynamic dispatch.
type IExpr_orContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_orContext differentiates from other interfaces.
	IsExpr_orContext()
}

type Expr_orContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_orContext() *Expr_orContext {
	var p = new(Expr_orContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_or
	return p
}

func (*Expr_orContext) IsExpr_orContext() {}

func NewExpr_orContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_orContext {
	var p = new(Expr_orContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_or

	return p
}

func (s *Expr_orContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_orContext) AllExpr_and() []IExpr_andContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_andContext)(nil)).Elem())
	var tst = make([]IExpr_andContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_andContext)
		}
	}

	return tst
}

func (s *Expr_orContext) Expr_and(i int) IExpr_andContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_andContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_andContext)
}

func (s *Expr_orContext) AllE_LOGIC_OR() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_LOGIC_OR)
}

func (s *Expr_orContext) E_LOGIC_OR(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_LOGIC_OR, i)
}

func (s *Expr_orContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_orContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_orContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_or(s)
	}
}

func (s *Expr_orContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_or(s)
	}
}

func (p *SyslParser) Expr_or() (localctx IExpr_orContext) {
	localctx = NewExpr_orContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, SyslParserRULE_expr_or)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1370)
		p.Expr_and()
	}
	p.SetState(1375)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1371)
				p.Match(SyslParserE_LOGIC_OR)
			}
			{
				p.SetState(1372)
				p.Expr_and()
			}

		}
		p.SetState(1377)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_but_notContext is an interface to support dynamic dispatch.
type IExpr_but_notContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_but_notContext differentiates from other interfaces.
	IsExpr_but_notContext()
}

type Expr_but_notContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_but_notContext() *Expr_but_notContext {
	var p = new(Expr_but_notContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_but_not
	return p
}

func (*Expr_but_notContext) IsExpr_but_notContext() {}

func NewExpr_but_notContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_but_notContext {
	var p = new(Expr_but_notContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_but_not

	return p
}

func (s *Expr_but_notContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_but_notContext) AllExpr_or() []IExpr_orContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_orContext)(nil)).Elem())
	var tst = make([]IExpr_orContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_orContext)
		}
	}

	return tst
}

func (s *Expr_but_notContext) Expr_or(i int) IExpr_orContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_orContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_orContext)
}

func (s *Expr_but_notContext) AllE_BUTNOT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_BUTNOT)
}

func (s *Expr_but_notContext) E_BUTNOT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_BUTNOT, i)
}

func (s *Expr_but_notContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_but_notContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_but_notContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_but_not(s)
	}
}

func (s *Expr_but_notContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_but_not(s)
	}
}

func (p *SyslParser) Expr_but_not() (localctx IExpr_but_notContext) {
	localctx = NewExpr_but_notContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, SyslParserRULE_expr_but_not)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1378)
		p.Expr_or()
	}
	p.SetState(1383)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1379)
				p.Match(SyslParserE_BUTNOT)
			}
			{
				p.SetState(1380)
				p.Expr_or()
			}

		}
		p.SetState(1385)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())
	}

	return localctx
}

// IExpr_coalesceContext is an interface to support dynamic dispatch.
type IExpr_coalesceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_coalesceContext differentiates from other interfaces.
	IsExpr_coalesceContext()
}

type Expr_coalesceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_coalesceContext() *Expr_coalesceContext {
	var p = new(Expr_coalesceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_coalesce
	return p
}

func (*Expr_coalesceContext) IsExpr_coalesceContext() {}

func NewExpr_coalesceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_coalesceContext {
	var p = new(Expr_coalesceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_coalesce

	return p
}

func (s *Expr_coalesceContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_coalesceContext) AllExpr_but_not() []IExpr_but_notContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_but_notContext)(nil)).Elem())
	var tst = make([]IExpr_but_notContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_but_notContext)
		}
	}

	return tst
}

func (s *Expr_coalesceContext) Expr_but_not(i int) IExpr_but_notContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_but_notContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_but_notContext)
}

func (s *Expr_coalesceContext) AllE_COALESCE() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COALESCE)
}

func (s *Expr_coalesceContext) E_COALESCE(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COALESCE, i)
}

func (s *Expr_coalesceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_coalesceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_coalesceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_coalesce(s)
	}
}

func (s *Expr_coalesceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_coalesce(s)
	}
}

func (p *SyslParser) Expr_coalesce() (localctx IExpr_coalesceContext) {
	localctx = NewExpr_coalesceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, SyslParserRULE_expr_coalesce)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1386)
		p.Expr_but_not()
	}
	p.SetState(1391)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1387)
				p.Match(SyslParserE_COALESCE)
			}
			{
				p.SetState(1388)
				p.Expr_but_not()
			}

		}
		p.SetState(1393)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext())
	}

	return localctx
}

// IIf_one_linerContext is an interface to support dynamic dispatch.
type IIf_one_linerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_one_linerContext differentiates from other interfaces.
	IsIf_one_linerContext()
}

type If_one_linerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_one_linerContext() *If_one_linerContext {
	var p = new(If_one_linerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_one_liner
	return p
}

func (*If_one_linerContext) IsIf_one_linerContext() {}

func NewIf_one_linerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_one_linerContext {
	var p = new(If_one_linerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_one_liner

	return p
}

func (s *If_one_linerContext) GetParser() antlr.Parser { return s.parser }

func (s *If_one_linerContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *If_one_linerContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *If_one_linerContext) E_THEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_THEN, 0)
}

func (s *If_one_linerContext) E_ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ELSE, 0)
}

func (s *If_one_linerContext) E_QN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_QN, 0)
}

func (s *If_one_linerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_one_linerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_one_linerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_one_liner(s)
	}
}

func (s *If_one_linerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_one_liner(s)
	}
}

func (p *SyslParser) If_one_liner() (localctx IIf_one_linerContext) {
	localctx = NewIf_one_linerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, SyslParserRULE_if_one_liner)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1394)
		p.Expr()
	}
	p.SetState(1396)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_QN {
		{
			p.SetState(1395)
			p.Match(SyslParserE_QN)
		}

	}
	{
		p.SetState(1398)
		p.Match(SyslParserE_THEN)
	}
	{
		p.SetState(1399)
		p.Expr()
	}
	{
		p.SetState(1400)
		p.Match(SyslParserE_ELSE)
	}
	{
		p.SetState(1401)
		p.Expr()
	}

	return localctx
}

// IElse_block_stmtContext is an interface to support dynamic dispatch.
type IElse_block_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsElse_block_stmtContext differentiates from other interfaces.
	IsElse_block_stmtContext()
}

type Else_block_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
	_expr  IExprContext
}

func NewEmptyElse_block_stmtContext() *Else_block_stmtContext {
	var p = new(Else_block_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_else_block_stmt
	return p
}

func (*Else_block_stmtContext) IsElse_block_stmtContext() {}

func NewElse_block_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_block_stmtContext {
	var p = new(Else_block_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_else_block_stmt

	return p
}

func (s *Else_block_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_block_stmtContext) Get_expr() IExprContext { return s._expr }

func (s *Else_block_stmtContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Else_block_stmtContext) GetNested() bool { return s.nested }

func (s *Else_block_stmtContext) SetNested(v bool) { s.nested = v }

func (s *Else_block_stmtContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Else_block_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_block_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_block_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterElse_block_stmt(s)
	}
}

func (s *Else_block_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitElse_block_stmt(s)
	}
}

func (p *SyslParser) Else_block_stmt() (localctx IElse_block_stmtContext) {
	localctx = NewElse_block_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, SyslParserRULE_else_block_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1403)

		var _x = p.Expr()

		localctx.(*Else_block_stmtContext)._expr = _x
	}
	localctx.(*Else_block_stmtContext).SetNested(localctx.(*Else_block_stmtContext).Get_expr().GetNested())

	return localctx
}

// IControl_itemContext is an interface to support dynamic dispatch.
type IControl_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsControl_itemContext differentiates from other interfaces.
	IsControl_itemContext()
}

type Control_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyControl_itemContext() *Control_itemContext {
	var p = new(Control_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_control_item
	return p
}

func (*Control_itemContext) IsControl_itemContext() {}

func NewControl_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Control_itemContext {
	var p = new(Control_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_control_item

	return p
}

func (s *Control_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Control_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Control_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Control_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Control_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterControl_item(s)
	}
}

func (s *Control_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitControl_item(s)
	}
}

func (p *SyslParser) Control_item() (localctx IControl_itemContext) {
	localctx = NewControl_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, SyslParserRULE_control_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1406)
		p.Expr()
	}

	return localctx
}

// IIf_controlsContext is an interface to support dynamic dispatch.
type IIf_controlsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_controlsContext differentiates from other interfaces.
	IsIf_controlsContext()
}

type If_controlsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_controlsContext() *If_controlsContext {
	var p = new(If_controlsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_controls
	return p
}

func (*If_controlsContext) IsIf_controlsContext() {}

func NewIf_controlsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_controlsContext {
	var p = new(If_controlsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_controls

	return p
}

func (s *If_controlsContext) GetParser() antlr.Parser { return s.parser }

func (s *If_controlsContext) AllControl_item() []IControl_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IControl_itemContext)(nil)).Elem())
	var tst = make([]IControl_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IControl_itemContext)
		}
	}

	return tst
}

func (s *If_controlsContext) Control_item(i int) IControl_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControl_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IControl_itemContext)
}

func (s *If_controlsContext) AllE_COMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_COMMA)
}

func (s *If_controlsContext) E_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_COMMA, i)
}

func (s *If_controlsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_controlsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_controlsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_controls(s)
	}
}

func (s *If_controlsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_controls(s)
	}
}

func (p *SyslParser) If_controls() (localctx IIf_controlsContext) {
	localctx = NewIf_controlsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, SyslParserRULE_if_controls)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1408)
		p.Control_item()
	}
	p.SetState(1413)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserE_COMMA {
		{
			p.SetState(1409)
			p.Match(SyslParserE_COMMA)
		}
		{
			p.SetState(1410)
			p.Control_item()
		}

		p.SetState(1415)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICond_blockContext is an interface to support dynamic dispatch.
type ICond_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_else_block_stmt returns the _else_block_stmt rule contexts.
	Get_else_block_stmt() IElse_block_stmtContext

	// Set_else_block_stmt sets the _else_block_stmt rule contexts.
	Set_else_block_stmt(IElse_block_stmtContext)

	// IsCond_blockContext differentiates from other interfaces.
	IsCond_blockContext()
}

type Cond_blockContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	_else_block_stmt IElse_block_stmtContext
}

func NewEmptyCond_blockContext() *Cond_blockContext {
	var p = new(Cond_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_cond_block
	return p
}

func (*Cond_blockContext) IsCond_blockContext() {}

func NewCond_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cond_blockContext {
	var p = new(Cond_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_cond_block

	return p
}

func (s *Cond_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Cond_blockContext) Get_else_block_stmt() IElse_block_stmtContext { return s._else_block_stmt }

func (s *Cond_blockContext) Set_else_block_stmt(v IElse_block_stmtContext) { s._else_block_stmt = v }

func (s *Cond_blockContext) If_controls() IIf_controlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_controlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_controlsContext)
}

func (s *Cond_blockContext) E_EQ_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EQ_RIGHT, 0)
}

func (s *Cond_blockContext) Else_block_stmt() IElse_block_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_block_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_block_stmtContext)
}

func (s *Cond_blockContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Cond_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cond_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cond_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterCond_block(s)
	}
}

func (s *Cond_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitCond_block(s)
	}
}

func (p *SyslParser) Cond_block() (localctx ICond_blockContext) {
	localctx = NewCond_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, SyslParserRULE_cond_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1416)
		p.If_controls()
	}
	{
		p.SetState(1417)
		p.Match(SyslParserE_EQ_RIGHT)
	}
	{
		p.SetState(1418)

		var _x = p.Else_block_stmt()

		localctx.(*Cond_blockContext)._else_block_stmt = _x
	}
	p.SetState(1421)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1419)

		if !(localctx.(*Cond_blockContext).Get_else_block_stmt().GetNested() == true) {
			panic(antlr.NewFailedPredicateException(p, "$else_block_stmt.nested == true", ""))
		}

	case 2:
		{
			p.SetState(1420)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IFinal_elseContext is an interface to support dynamic dispatch.
type IFinal_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// IsFinal_elseContext differentiates from other interfaces.
	IsFinal_elseContext()
}

type Final_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	_expr  IExprContext
}

func NewEmptyFinal_elseContext() *Final_elseContext {
	var p = new(Final_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_final_else
	return p
}

func (*Final_elseContext) IsFinal_elseContext() {}

func NewFinal_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Final_elseContext {
	var p = new(Final_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_final_else

	return p
}

func (s *Final_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *Final_elseContext) Get_expr() IExprContext { return s._expr }

func (s *Final_elseContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Final_elseContext) E_ELSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ELSE, 0)
}

func (s *Final_elseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Final_elseContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Final_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Final_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Final_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterFinal_else(s)
	}
}

func (s *Final_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitFinal_else(s)
	}
}

func (p *SyslParser) Final_else() (localctx IFinal_elseContext) {
	localctx = NewFinal_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, SyslParserRULE_final_else)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1423)
		p.Match(SyslParserE_ELSE)
	}
	{
		p.SetState(1424)

		var _x = p.Expr()

		localctx.(*Final_elseContext)._expr = _x
	}
	p.SetState(1427)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1425)

		if !(localctx.(*Final_elseContext).Get_expr().GetNested() == true) {
			panic(antlr.NewFailedPredicateException(p, "$expr.nested == true", ""))
		}

	case 2:
		{
			p.SetState(1426)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IIfvarContext is an interface to support dynamic dispatch.
type IIfvarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfvarContext differentiates from other interfaces.
	IsIfvarContext()
}

type IfvarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfvarContext() *IfvarContext {
	var p = new(IfvarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_ifvar
	return p
}

func (*IfvarContext) IsIfvarContext() {}

func NewIfvarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfvarContext {
	var p = new(IfvarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_ifvar

	return p
}

func (s *IfvarContext) GetParser() antlr.Parser { return s.parser }

func (s *IfvarContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfvarContext) E_DOUBLE_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOUBLE_EQ, 0)
}

func (s *IfvarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfvarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfvarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIfvar(s)
	}
}

func (s *IfvarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIfvar(s)
	}
}

func (p *SyslParser) Ifvar() (localctx IIfvarContext) {
	localctx = NewIfvarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, SyslParserRULE_ifvar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1429)
		p.Expr()
	}
	{
		p.SetState(1430)
		p.Match(SyslParserE_DOUBLE_EQ)
	}

	return localctx
}

// IIf_multiple_linesContext is an interface to support dynamic dispatch.
type IIf_multiple_linesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_multiple_linesContext differentiates from other interfaces.
	IsIf_multiple_linesContext()
}

type If_multiple_linesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_multiple_linesContext() *If_multiple_linesContext {
	var p = new(If_multiple_linesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_if_multiple_lines
	return p
}

func (*If_multiple_linesContext) IsIf_multiple_linesContext() {}

func NewIf_multiple_linesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_multiple_linesContext {
	var p = new(If_multiple_linesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_if_multiple_lines

	return p
}

func (s *If_multiple_linesContext) GetParser() antlr.Parser { return s.parser }

func (s *If_multiple_linesContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *If_multiple_linesContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *If_multiple_linesContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *If_multiple_linesContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *If_multiple_linesContext) Ifvar() IIfvarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfvarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfvarContext)
}

func (s *If_multiple_linesContext) AllCond_block() []ICond_blockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICond_blockContext)(nil)).Elem())
	var tst = make([]ICond_blockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICond_blockContext)
		}
	}

	return tst
}

func (s *If_multiple_linesContext) Cond_block(i int) ICond_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICond_blockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICond_blockContext)
}

func (s *If_multiple_linesContext) Final_else() IFinal_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinal_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinal_elseContext)
}

func (s *If_multiple_linesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_multiple_linesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_multiple_linesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterIf_multiple_lines(s)
	}
}

func (s *If_multiple_linesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitIf_multiple_lines(s)
	}
}

func (p *SyslParser) If_multiple_lines() (localctx IIf_multiple_linesContext) {
	localctx = NewIf_multiple_linesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, SyslParserRULE_if_multiple_lines)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1433)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserNativeDataTypes || (((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(SyslParserE_WHATEVER-73))|(1<<(SyslParserE_ARROW_RIGHT-73))|(1<<(SyslParserE_SQ_OPEN-73))|(1<<(SyslParserE_EMPTY_TUPLE-73))|(1<<(SyslParserE_CURLY_OPEN-73))|(1<<(SyslParserE_NULLSAFE_DOT-73))|(1<<(SyslParserE_OPEN_PAREN-73))|(1<<(SyslParserE_PLUS-73))|(1<<(SyslParserE_MINUS-73))|(1<<(SyslParserE_QN-73))|(1<<(SyslParserE_TILDE-73))|(1<<(SyslParserE_NOT-73)))) != 0) || (((_la-111)&-(0x1f+1)) == 0 && ((1<<uint((_la-111)))&((1<<(SyslParserE_IF-111))|(1<<(SyslParserE_TRUE-111))|(1<<(SyslParserE_FALSE-111))|(1<<(SyslParserE_NULL-111))|(1<<(SyslParserE_FUNC-111))|(1<<(SyslParserE_STRING_DBL-111))|(1<<(SyslParserE_STRING_SINGLE-111))|(1<<(SyslParserE_DECIMAL-111))|(1<<(SyslParserE_DIGITS-111))|(1<<(SyslParserE_Name-111))|(1<<(SyslParserE_DOT-111)))) != 0) {
		{
			p.SetState(1432)
			p.Ifvar()
		}

	}
	{
		p.SetState(1435)
		p.Match(SyslParserE_COLON)
	}
	{
		p.SetState(1436)
		p.Match(SyslParserE_NL)
	}
	{
		p.SetState(1437)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1439)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserNativeDataTypes || (((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(SyslParserE_WHATEVER-73))|(1<<(SyslParserE_ARROW_RIGHT-73))|(1<<(SyslParserE_SQ_OPEN-73))|(1<<(SyslParserE_EMPTY_TUPLE-73))|(1<<(SyslParserE_CURLY_OPEN-73))|(1<<(SyslParserE_NULLSAFE_DOT-73))|(1<<(SyslParserE_OPEN_PAREN-73))|(1<<(SyslParserE_PLUS-73))|(1<<(SyslParserE_MINUS-73))|(1<<(SyslParserE_QN-73))|(1<<(SyslParserE_TILDE-73))|(1<<(SyslParserE_NOT-73)))) != 0) || (((_la-111)&-(0x1f+1)) == 0 && ((1<<uint((_la-111)))&((1<<(SyslParserE_IF-111))|(1<<(SyslParserE_TRUE-111))|(1<<(SyslParserE_FALSE-111))|(1<<(SyslParserE_NULL-111))|(1<<(SyslParserE_FUNC-111))|(1<<(SyslParserE_STRING_DBL-111))|(1<<(SyslParserE_STRING_SINGLE-111))|(1<<(SyslParserE_DECIMAL-111))|(1<<(SyslParserE_DIGITS-111))|(1<<(SyslParserE_Name-111))|(1<<(SyslParserE_DOT-111)))) != 0) {
		{
			p.SetState(1438)
			p.Cond_block()
		}

		p.SetState(1441)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1444)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ELSE {
		{
			p.SetState(1443)
			p.Final_else()
		}

	}
	{
		p.SetState(1446)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IExpr_if_elseContext is an interface to support dynamic dispatch.
type IExpr_if_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_if_elseContext differentiates from other interfaces.
	IsExpr_if_elseContext()
}

type Expr_if_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
}

func NewEmptyExpr_if_elseContext() *Expr_if_elseContext {
	var p = new(Expr_if_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_if_else
	return p
}

func (*Expr_if_elseContext) IsExpr_if_elseContext() {}

func NewExpr_if_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_if_elseContext {
	var p = new(Expr_if_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_if_else

	return p
}

func (s *Expr_if_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_if_elseContext) GetNested() bool { return s.nested }

func (s *Expr_if_elseContext) SetNested(v bool) { s.nested = v }

func (s *Expr_if_elseContext) E_IF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_IF, 0)
}

func (s *Expr_if_elseContext) If_one_liner() IIf_one_linerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_one_linerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_one_linerContext)
}

func (s *Expr_if_elseContext) If_multiple_lines() IIf_multiple_linesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_multiple_linesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_multiple_linesContext)
}

func (s *Expr_if_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_if_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_if_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_if_else(s)
	}
}

func (s *Expr_if_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_if_else(s)
	}
}

func (p *SyslParser) Expr_if_else() (localctx IExpr_if_elseContext) {
	localctx = NewExpr_if_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, SyslParserRULE_expr_if_else)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1448)
		p.Match(SyslParserE_IF)
	}
	p.SetState(1453)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1449)
			p.If_one_liner()
		}

	case 2:
		{
			p.SetState(1450)
			p.If_multiple_lines()
		}
		localctx.(*Expr_if_elseContext).SetNested(true)

	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_if_else returns the _expr_if_else rule contexts.
	Get_expr_if_else() IExpr_if_elseContext

	// Set_expr_if_else sets the _expr_if_else rule contexts.
	Set_expr_if_else(IExpr_if_elseContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser        antlr.Parser
	nested        bool
	_expr_if_else IExpr_if_elseContext
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) Get_expr_if_else() IExpr_if_elseContext { return s._expr_if_else }

func (s *ExprContext) Set_expr_if_else(v IExpr_if_elseContext) { s._expr_if_else = v }

func (s *ExprContext) GetNested() bool { return s.nested }

func (s *ExprContext) SetNested(v bool) { s.nested = v }

func (s *ExprContext) Expr_if_else() IExpr_if_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_if_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_if_elseContext)
}

func (s *ExprContext) Expr_coalesce() IExpr_coalesceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_coalesceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_coalesceContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *SyslParser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, SyslParserRULE_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1459)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_IF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1455)

			var _x = p.Expr_if_else()

			localctx.(*ExprContext)._expr_if_else = _x
		}
		localctx.(*ExprContext).SetNested(localctx.(*ExprContext).Get_expr_if_else().GetNested())

	case SyslParserNativeDataTypes, SyslParserE_WHATEVER, SyslParserE_ARROW_RIGHT, SyslParserE_SQ_OPEN, SyslParserE_EMPTY_TUPLE, SyslParserE_CURLY_OPEN, SyslParserE_NULLSAFE_DOT, SyslParserE_OPEN_PAREN, SyslParserE_PLUS, SyslParserE_MINUS, SyslParserE_QN, SyslParserE_TILDE, SyslParserE_NOT, SyslParserE_TRUE, SyslParserE_FALSE, SyslParserE_NULL, SyslParserE_FUNC, SyslParserE_STRING_DBL, SyslParserE_STRING_SINGLE, SyslParserE_DECIMAL, SyslParserE_DIGITS, SyslParserE_Name, SyslParserE_DOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1458)
			p.Expr_coalesce()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpr_assignContext is an interface to support dynamic dispatch.
type IExpr_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_assignContext differentiates from other interfaces.
	IsExpr_assignContext()
}

type Expr_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	nested bool
	_expr  IExprContext
}

func NewEmptyExpr_assignContext() *Expr_assignContext {
	var p = new(Expr_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_assign
	return p
}

func (*Expr_assignContext) IsExpr_assignContext() {}

func NewExpr_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_assignContext {
	var p = new(Expr_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_assign

	return p
}

func (s *Expr_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_assignContext) Get_expr() IExprContext { return s._expr }

func (s *Expr_assignContext) Set_expr(v IExprContext) { s._expr = v }

func (s *Expr_assignContext) GetNested() bool { return s.nested }

func (s *Expr_assignContext) SetNested(v bool) { s.nested = v }

func (s *Expr_assignContext) E_EQ() antlr.TerminalNode {
	return s.GetToken(SyslParserE_EQ, 0)
}

func (s *Expr_assignContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_assignContext) Transform() ITransformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransformContext)
}

func (s *Expr_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_assign(s)
	}
}

func (s *Expr_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_assign(s)
	}
}

func (p *SyslParser) Expr_assign() (localctx IExpr_assignContext) {
	localctx = NewExpr_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, SyslParserRULE_expr_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1461)
		p.Match(SyslParserE_EQ)
	}
	p.SetState(1468)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1462)

			var _x = p.Expr()

			localctx.(*Expr_assignContext)._expr = _x
		}
		localctx.(*Expr_assignContext).SetNested(localctx.(*Expr_assignContext).Get_expr().GetNested())

	case 2:
		{
			p.SetState(1465)
			p.Transform()
		}
		localctx.(*Expr_assignContext).SetNested(true)

	}

	return localctx
}

// IExpr_simple_assignContext is an interface to support dynamic dispatch.
type IExpr_simple_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_simple_assignContext differentiates from other interfaces.
	IsExpr_simple_assignContext()
}

type Expr_simple_assignContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_simple_assignContext() *Expr_simple_assignContext {
	var p = new(Expr_simple_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_simple_assign
	return p
}

func (*Expr_simple_assignContext) IsExpr_simple_assignContext() {}

func NewExpr_simple_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_simple_assignContext {
	var p = new(Expr_simple_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_simple_assign

	return p
}

func (s *Expr_simple_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_simple_assignContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_simple_assignContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_simple_assignContext) GetNested() bool { return s.nested }

func (s *Expr_simple_assignContext) SetNested(v bool) { s.nested = v }

func (s *Expr_simple_assignContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_simple_assignContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_simple_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_simple_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_simple_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_simple_assign(s)
	}
}

func (s *Expr_simple_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_simple_assign(s)
	}
}

func (p *SyslParser) Expr_simple_assign() (localctx IExpr_simple_assignContext) {
	localctx = NewExpr_simple_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, SyslParserRULE_expr_simple_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1470)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1471)

		var _x = p.Expr_assign()

		localctx.(*Expr_simple_assignContext)._expr_assign = _x
	}
	localctx.(*Expr_simple_assignContext).SetNested(localctx.(*Expr_simple_assignContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_let_statementContext is an interface to support dynamic dispatch.
type IExpr_let_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_let_statementContext differentiates from other interfaces.
	IsExpr_let_statementContext()
}

type Expr_let_statementContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_let_statementContext() *Expr_let_statementContext {
	var p = new(Expr_let_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_let_statement
	return p
}

func (*Expr_let_statementContext) IsExpr_let_statementContext() {}

func NewExpr_let_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_let_statementContext {
	var p = new(Expr_let_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_let_statement

	return p
}

func (s *Expr_let_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_let_statementContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_let_statementContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_let_statementContext) GetNested() bool { return s.nested }

func (s *Expr_let_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_let_statementContext) E_LET() antlr.TerminalNode {
	return s.GetToken(SyslParserE_LET, 0)
}

func (s *Expr_let_statementContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_let_statementContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_let_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_let_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_let_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_let_statement(s)
	}
}

func (s *Expr_let_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_let_statement(s)
	}
}

func (p *SyslParser) Expr_let_statement() (localctx IExpr_let_statementContext) {
	localctx = NewExpr_let_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, SyslParserRULE_expr_let_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1474)
		p.Match(SyslParserE_LET)
	}
	{
		p.SetState(1475)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1476)

		var _x = p.Expr_assign()

		localctx.(*Expr_let_statementContext)._expr_assign = _x
	}
	localctx.(*Expr_let_statementContext).SetNested(localctx.(*Expr_let_statementContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_table_of_statementContext is an interface to support dynamic dispatch.
type IExpr_table_of_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_assign returns the _expr_assign rule contexts.
	Get_expr_assign() IExpr_assignContext

	// Set_expr_assign sets the _expr_assign rule contexts.
	Set_expr_assign(IExpr_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_table_of_statementContext differentiates from other interfaces.
	IsExpr_table_of_statementContext()
}

type Expr_table_of_statementContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	nested       bool
	_expr_assign IExpr_assignContext
}

func NewEmptyExpr_table_of_statementContext() *Expr_table_of_statementContext {
	var p = new(Expr_table_of_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_table_of_statement
	return p
}

func (*Expr_table_of_statementContext) IsExpr_table_of_statementContext() {}

func NewExpr_table_of_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_table_of_statementContext {
	var p = new(Expr_table_of_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_table_of_statement

	return p
}

func (s *Expr_table_of_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_table_of_statementContext) Get_expr_assign() IExpr_assignContext { return s._expr_assign }

func (s *Expr_table_of_statementContext) Set_expr_assign(v IExpr_assignContext) { s._expr_assign = v }

func (s *Expr_table_of_statementContext) GetNested() bool { return s.nested }

func (s *Expr_table_of_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_table_of_statementContext) E_TABLE_OF() antlr.TerminalNode {
	return s.GetToken(SyslParserE_TABLE_OF, 0)
}

func (s *Expr_table_of_statementContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Expr_table_of_statementContext) Expr_assign() IExpr_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_assignContext)
}

func (s *Expr_table_of_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_table_of_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_table_of_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_table_of_statement(s)
	}
}

func (s *Expr_table_of_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_table_of_statement(s)
	}
}

func (p *SyslParser) Expr_table_of_statement() (localctx IExpr_table_of_statementContext) {
	localctx = NewExpr_table_of_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, SyslParserRULE_expr_table_of_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1479)
		p.Match(SyslParserE_TABLE_OF)
	}
	{
		p.SetState(1480)
		p.Match(SyslParserE_Name)
	}
	{
		p.SetState(1481)

		var _x = p.Expr_assign()

		localctx.(*Expr_table_of_statementContext)._expr_assign = _x
	}
	localctx.(*Expr_table_of_statementContext).SetNested(localctx.(*Expr_table_of_statementContext).Get_expr_assign().GetNested())

	return localctx
}

// IExpr_dot_assignContext is an interface to support dynamic dispatch.
type IExpr_dot_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_dot_assignContext differentiates from other interfaces.
	IsExpr_dot_assignContext()
}

type Expr_dot_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dot_assignContext() *Expr_dot_assignContext {
	var p = new(Expr_dot_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_dot_assign
	return p
}

func (*Expr_dot_assignContext) IsExpr_dot_assignContext() {}

func NewExpr_dot_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dot_assignContext {
	var p = new(Expr_dot_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_dot_assign

	return p
}

func (s *Expr_dot_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dot_assignContext) E_DOT_NAME_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT_NAME_NL, 0)
}

func (s *Expr_dot_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dot_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_dot_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_dot_assign(s)
	}
}

func (s *Expr_dot_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_dot_assign(s)
	}
}

func (p *SyslParser) Expr_dot_assign() (localctx IExpr_dot_assignContext) {
	localctx = NewExpr_dot_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, SyslParserRULE_expr_dot_assign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1484)
		p.Match(SyslParserE_DOT_NAME_NL)
	}

	return localctx
}

// IExpr_statement_no_nlContext is an interface to support dynamic dispatch.
type IExpr_statement_no_nlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_statement_no_nlContext differentiates from other interfaces.
	IsExpr_statement_no_nlContext()
}

type Expr_statement_no_nlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_statement_no_nlContext() *Expr_statement_no_nlContext {
	var p = new(Expr_statement_no_nlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_statement_no_nl
	return p
}

func (*Expr_statement_no_nlContext) IsExpr_statement_no_nlContext() {}

func NewExpr_statement_no_nlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_statement_no_nlContext {
	var p = new(Expr_statement_no_nlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_statement_no_nl

	return p
}

func (s *Expr_statement_no_nlContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_statement_no_nlContext) Expr_dot_assign() IExpr_dot_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_dot_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_dot_assignContext)
}

func (s *Expr_statement_no_nlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_statement_no_nlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_statement_no_nlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_statement_no_nl(s)
	}
}

func (s *Expr_statement_no_nlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_statement_no_nl(s)
	}
}

func (p *SyslParser) Expr_statement_no_nl() (localctx IExpr_statement_no_nlContext) {
	localctx = NewExpr_statement_no_nlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, SyslParserRULE_expr_statement_no_nl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1486)
		p.Expr_dot_assign()
	}

	return localctx
}

// IExpr_statementContext is an interface to support dynamic dispatch.
type IExpr_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr_let_statement returns the _expr_let_statement rule contexts.
	Get_expr_let_statement() IExpr_let_statementContext

	// Get_expr_table_of_statement returns the _expr_table_of_statement rule contexts.
	Get_expr_table_of_statement() IExpr_table_of_statementContext

	// Get_expr_simple_assign returns the _expr_simple_assign rule contexts.
	Get_expr_simple_assign() IExpr_simple_assignContext

	// Set_expr_let_statement sets the _expr_let_statement rule contexts.
	Set_expr_let_statement(IExpr_let_statementContext)

	// Set_expr_table_of_statement sets the _expr_table_of_statement rule contexts.
	Set_expr_table_of_statement(IExpr_table_of_statementContext)

	// Set_expr_simple_assign sets the _expr_simple_assign rule contexts.
	Set_expr_simple_assign(IExpr_simple_assignContext)

	// GetNested returns the nested attribute.
	GetNested() bool

	// SetNested sets the nested attribute.
	SetNested(bool)

	// IsExpr_statementContext differentiates from other interfaces.
	IsExpr_statementContext()
}

type Expr_statementContext struct {
	*antlr.BaseParserRuleContext
	parser                   antlr.Parser
	nested                   bool
	_expr_let_statement      IExpr_let_statementContext
	_expr_table_of_statement IExpr_table_of_statementContext
	_expr_simple_assign      IExpr_simple_assignContext
}

func NewEmptyExpr_statementContext() *Expr_statementContext {
	var p = new(Expr_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_statement
	return p
}

func (*Expr_statementContext) IsExpr_statementContext() {}

func NewExpr_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_statementContext {
	var p = new(Expr_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_statement

	return p
}

func (s *Expr_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_statementContext) Get_expr_let_statement() IExpr_let_statementContext {
	return s._expr_let_statement
}

func (s *Expr_statementContext) Get_expr_table_of_statement() IExpr_table_of_statementContext {
	return s._expr_table_of_statement
}

func (s *Expr_statementContext) Get_expr_simple_assign() IExpr_simple_assignContext {
	return s._expr_simple_assign
}

func (s *Expr_statementContext) Set_expr_let_statement(v IExpr_let_statementContext) {
	s._expr_let_statement = v
}

func (s *Expr_statementContext) Set_expr_table_of_statement(v IExpr_table_of_statementContext) {
	s._expr_table_of_statement = v
}

func (s *Expr_statementContext) Set_expr_simple_assign(v IExpr_simple_assignContext) {
	s._expr_simple_assign = v
}

func (s *Expr_statementContext) GetNested() bool { return s.nested }

func (s *Expr_statementContext) SetNested(v bool) { s.nested = v }

func (s *Expr_statementContext) Expr_let_statement() IExpr_let_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_let_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_let_statementContext)
}

func (s *Expr_statementContext) Expr_table_of_statement() IExpr_table_of_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_table_of_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_table_of_statementContext)
}

func (s *Expr_statementContext) Expr_simple_assign() IExpr_simple_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_simple_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_simple_assignContext)
}

func (s *Expr_statementContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Expr_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_statement(s)
	}
}

func (s *Expr_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_statement(s)
	}
}

func (p *SyslParser) Expr_statement() (localctx IExpr_statementContext) {
	localctx = NewExpr_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, SyslParserRULE_expr_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1497)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserE_LET:
		{
			p.SetState(1488)

			var _x = p.Expr_let_statement()

			localctx.(*Expr_statementContext)._expr_let_statement = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_let_statement().GetNested())

	case SyslParserE_TABLE_OF:
		{
			p.SetState(1491)

			var _x = p.Expr_table_of_statement()

			localctx.(*Expr_statementContext)._expr_table_of_statement = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_table_of_statement().GetNested())

	case SyslParserE_Name:
		{
			p.SetState(1494)

			var _x = p.Expr_simple_assign()

			localctx.(*Expr_statementContext)._expr_simple_assign = _x
		}
		localctx.(*Expr_statementContext).SetNested(localctx.(*Expr_statementContext).Get_expr_simple_assign().GetNested())

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1501)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1499)

		if !(localctx.(*Expr_statementContext).nested == true) {
			panic(antlr.NewFailedPredicateException(p, "$nested == true", ""))
		}

	case 2:
		{
			p.SetState(1500)
			p.Match(SyslParserE_NL)
		}

	}

	return localctx
}

// IExpr_inject_stmtContext is an interface to support dynamic dispatch.
type IExpr_inject_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_inject_stmtContext differentiates from other interfaces.
	IsExpr_inject_stmtContext()
}

type Expr_inject_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_inject_stmtContext() *Expr_inject_stmtContext {
	var p = new(Expr_inject_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_inject_stmt
	return p
}

func (*Expr_inject_stmtContext) IsExpr_inject_stmtContext() {}

func NewExpr_inject_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_inject_stmtContext {
	var p = new(Expr_inject_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_inject_stmt

	return p
}

func (s *Expr_inject_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_inject_stmtContext) Expr_func() IExpr_funcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_funcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Expr_inject_stmtContext) E_DOT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_DOT, 0)
}

func (s *Expr_inject_stmtContext) E_STAR() antlr.TerminalNode {
	return s.GetToken(SyslParserE_STAR, 0)
}

func (s *Expr_inject_stmtContext) E_NL() antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, 0)
}

func (s *Expr_inject_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_inject_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_inject_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_inject_stmt(s)
	}
}

func (s *Expr_inject_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_inject_stmt(s)
	}
}

func (p *SyslParser) Expr_inject_stmt() (localctx IExpr_inject_stmtContext) {
	localctx = NewExpr_inject_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, SyslParserRULE_expr_inject_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1503)
		p.Expr_func()
	}
	{
		p.SetState(1504)
		p.Match(SyslParserE_DOT)
	}
	{
		p.SetState(1505)
		p.Match(SyslParserE_STAR)
	}
	{
		p.SetState(1506)
		p.Match(SyslParserE_NL)
	}

	return localctx
}

// IExpr_stmtContext is an interface to support dynamic dispatch.
type IExpr_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_stmtContext differentiates from other interfaces.
	IsExpr_stmtContext()
}

type Expr_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_stmtContext() *Expr_stmtContext {
	var p = new(Expr_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_stmt
	return p
}

func (*Expr_stmtContext) IsExpr_stmtContext() {}

func NewExpr_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_stmt

	return p
}

func (s *Expr_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_stmtContext) Expr_statement_no_nl() IExpr_statement_no_nlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_statement_no_nlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_statement_no_nlContext)
}

func (s *Expr_stmtContext) Expr_statement() IExpr_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_statementContext)
}

func (s *Expr_stmtContext) Expr_inject_stmt() IExpr_inject_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_inject_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_inject_stmtContext)
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}

func (p *SyslParser) Expr_stmt() (localctx IExpr_stmtContext) {
	localctx = NewExpr_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, SyslParserRULE_expr_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1511)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1508)
			p.Expr_statement_no_nl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1509)
			p.Expr_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1510)
			p.Expr_inject_stmt()
		}

	}

	return localctx
}

// ITransform_return_typeContext is an interface to support dynamic dispatch.
type ITransform_return_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_return_typeContext differentiates from other interfaces.
	IsTransform_return_typeContext()
}

type Transform_return_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_return_typeContext() *Transform_return_typeContext {
	var p = new(Transform_return_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_return_type
	return p
}

func (*Transform_return_typeContext) IsTransform_return_typeContext() {}

func NewTransform_return_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_return_typeContext {
	var p = new(Transform_return_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_return_type

	return p
}

func (s *Transform_return_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_return_typeContext) Set_of() ISet_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_ofContext)
}

func (s *Transform_return_typeContext) Sequence_of() ISequence_ofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_ofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_ofContext)
}

func (s *Transform_return_typeContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *Transform_return_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_return_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_return_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_return_type(s)
	}
}

func (s *Transform_return_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_return_type(s)
	}
}

func (p *SyslParser) Transform_return_type() (localctx ITransform_return_typeContext) {
	localctx = NewTransform_return_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, SyslParserRULE_transform_return_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1516)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1513)
			p.Set_of()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1514)
			p.Sequence_of()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1515)
			p.View_type_spec()
		}

	}

	return localctx
}

// IView_return_typeContext is an interface to support dynamic dispatch.
type IView_return_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_return_typeContext differentiates from other interfaces.
	IsView_return_typeContext()
}

type View_return_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_return_typeContext() *View_return_typeContext {
	var p = new(View_return_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_return_type
	return p
}

func (*View_return_typeContext) IsView_return_typeContext() {}

func NewView_return_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_return_typeContext {
	var p = new(View_return_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_return_type

	return p
}

func (s *View_return_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *View_return_typeContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *View_return_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_return_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_return_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_return_type(s)
	}
}

func (s *View_return_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_return_type(s)
	}
}

func (p *SyslParser) View_return_type() (localctx IView_return_typeContext) {
	localctx = NewView_return_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, SyslParserRULE_view_return_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1518)
		p.View_type_spec()
	}

	return localctx
}

// ITransform_scope_varContext is an interface to support dynamic dispatch.
type ITransform_scope_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_scope_varContext differentiates from other interfaces.
	IsTransform_scope_varContext()
}

type Transform_scope_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_scope_varContext() *Transform_scope_varContext {
	var p = new(Transform_scope_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_scope_var
	return p
}

func (*Transform_scope_varContext) IsTransform_scope_varContext() {}

func NewTransform_scope_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_scope_varContext {
	var p = new(Transform_scope_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_scope_var

	return p
}

func (s *Transform_scope_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_scope_varContext) E_Name() antlr.TerminalNode {
	return s.GetToken(SyslParserE_Name, 0)
}

func (s *Transform_scope_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_scope_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_scope_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_scope_var(s)
	}
}

func (s *Transform_scope_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_scope_var(s)
	}
}

func (p *SyslParser) Transform_scope_var() (localctx ITransform_scope_varContext) {
	localctx = NewTransform_scope_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, SyslParserRULE_transform_scope_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1520)
		p.Match(SyslParserE_Name)
	}

	return localctx
}

// ITransform_argContext is an interface to support dynamic dispatch.
type ITransform_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransform_argContext differentiates from other interfaces.
	IsTransform_argContext()
}

type Transform_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransform_argContext() *Transform_argContext {
	var p = new(Transform_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform_arg
	return p
}

func (*Transform_argContext) IsTransform_argContext() {}

func NewTransform_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transform_argContext {
	var p = new(Transform_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform_arg

	return p
}

func (s *Transform_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Transform_argContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Transform_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transform_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transform_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform_arg(s)
	}
}

func (s *Transform_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform_arg(s)
	}
}

func (p *SyslParser) Transform_arg() (localctx ITransform_argContext) {
	localctx = NewTransform_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, SyslParserRULE_transform_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1522)
		p.Expr()
	}

	return localctx
}

// ITransformContext is an interface to support dynamic dispatch.
type ITransformContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransformContext differentiates from other interfaces.
	IsTransformContext()
}

type TransformContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransformContext() *TransformContext {
	var p = new(TransformContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_transform
	return p
}

func (*TransformContext) IsTransformContext() {}

func NewTransformContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransformContext {
	var p = new(TransformContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_transform

	return p
}

func (s *TransformContext) GetParser() antlr.Parser { return s.parser }

func (s *TransformContext) E_ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ARROW_RIGHT, 0)
}

func (s *TransformContext) E_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_OPEN_PAREN, 0)
}

func (s *TransformContext) E_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserE_COLON, 0)
}

func (s *TransformContext) AllE_NL() []antlr.TerminalNode {
	return s.GetTokens(SyslParserE_NL)
}

func (s *TransformContext) E_NL(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserE_NL, i)
}

func (s *TransformContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *TransformContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *TransformContext) E_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_CLOSE_PAREN, 0)
}

func (s *TransformContext) Transform_arg() ITransform_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_argContext)
}

func (s *TransformContext) E_ANGLE_OPEN() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_OPEN, 0)
}

func (s *TransformContext) Transform_return_type() ITransform_return_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_return_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_return_typeContext)
}

func (s *TransformContext) E_ANGLE_CLOSE() antlr.TerminalNode {
	return s.GetToken(SyslParserE_ANGLE_CLOSE, 0)
}

func (s *TransformContext) Transform_scope_var() ITransform_scope_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransform_scope_varContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransform_scope_varContext)
}

func (s *TransformContext) AllExpr_stmt() []IExpr_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpr_stmtContext)(nil)).Elem())
	var tst = make([]IExpr_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpr_stmtContext)
		}
	}

	return tst
}

func (s *TransformContext) Expr_stmt(i int) IExpr_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpr_stmtContext)
}

func (s *TransformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransformContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransformContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterTransform(s)
	}
}

func (s *TransformContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitTransform(s)
	}
}

func (p *SyslParser) Transform() (localctx ITransformContext) {
	localctx = NewTransformContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, SyslParserRULE_transform)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1525)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1524)
			p.Transform_arg()
		}

	}
	{
		p.SetState(1527)
		p.Match(SyslParserE_ARROW_RIGHT)
	}
	p.SetState(1532)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_ANGLE_OPEN {
		{
			p.SetState(1528)
			p.Match(SyslParserE_ANGLE_OPEN)
		}
		{
			p.SetState(1529)
			p.Transform_return_type()
		}
		{
			p.SetState(1530)
			p.Match(SyslParserE_ANGLE_CLOSE)
		}

	}
	{
		p.SetState(1534)
		p.Match(SyslParserE_OPEN_PAREN)
	}
	p.SetState(1536)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserE_Name {
		{
			p.SetState(1535)
			p.Transform_scope_var()
		}

	}
	{
		p.SetState(1538)
		p.Match(SyslParserE_COLON)
	}
	{
		p.SetState(1539)
		p.Match(SyslParserE_NL)
	}
	{
		p.SetState(1540)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1542)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserNativeDataTypes || _la == SyslParserE_TABLE_OF || _la == SyslParserE_LET || (((_la-132)&-(0x1f+1)) == 0 && ((1<<uint((_la-132)))&((1<<(SyslParserE_FUNC-132))|(1<<(SyslParserE_DOT_NAME_NL-132))|(1<<(SyslParserE_Name-132)))) != 0) {
		{
			p.SetState(1541)
			p.Expr_stmt()
		}

		p.SetState(1544)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1546)
		p.Match(SyslParserDEDENT)
	}
	{
		p.SetState(1547)
		p.Match(SyslParserE_CLOSE_PAREN)
	}
	{
		p.SetState(1548)
		p.Match(SyslParserE_NL)
	}

	return localctx
}

// IExpr_blockContext is an interface to support dynamic dispatch.
type IExpr_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_blockContext differentiates from other interfaces.
	IsExpr_blockContext()
}

type Expr_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_blockContext() *Expr_blockContext {
	var p = new(Expr_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_expr_block
	return p
}

func (*Expr_blockContext) IsExpr_blockContext() {}

func NewExpr_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_blockContext {
	var p = new(Expr_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_expr_block

	return p
}

func (s *Expr_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_blockContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *Expr_blockContext) Transform() ITransformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransformContext)
}

func (s *Expr_blockContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *Expr_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterExpr_block(s)
	}
}

func (s *Expr_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitExpr_block(s)
	}
}

func (p *SyslParser) Expr_block() (localctx IExpr_blockContext) {
	localctx = NewExpr_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, SyslParserRULE_expr_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1550)
		p.Match(SyslParserINDENT)
	}
	{
		p.SetState(1551)
		p.Transform()
	}
	{
		p.SetState(1552)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IView_paramContext is an interface to support dynamic dispatch.
type IView_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_paramContext differentiates from other interfaces.
	IsView_paramContext()
}

type View_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_paramContext() *View_paramContext {
	var p = new(View_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_param
	return p
}

func (*View_paramContext) IsView_paramContext() {}

func NewView_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_paramContext {
	var p = new(View_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_param

	return p
}

func (s *View_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *View_paramContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *View_paramContext) LESS_COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserLESS_COLON, 0)
}

func (s *View_paramContext) View_type_spec() IView_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_type_specContext)
}

func (s *View_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_param(s)
	}
}

func (s *View_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_param(s)
	}
}

func (p *SyslParser) View_param() (localctx IView_paramContext) {
	localctx = NewView_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, SyslParserRULE_view_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1554)
		p.Name_str()
	}
	{
		p.SetState(1555)
		p.Match(SyslParserLESS_COLON)
	}
	{
		p.SetState(1556)
		p.View_type_spec()
	}

	return localctx
}

// IView_paramsContext is an interface to support dynamic dispatch.
type IView_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsView_paramsContext differentiates from other interfaces.
	IsView_paramsContext()
}

type View_paramsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_paramsContext() *View_paramsContext {
	var p = new(View_paramsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view_params
	return p
}

func (*View_paramsContext) IsView_paramsContext() {}

func NewView_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_paramsContext {
	var p = new(View_paramsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view_params

	return p
}

func (s *View_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *View_paramsContext) AllView_param() []IView_paramContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IView_paramContext)(nil)).Elem())
	var tst = make([]IView_paramContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IView_paramContext)
		}
	}

	return tst
}

func (s *View_paramsContext) View_param(i int) IView_paramContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_paramContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IView_paramContext)
}

func (s *View_paramsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SyslParserCOMMA)
}

func (s *View_paramsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserCOMMA, i)
}

func (s *View_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView_params(s)
	}
}

func (s *View_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView_params(s)
	}
}

func (p *SyslParser) View_params() (localctx IView_paramsContext) {
	localctx = NewView_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, SyslParserRULE_view_params)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1558)
		p.View_param()
	}
	p.SetState(1563)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserCOMMA {
		{
			p.SetState(1559)
			p.Match(SyslParserCOMMA)
		}
		{
			p.SetState(1560)
			p.View_param()
		}

		p.SetState(1565)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAbstract_viewContext is an interface to support dynamic dispatch.
type IAbstract_viewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstract_viewContext differentiates from other interfaces.
	IsAbstract_viewContext()
}

type Abstract_viewContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstract_viewContext() *Abstract_viewContext {
	var p = new(Abstract_viewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_abstract_view
	return p
}

func (*Abstract_viewContext) IsAbstract_viewContext() {}

func NewAbstract_viewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Abstract_viewContext {
	var p = new(Abstract_viewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_abstract_view

	return p
}

func (s *Abstract_viewContext) GetParser() antlr.Parser { return s.parser }

func (s *Abstract_viewContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(SyslParserABSTRACT, 0)
}

func (s *Abstract_viewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Abstract_viewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Abstract_viewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAbstract_view(s)
	}
}

func (s *Abstract_viewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAbstract_view(s)
	}
}

func (p *SyslParser) Abstract_view() (localctx IAbstract_viewContext) {
	localctx = NewAbstract_viewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, SyslParserRULE_abstract_view)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1566)
		p.Match(SyslParserABSTRACT)
	}

	return localctx
}

// IViewContext is an interface to support dynamic dispatch.
type IViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAbstractView returns the abstractView attribute.
	GetAbstractView() bool

	// SetAbstractView sets the abstractView attribute.
	SetAbstractView(bool)

	// IsViewContext differentiates from other interfaces.
	IsViewContext()
}

type ViewContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	abstractView bool
}

func NewEmptyViewContext() *ViewContext {
	var p = new(ViewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_view
	return p
}

func (*ViewContext) IsViewContext() {}

func NewViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewContext {
	var p = new(ViewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_view

	return p
}

func (s *ViewContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewContext) GetAbstractView() bool { return s.abstractView }

func (s *ViewContext) SetAbstractView(v bool) { s.abstractView = v }

func (s *ViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SyslParserVIEW, 0)
}

func (s *ViewContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *ViewContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserOPEN_PAREN, 0)
}

func (s *ViewContext) View_params() IView_paramsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_paramsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_paramsContext)
}

func (s *ViewContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(SyslParserCLOSE_PAREN, 0)
}

func (s *ViewContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *ViewContext) Expr_block() IExpr_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_blockContext)
}

func (s *ViewContext) Abstract_view() IAbstract_viewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_viewContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_viewContext)
}

func (s *ViewContext) ARROW_RIGHT() antlr.TerminalNode {
	return s.GetToken(SyslParserARROW_RIGHT, 0)
}

func (s *ViewContext) View_return_type() IView_return_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IView_return_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IView_return_typeContext)
}

func (s *ViewContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *ViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterView(s)
	}
}

func (s *ViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitView(s)
	}
}

func (p *SyslParser) View() (localctx IViewContext) {
	localctx = NewViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, SyslParserRULE_view)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1568)
		p.Match(SyslParserVIEW)
	}
	{
		p.SetState(1569)
		p.Name_str()
	}
	{
		p.SetState(1570)
		p.Match(SyslParserOPEN_PAREN)
	}
	{
		p.SetState(1571)
		p.View_params()
	}
	{
		p.SetState(1572)
		p.Match(SyslParserCLOSE_PAREN)
	}
	p.SetState(1575)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserARROW_RIGHT {
		{
			p.SetState(1573)
			p.Match(SyslParserARROW_RIGHT)
		}
		{
			p.SetState(1574)
			p.View_return_type()
		}

	}
	p.SetState(1585)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserCOLON, SyslParserSQ_OPEN:
		p.SetState(1578)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SyslParserSQ_OPEN {
			{
				p.SetState(1577)
				p.Attribs_or_modifiers()
			}

		}
		{
			p.SetState(1580)
			p.Match(SyslParserCOLON)
		}
		{
			p.SetState(1581)
			p.Expr_block()
		}

	case SyslParserABSTRACT:
		{
			p.SetState(1582)
			p.Abstract_view()
		}
		localctx.(*ViewContext).SetAbstractView(true)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_alias
	return p
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(SyslParserALIAS, 0)
}

func (s *AliasContext) Name_str() IName_strContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_strContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_strContext)
}

func (s *AliasContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *AliasContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *AliasContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *AliasContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *AliasContext) Collection_type() ICollection_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_typeContext)
}

func (s *AliasContext) Attribs_or_modifiers() IAttribs_or_modifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribs_or_modifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribs_or_modifiersContext)
}

func (s *AliasContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *AliasContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterAlias(s)
	}
}

func (s *AliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitAlias(s)
	}
}

func (p *SyslParser) Alias() (localctx IAliasContext) {
	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, SyslParserRULE_alias)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1587)
		p.Match(SyslParserALIAS)
	}
	{
		p.SetState(1588)
		p.Name_str()
	}
	p.SetState(1590)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserSQ_OPEN {
		{
			p.SetState(1589)
			p.Attribs_or_modifiers()
		}

	}
	{
		p.SetState(1592)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(1593)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1597)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserAT {
		{
			p.SetState(1594)
			p.Annotation()
		}

		p.SetState(1599)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1602)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SyslParserNativeDataTypes, SyslParserTEXT_LINE, SyslParserName, SyslParserE_Name:
		{
			p.SetState(1600)
			p.Types()
		}

	case SyslParserSEQUENCE_OF, SyslParserSET_OF, SyslParserE_SEQUENCE_OF, SyslParserE_SET_OF:
		{
			p.SetState(1601)
			p.Collection_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1604)
		p.Match(SyslParserDEDENT)
	}

	return localctx
}

// IApp_declContext is an interface to support dynamic dispatch.
type IApp_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_view returns the _view rule contexts.
	Get_view() IViewContext

	// Set_view sets the _view rule contexts.
	Set_view(IViewContext)

	// GetCheck returns the check attribute.
	GetCheck() bool

	// SetCheck sets the check attribute.
	SetCheck(bool)

	// IsApp_declContext differentiates from other interfaces.
	IsApp_declContext()
}

type App_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	check  bool
	_view  IViewContext
}

func NewEmptyApp_declContext() *App_declContext {
	var p = new(App_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_app_decl
	return p
}

func (*App_declContext) IsApp_declContext() {}

func NewApp_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *App_declContext {
	var p = new(App_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_app_decl

	return p
}

func (s *App_declContext) GetParser() antlr.Parser { return s.parser }

func (s *App_declContext) Get_view() IViewContext { return s._view }

func (s *App_declContext) Set_view(v IViewContext) { s._view = v }

func (s *App_declContext) GetCheck() bool { return s.check }

func (s *App_declContext) SetCheck(v bool) { s.check = v }

func (s *App_declContext) INDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserINDENT, 0)
}

func (s *App_declContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(SyslParserDEDENT, 0)
}

func (s *App_declContext) AllAlias() []IAliasContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAliasContext)(nil)).Elem())
	var tst = make([]IAliasContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAliasContext)
		}
	}

	return tst
}

func (s *App_declContext) Alias(i int) IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *App_declContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *App_declContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *App_declContext) AllCollector() []ICollectorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollectorContext)(nil)).Elem())
	var tst = make([]ICollectorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollectorContext)
		}
	}

	return tst
}

func (s *App_declContext) Collector(i int) ICollectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollectorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollectorContext)
}

func (s *App_declContext) AllEvent() []IEventContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEventContext)(nil)).Elem())
	var tst = make([]IEventContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEventContext)
		}
	}

	return tst
}

func (s *App_declContext) Event(i int) IEventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEventContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEventContext)
}

func (s *App_declContext) AllFacade() []IFacadeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFacadeContext)(nil)).Elem())
	var tst = make([]IFacadeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFacadeContext)
		}
	}

	return tst
}

func (s *App_declContext) Facade(i int) IFacadeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFacadeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFacadeContext)
}

func (s *App_declContext) AllMixin() []IMixinContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMixinContext)(nil)).Elem())
	var tst = make([]IMixinContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMixinContext)
		}
	}

	return tst
}

func (s *App_declContext) Mixin(i int) IMixinContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMixinContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMixinContext)
}

func (s *App_declContext) AllRest_endpoint() []IRest_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem())
	var tst = make([]IRest_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRest_endpointContext)
		}
	}

	return tst
}

func (s *App_declContext) Rest_endpoint(i int) IRest_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRest_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRest_endpointContext)
}

func (s *App_declContext) AllSimple_endpoint() []ISimple_endpointContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_endpointContext)(nil)).Elem())
	var tst = make([]ISimple_endpointContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_endpointContext)
		}
	}

	return tst
}

func (s *App_declContext) Simple_endpoint(i int) ISimple_endpointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_endpointContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_endpointContext)
}

func (s *App_declContext) AllSubscribe() []ISubscribeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscribeContext)(nil)).Elem())
	var tst = make([]ISubscribeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscribeContext)
		}
	}

	return tst
}

func (s *App_declContext) Subscribe(i int) ISubscribeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscribeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscribeContext)
}

func (s *App_declContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *App_declContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *App_declContext) AllUnion() []IUnionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionContext)(nil)).Elem())
	var tst = make([]IUnionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionContext)
		}
	}

	return tst
}

func (s *App_declContext) Union(i int) IUnionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionContext)
}

func (s *App_declContext) AllView() []IViewContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IViewContext)(nil)).Elem())
	var tst = make([]IViewContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IViewContext)
		}
	}

	return tst
}

func (s *App_declContext) View(i int) IViewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IViewContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IViewContext)
}

func (s *App_declContext) AllTable() []ITableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableContext)(nil)).Elem())
	var tst = make([]ITableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableContext)
		}
	}

	return tst
}

func (s *App_declContext) Table(i int) ITableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *App_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *App_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *App_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApp_decl(s)
	}
}

func (s *App_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApp_decl(s)
	}
}

func (p *SyslParser) App_decl() (localctx IApp_declContext) {
	localctx = NewApp_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, SyslParserRULE_app_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1606)
		p.Match(SyslParserINDENT)
	}
	p.SetState(1622)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(1622)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1607)
					p.Alias()
				}

			case 2:
				{
					p.SetState(1608)
					p.Annotation()
				}

			case 3:
				{
					p.SetState(1609)
					p.Collector()
				}

			case 4:
				{
					p.SetState(1610)
					p.Event()
				}

			case 5:
				{
					p.SetState(1611)
					p.Facade()
				}

			case 6:
				{
					p.SetState(1612)
					p.Mixin()
				}

			case 7:
				{
					p.SetState(1613)
					p.Rest_endpoint()
				}

			case 8:
				{
					p.SetState(1614)
					p.Simple_endpoint()
				}

			case 9:
				{
					p.SetState(1615)
					p.Subscribe()
				}

			case 10:
				{
					p.SetState(1616)
					p.Match(SyslParserSYSL_COMMENT)
				}

			case 11:
				{
					p.SetState(1617)
					p.Union()
				}

			case 12:
				{
					p.SetState(1618)

					var _x = p.View()

					localctx.(*App_declContext)._view = _x
				}
				localctx.(*App_declContext).SetCheck(localctx.(*App_declContext).Get_view().GetAbstractView())

			case 13:
				{
					p.SetState(1621)
					p.Table()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1624)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext())
	}
	p.SetState(1628)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1626)

		if !(localctx.(*App_declContext).check) {
			panic(antlr.NewFailedPredicateException(p, "$check", ""))
		}

	case 2:
		{
			p.SetState(1627)
			p.Match(SyslParserDEDENT)
		}

	}

	return localctx
}

// IApplicationContext is an interface to support dynamic dispatch.
type IApplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsApplicationContext differentiates from other interfaces.
	IsApplicationContext()
}

type ApplicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApplicationContext() *ApplicationContext {
	var p = new(ApplicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_application
	return p
}

func (*ApplicationContext) IsApplicationContext() {}

func NewApplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApplicationContext {
	var p = new(ApplicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_application

	return p
}

func (s *ApplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *ApplicationContext) Name_with_attribs() IName_with_attribsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_with_attribsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_with_attribsContext)
}

func (s *ApplicationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SyslParserCOLON, 0)
}

func (s *ApplicationContext) App_decl() IApp_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApp_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApp_declContext)
}

func (s *ApplicationContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *ApplicationContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *ApplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterApplication(s)
	}
}

func (s *ApplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitApplication(s)
	}
}

func (p *SyslParser) Application() (localctx IApplicationContext) {
	localctx = NewApplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, SyslParserRULE_application)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1633)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserSYSL_COMMENT {
		{
			p.SetState(1630)
			p.Match(SyslParserSYSL_COMMENT)
		}

		p.SetState(1635)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1636)
		p.Name_with_attribs()
	}
	{
		p.SetState(1637)
		p.Match(SyslParserCOLON)
	}
	{
		p.SetState(1638)
		p.App_decl()
	}

	return localctx
}

// IPathContext is an interface to support dynamic dispatch.
type IPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPathContext differentiates from other interfaces.
	IsPathContext()
}

type PathContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathContext() *PathContext {
	var p = new(PathContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_path
	return p
}

func (*PathContext) IsPathContext() {}

func NewPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathContext {
	var p = new(PathContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_path

	return p
}

func (s *PathContext) GetParser() antlr.Parser { return s.parser }

func (s *PathContext) AllName() []antlr.TerminalNode {
	return s.GetTokens(SyslParserName)
}

func (s *PathContext) Name(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserName, i)
}

func (s *PathContext) AllFORWARD_SLASH() []antlr.TerminalNode {
	return s.GetTokens(SyslParserFORWARD_SLASH)
}

func (s *PathContext) FORWARD_SLASH(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserFORWARD_SLASH, i)
}

func (s *PathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterPath(s)
	}
}

func (s *PathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitPath(s)
	}
}

func (p *SyslParser) Path() (localctx IPathContext) {
	localctx = NewPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, SyslParserRULE_path)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1641)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserFORWARD_SLASH {
		{
			p.SetState(1640)
			p.Match(SyslParserFORWARD_SLASH)
		}

	}
	{
		p.SetState(1643)
		p.Match(SyslParserName)
	}
	p.SetState(1648)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SyslParserFORWARD_SLASH {
		{
			p.SetState(1644)
			p.Match(SyslParserFORWARD_SLASH)
		}
		{
			p.SetState(1645)
			p.Match(SyslParserName)
		}

		p.SetState(1650)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IImport_stmtContext is an interface to support dynamic dispatch.
type IImport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_stmtContext differentiates from other interfaces.
	IsImport_stmtContext()
}

type Import_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_stmtContext() *Import_stmtContext {
	var p = new(Import_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_import_stmt
	return p
}

func (*Import_stmtContext) IsImport_stmtContext() {}

func NewImport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_stmtContext {
	var p = new(Import_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_import_stmt

	return p
}

func (s *Import_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_stmtContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(SyslParserIMPORT, 0)
}

func (s *Import_stmtContext) AllSYSL_COMMENT() []antlr.TerminalNode {
	return s.GetTokens(SyslParserSYSL_COMMENT)
}

func (s *Import_stmtContext) SYSL_COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(SyslParserSYSL_COMMENT, i)
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitImport_stmt(s)
	}
}

func (p *SyslParser) Import_stmt() (localctx IImport_stmtContext) {
	localctx = NewImport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, SyslParserRULE_import_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1651)
		p.Match(SyslParserIMPORT)
	}
	p.SetState(1655)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1652)
				p.Match(SyslParserSYSL_COMMENT)
			}

		}
		p.SetState(1657)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext())
	}

	return localctx
}

// IImports_declContext is an interface to support dynamic dispatch.
type IImports_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImports_declContext differentiates from other interfaces.
	IsImports_declContext()
}

type Imports_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImports_declContext() *Imports_declContext {
	var p = new(Imports_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_imports_decl
	return p
}

func (*Imports_declContext) IsImports_declContext() {}

func NewImports_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imports_declContext {
	var p = new(Imports_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_imports_decl

	return p
}

func (s *Imports_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Imports_declContext) AllImport_stmt() []IImport_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImport_stmtContext)(nil)).Elem())
	var tst = make([]IImport_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImport_stmtContext)
		}
	}

	return tst
}

func (s *Imports_declContext) Import_stmt(i int) IImport_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Imports_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imports_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imports_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterImports_decl(s)
	}
}

func (s *Imports_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitImports_decl(s)
	}
}

func (p *SyslParser) Imports_decl() (localctx IImports_declContext) {
	localctx = NewImports_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, SyslParserRULE_imports_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1659)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SyslParserIMPORT {
		{
			p.SetState(1658)
			p.Import_stmt()
		}

		p.SetState(1661)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISysl_fileContext is an interface to support dynamic dispatch.
type ISysl_fileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSysl_fileContext differentiates from other interfaces.
	IsSysl_fileContext()
}

type Sysl_fileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySysl_fileContext() *Sysl_fileContext {
	var p = new(Sysl_fileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SyslParserRULE_sysl_file
	return p
}

func (*Sysl_fileContext) IsSysl_fileContext() {}

func NewSysl_fileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sysl_fileContext {
	var p = new(Sysl_fileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SyslParserRULE_sysl_file

	return p
}

func (s *Sysl_fileContext) GetParser() antlr.Parser { return s.parser }

func (s *Sysl_fileContext) EOF() antlr.TerminalNode {
	return s.GetToken(SyslParserEOF, 0)
}

func (s *Sysl_fileContext) Imports_decl() IImports_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImports_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImports_declContext)
}

func (s *Sysl_fileContext) AllApplication() []IApplicationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IApplicationContext)(nil)).Elem())
	var tst = make([]IApplicationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IApplicationContext)
		}
	}

	return tst
}

func (s *Sysl_fileContext) Application(i int) IApplicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApplicationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IApplicationContext)
}

func (s *Sysl_fileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sysl_fileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sysl_fileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.EnterSysl_file(s)
	}
}

func (s *Sysl_fileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SyslParserListener); ok {
		listenerT.ExitSysl_file(s)
	}
}

func (p *SyslParser) Sysl_file() (localctx ISysl_fileContext) {
	localctx = NewSysl_fileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, SyslParserRULE_sysl_file)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1664)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SyslParserIMPORT {
		{
			p.SetState(1663)
			p.Imports_decl()
		}

	}
	p.SetState(1667)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(SyslParserSYSL_COMMENT-59))|(1<<(SyslParserTEXT_LINE-59))|(1<<(SyslParserName-59)))) != 0) || _la == SyslParserE_Name {
		{
			p.SetState(1666)
			p.Application()
		}

		p.SetState(1669)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1671)
		p.Match(SyslParserEOF)
	}

	return localctx
}

func (p *SyslParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 147:
		var t *Cond_blockContext = nil
		if localctx != nil {
			t = localctx.(*Cond_blockContext)
		}
		return p.Cond_block_Sempred(t, predIndex)

	case 148:
		var t *Final_elseContext = nil
		if localctx != nil {
			t = localctx.(*Final_elseContext)
		}
		return p.Final_else_Sempred(t, predIndex)

	case 159:
		var t *Expr_statementContext = nil
		if localctx != nil {
			t = localctx.(*Expr_statementContext)
		}
		return p.Expr_statement_Sempred(t, predIndex)

	case 173:
		var t *App_declContext = nil
		if localctx != nil {
			t = localctx.(*App_declContext)
		}
		return p.App_decl_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SyslParser) Cond_block_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return localctx.(*Cond_blockContext).Get_else_block_stmt().GetNested() == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) Final_else_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return localctx.(*Final_elseContext).Get_expr().GetNested() == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) Expr_statement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return localctx.(*Expr_statementContext).nested == true

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SyslParser) App_decl_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return localctx.(*App_declContext).check

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
