package main

import (
	"bytes"
	"fmt"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/anz-bank/sysl/src/proto"
	"github.com/sirupsen/logrus"
)

type indentWriter struct {
	bytes.Buffer
	ind      int
	complete bool // if the current position is a complete line
}

func (w *indentWriter) Write(p []byte) (n int, err error) {
	newline := []byte("\n")
	newlines := bytes.Count(p, newline)
	if newlines == 0 {
		if w.complete {
			w.writeIndent()
		}
		n, err = w.Buffer.Write(p)
		w.complete = false
		return n, err
	}

	frags := bytes.SplitN(p, newline, newlines+1)

	for i, frag := range frags {
		if w.complete {
			w.writeIndent()
		}
		nn, err := w.Buffer.Write(frag)
		n += nn
		if err != nil {
			return n, err
		}
		if i+1 < len(frags) {
			if _, err := w.Buffer.Write(newline); err != nil {
				return n, err
			}
			n++
		}
	}
	w.complete = len(frags[len(frags)-1]) == 0
	return n, nil
}

func (w *indentWriter) WriteString(s string) (n int, err error) {
	if !strings.Contains(s, "\n") {
		if w.complete {
			w.writeIndent()
		}
		w.complete = false
		return w.Buffer.WriteString(s)
	}
	return w.Write([]byte(s))
}

func (w *indentWriter) writeIndent() error {
	if !w.complete {
		return nil
	}

	for i := 0; i < w.ind; i++ {
		if err := w.Buffer.WriteByte(' '); err != nil {
			return err
		}
	}

	w.complete = false

	return nil
}

func (w *indentWriter) indent() { w.ind++ }

func (w *indentWriter) unindent() {
	if w.ind == 0 {
		logrus.Warn("seqs: indentWriter unindented too far")
		return
	}
	w.ind--
}

type sequenceDiagWriter struct {
	autogenHeader bool
	head          indentWriter
	body          indentWriter
}

func (w *sequenceDiagWriter) String() string {
	var sb strings.Builder
	if w.autogenHeader {
		fmt.Fprintln(&sb, "''''''''''''''''''''''''''''''''''''''''''")
		fmt.Fprintln(&sb, "''                                      ''")
		fmt.Fprintln(&sb, "''  AUTOGENERATED CODE -- DO NOT EDIT!  ''")
		fmt.Fprintln(&sb, "''                                      ''")
		fmt.Fprintln(&sb, "''''''''''''''''''''''''''''''''''''''''''")
		fmt.Fprintln(&sb)
	}

	fmt.Fprintln(&sb, "@startuml")
	sb.WriteString(w.head.Buffer.String())
	sb.WriteString(w.body.Buffer.String())
	fmt.Fprintln(&sb, "@enduml")

	return sb.String()
}

type epFmtParam struct {
	epname, human, human_sender, needs_int, args, patterns, controls string
	attrs                                                            map[string]*sysl.Attribute
}

type SfmtApp = func(appname, controls string, attrs map[string]*sysl.Attribute) string

type SfmtEP = func(p *epFmtParam) string

type sequenceDiagParam struct {
	endpoints   []string
	epfmt       SfmtEP
	appfmt      SfmtApp
	activations bool
	title       string
	blackboxes  [][]string
}

type appEndpoint struct {
	appname, epname, upto string
}

func makeAppEndpoint(s string) *appEndpoint {
	r := regexp.MustCompile(`(?P<appname>.*?)\s*<-\s*(?P<epname>.*?)(?:\s*\[upto\s+(?P<upto>.*)\])*$`)
	match := r.FindStringSubmatch(s)

	out := &appEndpoint{}
	for i, name := range r.SubexpNames() {
		if i > 0 && i <= len(match) {
			switch {
			case name == "appname":
				out.appname = match[i]
			case name == "epname":
				out.epname = match[i]
			case name == "upto":
				out.upto = match[i]
			}
		}
	}
	return out
}

type varName struct {
	category, order       int
	agent, varname, label string
}

func (v *varName) String() string {
	return fmt.Sprintf(`%s "%s" as %s`, v.agent, v.label, v.varname)
}

func (v *varName) setCategoryAndAgent(attrs map[string]*sysl.Attribute) {
	if attrs != nil {
		if patterns, has := attrs["patterns"]; has {
			if x := patterns.GetA(); x != nil {
				for _, y := range x.Elt {
					switch y.GetS() {
					case "human":
						v.category = 0
						v.agent = "actor"
					case "ui":
						v.category = 1
						v.agent = "boundary"
					case "cron":
						v.category = 2
						v.agent = "control"
					case "db":
						v.category = 4
						v.agent = "database"
					case "external":
						v.category = 5
						v.agent = "control"
					}
				}
			}
		}
	}
}

func makeVarName(varname string) *varName {
	i, _ := strconv.Atoi(varname[1:])
	return &varName{3, i, "control", varname, ""}
}

type newVar = func(varname, appname string)

type varManager struct {
	symbols       map[string]string
	newVarCreated newVar
}

func (v *varManager) getOrCreateVar(appname string) string {
	if varname, ok := v.symbols[appname]; ok {
		return varname
	}

	varname := fmt.Sprintf("_%d", len(v.symbols))
	v.newVarCreated(varname, appname)
	v.symbols[appname] = varname

	return varname
}

func getSortedISOCtrls(attrs map[string]*sysl.Attribute) []string {
	s := make([]string, 0)

	reg := regexp.MustCompile("iso_ctrl_(.*)_txt")
	for k := range attrs {
		if !strings.Contains(k, "iso_ctrl") {
			continue
		}
		match := reg.FindStringSubmatch(k)
		if len(match) > 1 {
			s = append(s, match[1])
		}
	}
	sort.Strings(s)
	return s
}

type setS map[string]interface{}

func unionSetS(a, b setS) setS {
	s := make(map[string]interface{})
	for k := range a {
		s[k] = nil
	}
	for k := range b {
		s[k] = nil
	}
	return s
}

func copySetS(a setS) setS {
	s := make(map[string]interface{})
	for k := range a {
		s[k] = nil
	}
	return s
}

func getSortedKeys(s setS) []string {
	a := make([]string, 0, len(s))
	for k := range s {
		a = append(a, k)
	}
	sort.Strings(a)
	return a
}

func getPatternsSet(attrs map[string]*sysl.Attribute) setS {
	s := make(map[string]interface{})
	if patterns, has := attrs["patterns"]; has {
		if x := patterns.GetA(); x != nil {
			for _, y := range x.Elt {
				s[y.GetS()] = nil
			}
		}
	}
	return s
}

type visitParam struct {
	w               *sequenceDiagWriter
	vm              *varManager
	m               *sysl.Module
	already_visited map[string]int
	uptos           map[string]string
	fmtArgs         func(a, b string) string
	fmtEndpoint     SfmtEP
	fmtReturnParam  func(a string) []string
	appname, epname string
}

type visitEndpointParam struct {
	visitParam
	from_app                               *sysl.AppName
	sender_patterns, sender_endpt_patterns setS
	stmt                                   *sysl.Statement
	deactivate                             bool
}

func visitEndpoint(p *visitEndpointParam) string {
	sender := "["
	if p.from_app != nil {
		sender = p.vm.getOrCreateVar(getAppName(p.from_app))
	}

	agent := p.vm.getOrCreateVar(p.appname)
	app, ok := p.m.GetApps()[p.appname]
	if !ok {
		logrus.Warnf("the specified app with name %s does not exist", p.appname)
		return ""
	}
	endpt, ok := app.GetEndpoints()[p.epname]
	if !ok {
		logrus.Warnf("the specified endpoint with name %s does not exist", p.epname)
		return ""
	}

	app_patterns := getPatternsSet(app.GetAttrs())
	target_patterns := getPatternsSet(endpt.GetAttrs())

	patterns := copySetS(target_patterns)

	_, human := app_patterns["human"]
	_, human_sender := p.sender_patterns["human"]
	_, cron := p.sender_patterns["cron"]
	needs_int := sender != agent && !(human || human_sender || cron)

	regL := regexp.MustCompile(`^.*? -> `)
	label := regL.ReplaceAllLiteralString(p.epname, " ⬄ ")

	_, cron = app_patterns["cron"]

	if p.stmt != nil && p.stmt.GetCall() != nil {
		ptrns := ""
		if len(p.sender_endpt_patterns) > 0 || len(patterns) > 0 {
			ptrns = strings.Join(getSortedKeys(p.sender_endpt_patterns), ", ")
			ptrns += " → "
			ptrns += strings.Join(getSortedKeys(patterns), ", ")
		}
		isoctrl := getSortedISOCtrls(endpt.GetAttrs())

		epargs := make([]string, 0)
		for _, v := range endpt.GetParam() {
			if ref_type := v.GetType().GetTypeRef(); ref_type != nil {
				if ref := ref_type.GetRef(); ref != nil {
					an := getAppName(ref.GetAppname())
					pn := strings.Join(ref.GetPath(), ".")
					eparg := p.fmtArgs(an, pn)
					if len(eparg) > 0 {
						epargs = append(epargs, eparg)
					}
				}
			}
		}

		s_epp := &epFmtParam{}
		s_epp.epname = label
		if human {
			s_epp.human = "human"
		}
		if human_sender {
			s_epp.human_sender = "human sender"
		}
		if needs_int {
			s_epp.needs_int = "needs_init"
		}
		s_epp.args = strings.Join(epargs, " | ")
		s_epp.patterns = ptrns
		s_epp.controls = strings.Join(isoctrl, ", ")
		s_epp.attrs = p.stmt.GetAttrs()
		label = p.fmtEndpoint(s_epp)
	}

	if !((human && sender == "[") || cron) {
		ep_patterns := getPatternsSet(endpt.GetAttrs())
		icon := ""
		if _, ok := ep_patterns["cron"]; ok {
			icon = "<&timer>"
		}
		fmt.Fprintf(&p.w.body, "%s->%s : %s%s\n", sender, agent, icon, label)
	}

	rargs := make([]string, 0)
	for _, ep_stmt := range endpt.GetStmt() {
		if stmt_ret := ep_stmt.GetRet(); stmt_ret != nil {
			ret_param := p.fmtReturnParam(stmt_ret.GetPayload())
			rargs = append(rargs, ret_param...)
		}
	}

	payload := strings.Join(rargs, " | ")
	calling_self := p.from_app != nil && getAppName(p.from_app) == p.appname

	if !calling_self && len(payload) == 0 && p.deactivate {
		fmt.Fprintf(&p.w.body, "deactivate %s\n", agent)
	}

	if len(endpt.GetStmt()) > 0 {
		hit_blackbox := false
		for upto, comment := range p.uptos {
			parts := strings.Split(upto, " <- ")
			if len(parts) == 2 && parts[0] == p.appname && parts[1] == p.epname {
				hit_blackbox = true
				if len(comment) == 0 {
					comment = "see below"
				}
				if len(payload) > 0 {
					fmt.Fprintf(&p.w.body, "activate %s\n", agent)
					p.w.body.indent()
					fmt.Fprintf(&p.w.body, "note over %s: %s\n", agent, comment)
					fmt.Fprintf(&p.w.body, "%s<--%s : %s\n", sender, agent, payload)
					p.w.body.unindent()
					fmt.Fprintf(&p.w.body, "deactivate %s\n", agent)
				} else {
					direct := "right"
					if sender > agent {
						direct = "left"
					}
					fmt.Fprintf(&p.w.body, "note %s: %s\n", direct, comment)
				}
				break
			}
		}

		if !hit_blackbox {
			active := !human && !cron
			if active {
				fmt.Fprintf(&p.w.body, "activate %s\n", agent)
			}
			visiting := fmt.Sprintf("%s <- %s", p.appname, p.epname)
			p.already_visited[visiting] += 1
			sp := &visitStmtsParam{}
			sp.w = p.w
			sp.vm = p.vm
			sp.m = p.m
			sp.already_visited = p.already_visited
			sp.uptos = p.uptos
			sp.fmtArgs = p.fmtArgs
			sp.fmtEndpoint = p.fmtEndpoint
			sp.fmtReturnParam = p.fmtReturnParam
			sp.appname = p.appname
			sp.epname = p.epname
			sp.app_patterns = app_patterns
			sp.target_patterns = target_patterns
			sp.deactivate = active
			sp.agent = agent
			sp.sender = sender
			sp.stmts = endpt.GetStmt()
			sp.last_parent_stmt = true
			payload = visitStmts(sp)
			p.already_visited[visiting] -= 1
			if p.already_visited[visiting] == 0 {
				delete(p.already_visited, visiting)
			}
			if active {
				fmt.Fprintf(&p.w.body, "deactivate %s\n", agent)
			}
		}
	}

	return payload
}

type visitStmtsParam struct {
	visitParam
	stmts                        []*sysl.Statement
	deactivate, last_parent_stmt bool
	app_patterns                 setS
	target_patterns              setS
	agent                        string
	sender                       string
}

func visitStmts(p *visitStmtsParam) string {
	block := func(last_stmt bool, block_stmts []*sysl.Statement, fmtStr string, args ...interface{}) string {
		fmt.Fprintf(&p.w.body, fmtStr, args)
		p.w.body.indent()
		sp := &visitStmtsParam{}
		sp.w = p.w
		sp.vm = p.vm
		sp.m = p.m
		sp.already_visited = p.already_visited
		sp.uptos = p.uptos
		sp.fmtArgs = p.fmtArgs
		sp.fmtEndpoint = p.fmtEndpoint
		sp.fmtReturnParam = p.fmtReturnParam
		sp.appname = p.appname
		sp.epname = p.epname
		sp.app_patterns = p.app_patterns
		sp.target_patterns = p.target_patterns
		sp.deactivate = p.deactivate
		sp.agent = p.agent
		sp.sender = p.sender
		sp.stmts = block_stmts
		sp.last_parent_stmt = last_stmt
		ret := visitStmts(sp)
		p.w.body.unindent()
		return ret
	}

	blockWithEnd := func(last_stmt bool, block_stmts []*sysl.Statement, fmtStr string, args ...interface{}) string {
		payload := block(last_stmt, block_stmts, fmtStr, args)
		p.w.body.WriteString("end\n")
		return payload
	}

	payload := ""
	for i, stmt := range p.stmts {
		last_stmt := p.last_parent_stmt && i == len(p.stmts)-1
		stmt_patterns := getPatternsSet(stmt.GetAttrs())
		switch stmt.GetStmt().(type) {
		case *sysl.Statement_Call:
			ep := &visitEndpointParam{}
			ep.w = p.w
			ep.vm = p.vm
			ep.m = p.m
			ep.already_visited = p.already_visited
			ep.uptos = p.uptos
			ep.fmtArgs = p.fmtArgs
			ep.fmtEndpoint = p.fmtEndpoint
			ep.fmtReturnParam = p.fmtReturnParam
			ep.appname = getAppName(stmt.GetCall().GetTarget())
			ep.epname = stmt.GetCall().GetEndpoint()
			ep.from_app = p.m.GetApps()[p.appname].GetName()
			ep.sender_patterns = p.app_patterns
			ep.sender_endpt_patterns = unionSetS(p.target_patterns, stmt_patterns)
			ep.stmt = stmt
			ep.deactivate = last_stmt && p.deactivate

			p.w.body.indent()
			payload = visitEndpoint(ep)
			p.w.body.unindent()
		case *sysl.Statement_Action:
			fmt.Fprintf(&p.w.body, "%s -> %s : %s\n", p.agent, p.agent, stmt.GetAction().GetAction())
		case *sysl.Statement_Cond:
			payload = blockWithEnd(last_stmt, stmt.GetCond().GetStmt(), "opt %s\n", stmt.GetCond().GetTest())
		case *sysl.Statement_Loop:
			loop := stmt.GetLoop()
			payload = blockWithEnd(last_stmt, loop.GetStmt(), "loop %s %s\n", sysl.Loop_Mode_name[int32(loop.GetMode())], loop.GetCriterion())
		case *sysl.Statement_LoopN:
			payload = blockWithEnd(last_stmt, stmt.GetLoopN().GetStmt(), "loop %d times\n", stmt.GetLoopN().GetCount())
		case *sysl.Statement_Foreach:
			payload = blockWithEnd(last_stmt, stmt.GetForeach().GetStmt(), "loop for each %s\n", stmt.GetForeach().GetCollection())
		case *sysl.Statement_Group:
			payload = blockWithEnd(last_stmt, stmt.GetGroup().GetStmt(), "group %s\n", stmt.GetGroup().GetTitle())
		case *sysl.Statement_Alt:
			prefix := "alt"
			alt := stmt.GetAlt()
			for j, choice := range alt.GetChoice() {
				last_alt_stmt := last_stmt && j == len(alt.GetChoice())-1
				payload = block(last_alt_stmt, choice.GetStmt(), "%s %s", prefix, choice.GetCond())
				prefix = "else"
			}
			p.w.body.WriteString("end\n")
		case *sysl.Statement_Ret:
			rargs := p.fmtReturnParam(stmt.GetRet().GetPayload())
			fmt.Fprintf(&p.w.body, "%s<--%s : %s\n", p.sender, p.agent, strings.Join(rargs, " | "))
		}
	}

	return payload
}

func generateSequenceDiag(m *sysl.Module, p *sequenceDiagParam) (string, error) {
	out := &sequenceDiagWriter{autogenHeader: true}
	var_names := make([]*varName, 0)
	already_visited := make(map[string]int)

	formatArgs := func(an, pn string) string {
		arg := an
		if len(arg) > 0 && len(pn) > 0 {
			arg += "."
			arg += pn

			conf := "?"
			integ := "?"
			if app, ok := m.GetApps()[an]; ok {
				if t, exist := app.GetTypes()[pn]; exist {
					if c, okConf := t.GetAttrs()["iso_conf"]; okConf {
						if s := c.GetS(); len(s) > 0 {
							conf = strings.ToUpper(s[:1])
						}
					}
					if c, okConf := t.GetAttrs()["iso_integ"]; okConf {
						if s := c.GetS(); len(s) > 0 {
							integ = strings.ToUpper(s[:1])
						}
					}
				}
			}
			isocolor := "green"
			if conf == "R" {
				isocolor = "red"
			}
			arg = fmt.Sprintf("<color blue>%s</color> <<color %s>%s, %s</color>>", arg, isocolor, conf, integ)
		}

		return arg
	}

	fmtReturnParam := func(s string) []string {
		ptns := make([]string, 0)
		if len(s) > 0 {
			re := regexp.MustCompile(`,?(![^{]*\})`)
			rns := re.Split(s, -1)
			for _, rn := range rns {
				ptn := rn
				if strings.Count(rn, "<:") == 1 {
					rex := regexp.MustCompile(`\s*<:\s*`)
					ps := rex.Split(rn, -1)
					if len(ps) == 2 {
						ptn = ps[1]
					}
				}

				if _, ok := sysl.Type_Primitive_value[strings.ToUpper(ptn)]; !ok {
					rex := regexp.MustCompile(`set\s+of\s+(.+)$`)
					if m := rex.FindStringSubmatch(ptn); len(m) > 0 {
						ptn = m[1]
					}
					rex = regexp.MustCompile(`one\s+of\s*{(.+)}$`)
					if m := rex.FindStringSubmatch(ptn); len(m) > 0 {
						rex = regexp.MustCompile(`\s*,\s*`)
						ptns = append(ptns, rex.Split(m[1], -1)...)
					} else {
						ptns = append(ptns, ptn)
					}
				}
			}
		}

		rargs := make([]string, 0, len(ptns))
		for _, ptn := range ptns {
			if !strings.Contains(ptn, "...") && strings.Contains(ptn, ".") {
				aps := strings.Split(ptn, ".")
				if len(aps) > 1 {
					rarg := formatArgs(aps[0], aps[1])
					if len(rarg) > 0 {
						rargs = append(rargs, rarg)
					}
				}
			} else {
				rargs = append(rargs, ptn)
			}
		}
		return rargs
	}

	newVarCreated := func(varname, appname string) {
		apps := m.GetApps()
		if apps == nil {
			return
		}

		app, ok := apps[appname]
		if !ok {
			return
		}

		attrs := app.GetAttrs()

		v := makeVarName(varname)
		v.setCategoryAndAgent(attrs)

		isoctrl := getSortedISOCtrls(attrs)

		v.label = p.appfmt(appname, strings.Join(isoctrl, ", "), attrs)

		var_names = append(var_names, v)
	}

	vm := &varManager{make(map[string]string), newVarCreated}

	out.body.WriteString("skinparam maxMessageSize 250\n")
	if len(p.title) > 0 {
		fmt.Fprintf(&out.body, "title %s\n", p.title)
	}

	appeps := make([]*appEndpoint, 0, len(p.endpoints))
	uptos := make(map[string]interface{}) // use as set
	for _, v := range p.endpoints {
		appep := makeAppEndpoint(v)
		appeps = append(appeps, appep)

		upto := fmt.Sprintf("%s <- %s", appep.appname, appep.epname)
		if _, ok := uptos[upto]; !ok {
			uptos[upto] = nil
		}
	}

	blackboxes := make(map[string]string)
	for _, b := range p.blackboxes {
		switch {
		case len(b) == 1:
			blackboxes[b[0]] = ""
		case len(b) > 1:
			blackboxes[b[0]] = b[1]
		}
	}

	for _, a := range appeps {
		fmt.Fprintf(&out.body, "== %s <- %s ==\n", a.appname, a.epname)

		upto := fmt.Sprintf("%s <- %s", a.appname, a.epname)
		bbs := make(map[string]string)
		for k, v := range blackboxes {
			if _, ok := uptos[k]; (ok && v != upto) || k == a.upto {
				bbs[k] = "see below"
			} else {
				bbs[k] = v
			}
		}
		for k := range already_visited {
			delete(already_visited, k)
		}
		ep := &visitEndpointParam{}
		ep.w = out
		ep.vm = vm
		ep.m = m
		ep.already_visited = already_visited
		ep.uptos = bbs
		ep.fmtArgs = formatArgs
		ep.fmtEndpoint = p.epfmt
		ep.fmtReturnParam = fmtReturnParam
		ep.appname = a.appname
		ep.epname = a.epname
		visitEndpoint(ep)
	}

	sort.Slice(var_names, func(i, j int) bool {
		if var_names[i].category < var_names[j].category {
			return true
		} else if var_names[i].category == var_names[j].category {
			return var_names[i].order < var_names[j].order
		}
		return false
	})
	for _, vn := range var_names {
		fmt.Fprintln(&out.head, vn)
	}

	return out.String(), nil
}
