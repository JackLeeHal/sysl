package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/anz-bank/sysl/src/proto"
	"github.com/sirupsen/logrus"
)

type indentWriter struct {
	bytes.Buffer
	ind      int
	complete bool // if the current position is a complete line
}

func (w *indentWriter) Write(p []byte) (n int, err error) {
	newline := []byte("\n")
	newlines := bytes.Count(p, newline)
	if newlines == 0 {
		if w.complete {
			w.writeIndent()
		}
		n, err = w.Buffer.Write(p)
		w.complete = false
		return n, err
	}

	frags := bytes.SplitN(p, newline, newlines+1)

	for i, frag := range frags {
		if w.complete {
			w.writeIndent()
		}
		nn, err := w.Buffer.Write(frag)
		n += nn
		if err != nil {
			return n, err
		}
		if i+1 < len(frags) {
			if _, err := w.Buffer.Write(newline); err != nil {
				return n, err
			}
			n++
		}
	}
	w.complete = len(frags[len(frags)-1]) == 0
	return n, nil
}

func (w *indentWriter) WriteString(s string) (n int, err error) {
	if !strings.Contains(s, "\n") {
		if w.complete {
			w.writeIndent()
		}
		w.complete = false
		return w.Buffer.WriteString(s)
	}
	return w.Write([]byte(s))
}

func (w *indentWriter) writeIndent() error {
	if !w.complete {
		return nil
	}

	for i := 0; i < w.ind; i++ {
		if err := w.Buffer.WriteByte(' '); err != nil {
			return err
		}
	}

	w.complete = false

	return nil
}

func (w *indentWriter) indent() { w.ind++ }

func (w *indentWriter) unindent() {
	if w.ind == 0 {
		logrus.Warn("seqs: indentWriter unindented too far")
		return
	}
	w.ind--
}

type sequenceDiagWriter struct {
	autogenHeader bool
	head          indentWriter
	body          indentWriter
}

func (w *sequenceDiagWriter) String() string {
	var sb strings.Builder
	if w.autogenHeader {
		fmt.Fprintln(&sb, "''''''''''''''''''''''''''''''''''''''''''")
		fmt.Fprintln(&sb, "''                                      ''")
		fmt.Fprintln(&sb, "''  AUTOGENERATED CODE -- DO NOT EDIT!  ''")
		fmt.Fprintln(&sb, "''                                      ''")
		fmt.Fprintln(&sb, "''''''''''''''''''''''''''''''''''''''''''")
		fmt.Fprintln(&sb)
	}

	fmt.Fprintln(&sb, "@startuml")
	sb.WriteString(w.head.Buffer.String())
	sb.WriteString(w.body.Buffer.String())
	fmt.Fprintln(&sb, "@enduml")

	return sb.String()
}

type SimpleParser struct {
	self string
}

type epFmtParam struct {
	epname, human, human_sender, needs_int, args, patterns, controls string
	attrs                                                            map[string]*sysl.Attribute
}

type SfmtApp = func(appname, controls string, attrs map[string]*sysl.Attribute) string

type SfmtEP = func(p *epFmtParam) string

type sequenceDiagParam struct {
	endpoints   []string
	epfmt       SfmtEP
	appfmt      SfmtApp
	activations bool
	title       string
	blackboxes  [][]string
}

type appEndpoint struct {
	appname, epname, upto string
}

func makeAppEndpoint(s string) *appEndpoint {
	r := regexp.MustCompile(`(?P<appname>.*?)\s*<-\s*(?P<epname>.*?)(?:\s*\[upto\s+(?P<upto>.*)\])*$`)
	match := r.FindStringSubmatch(s)

	out := &appEndpoint{}
	for i, name := range r.SubexpNames() {
		if i > 0 && i <= len(match) {
			switch {
			case name == "appname":
				out.appname = match[i]
			case name == "epname":
				out.epname = match[i]
			case name == "upto":
				out.upto = match[i]
			}
		}
	}
	return out
}

type varName struct {
	category, order       int
	agent, varname, label string
}

func (v *varName) String() string {
	return fmt.Sprintf(`%s "%s" as %s`, v.agent, v.label, v.varname)
}

func (v *varName) setCategoryAndAgent(attrs map[string]*sysl.Attribute) {
	if attrs != nil {
		if patterns, has := attrs["patterns"]; has {
			if x := patterns.GetA(); x != nil {
				for _, y := range x.Elt {
					switch y.GetS() {
					case "human":
						v.category = 0
						v.agent = "actor"
					case "ui":
						v.category = 1
						v.agent = "boundary"
					case "cron":
						v.category = 2
						v.agent = "control"
					case "db":
						v.category = 4
						v.agent = "database"
					case "external":
						v.category = 5
						v.agent = "control"
					}
				}
			}
		}
	}
}

func makeVarName(varname string) *varName {
	i, _ := strconv.Atoi(varname[1:])
	return &varName{3, i, "control", varname, ""}
}

type newVar = func(varname, appname string)

type varManager struct {
	symbols       map[string]string
	newVarCreated newVar
}

func (v *varManager) getOrCreateVar(appname string) string {
	if varname, ok := v.symbols[appname]; ok {
		return varname
	}

	varname := fmt.Sprintf("_%d", len(v.symbols))
	v.newVarCreated(varname, appname)
	v.symbols[appname] = varname

	return varname
}

func getSortedISOCtrls(attrs map[string]*sysl.Attribute) []string {
	s := make([]string, 0)

	reg := regexp.MustCompile("iso_ctrl_(.*)_txt")
	for k := range attrs {
		if !strings.Contains(k, "iso_ctrl") {
			continue
		}
		match := reg.FindStringSubmatch(k)
		if len(match) > 1 {
			s = append(s, match[1])
		}
	}
	sort.Strings(s)
	return s
}

type setS map[string]interface{}

func unionSetS(a, b setS) setS {
	s := make(map[string]interface{})
	for k := range a {
		s[k] = nil
	}
	for k := range b {
		s[k] = nil
	}
	return s
}

func copySetS(a setS) setS {
	s := make(map[string]interface{})
	for k := range a {
		s[k] = nil
	}
	return s
}

func getSortedKeys(s setS) []string {
	a := make([]string, 0, len(s))
	for k := range s {
		a = append(a, k)
	}
	sort.Strings(a)
	return a
}

func getPatternsSet(attrs map[string]*sysl.Attribute) setS {
	s := make(map[string]interface{})
	if patterns, has := attrs["patterns"]; has {
		if x := patterns.GetA(); x != nil {
			for _, y := range x.Elt {
				s[y.GetS()] = nil
			}
		}
	}
	return s
}

type visitParam struct {
	w               *sequenceDiagWriter
	vm              *varManager
	m               *sysl.Module
	already_visited map[string]int
	uptos           map[string]string
	fmtArgs         func(a, b string) string
	fmtEndpoint     SfmtEP
	fmtReturnParam  func(a string) []string
	appname, epname string
}

type visitEndpointParam struct {
	visitParam
	from_app                               *sysl.AppName
	sender_patterns, sender_endpt_patterns setS
	stmt                                   *sysl.Statement
	deactivate                             bool
}

func visitEndpoint(p *visitEndpointParam) string {
	sender := "["
	if p.from_app != nil {
		sender = p.vm.getOrCreateVar(getAppName(p.from_app))
	}

	agent := p.vm.getOrCreateVar(p.appname)
	app, ok := p.m.GetApps()[p.appname]
	if !ok {
		logrus.Warnf("the specified app with name %s does not exist", p.appname)
		return ""
	}
	endpt, ok := app.GetEndpoints()[p.epname]
	if !ok {
		logrus.Warnf("the specified endpoint with name %s does not exist", p.epname)
		return ""
	}

	app_patterns := getPatternsSet(app.GetAttrs())
	target_patterns := getPatternsSet(endpt.GetAttrs())

	patterns := copySetS(target_patterns)

	_, human := app_patterns["human"]
	_, human_sender := p.sender_patterns["human"]
	_, cron := p.sender_patterns["cron"]
	needs_int := sender != agent && !(human || human_sender || cron)

	regL := regexp.MustCompile(`^.*? -> `)
	label := regL.ReplaceAllLiteralString(p.epname, " ⬄ ")

	_, cron = app_patterns["cron"]

	if p.stmt != nil && p.stmt.GetCall() != nil {
		ptrns := ""
		if len(p.sender_endpt_patterns) > 0 || len(patterns) > 0 {
			ptrns = strings.Join(getSortedKeys(p.sender_endpt_patterns), ", ")
			ptrns += " → "
			ptrns += strings.Join(getSortedKeys(patterns), ", ")
		}
		isoctrl := getSortedISOCtrls(endpt.GetAttrs())

		epargs := make([]string, 0)
		for _, v := range endpt.GetParam() {
			if ref_type := v.GetType().GetTypeRef(); ref_type != nil {
				if ref := ref_type.GetRef(); ref != nil {
					an := getAppName(ref.GetAppname())
					pn := strings.Join(ref.GetPath(), ".")
					eparg := p.fmtArgs(an, pn)
					if len(eparg) > 0 {
						epargs = append(epargs, eparg)
					}
				}
			}
		}

		s_epp := &epFmtParam{}
		s_epp.epname = label
		if human {
			s_epp.human = "human"
		}
		if human_sender {
			s_epp.human_sender = "human sender"
		}
		if needs_int {
			s_epp.needs_int = "needs_init"
		}
		s_epp.args = strings.Join(epargs, " | ")
		s_epp.patterns = ptrns
		s_epp.controls = strings.Join(isoctrl, ", ")
		s_epp.attrs = p.stmt.GetAttrs()
		label = p.fmtEndpoint(s_epp)
	}

	if !((human && sender == "[") || cron) {
		ep_patterns := getPatternsSet(endpt.GetAttrs())
		icon := ""
		if _, ok := ep_patterns["cron"]; ok {
			icon = "<&timer>"
		}
		fmt.Fprintf(&p.w.body, "%s->%s : %s%s\n", sender, agent, icon, label)
	}

	rargs := make([]string, 0)
	for _, ep_stmt := range endpt.GetStmt() {
		if stmt_ret := ep_stmt.GetRet(); stmt_ret != nil {
			ret_param := p.fmtReturnParam(stmt_ret.GetPayload())
			rargs = append(rargs, ret_param...)
		}
	}

	payload := strings.Join(rargs, " | ")
	calling_self := p.from_app != nil && getAppName(p.from_app) == p.appname

	if !calling_self && len(payload) == 0 && p.deactivate {
		fmt.Fprintf(&p.w.body, "deactivate %s\n", agent)
	}

	if len(endpt.GetStmt()) > 0 {
		hit_blackbox := false
		for upto, comment := range p.uptos {
			parts := strings.Split(upto, " <- ")
			if len(parts) == 2 && parts[0] == p.appname && parts[1] == p.epname {
				hit_blackbox = true
				if len(comment) == 0 {
					comment = "see below"
				}
				if len(payload) > 0 {
					fmt.Fprintf(&p.w.body, "activate %s\n", agent)
					p.w.body.indent()
					fmt.Fprintf(&p.w.body, "note over %s: %s\n", agent, comment)
					fmt.Fprintf(&p.w.body, "%s<--%s : %s\n", sender, agent, payload)
					p.w.body.unindent()
					fmt.Fprintf(&p.w.body, "deactivate %s\n", agent)
				} else {
					direct := "right"
					if sender > agent {
						direct = "left"
					}
					fmt.Fprintf(&p.w.body, "note %s: %s\n", direct, comment)
				}
				break
			}
		}

		if !hit_blackbox {
			active := !human && !cron
			if active {
				fmt.Fprintf(&p.w.body, "activate %s\n", agent)
			}
			visiting := fmt.Sprintf("%s <- %s", p.appname, p.epname)
			p.already_visited[visiting] += 1
			sp := &visitStmtsParam{}
			sp.w = p.w
			sp.vm = p.vm
			sp.m = p.m
			sp.already_visited = p.already_visited
			sp.uptos = p.uptos
			sp.fmtArgs = p.fmtArgs
			sp.fmtEndpoint = p.fmtEndpoint
			sp.fmtReturnParam = p.fmtReturnParam
			sp.appname = p.appname
			sp.epname = p.epname
			sp.app_patterns = app_patterns
			sp.target_patterns = target_patterns
			sp.deactivate = active
			sp.agent = agent
			sp.sender = sender
			sp.stmts = endpt.GetStmt()
			sp.last_parent_stmt = true
			payload = visitStmts(sp)
			p.already_visited[visiting] -= 1
			if p.already_visited[visiting] == 0 {
				delete(p.already_visited, visiting)
			}
			if active {
				fmt.Fprintf(&p.w.body, "deactivate %s\n", agent)
			}
		}
	}

	return payload
}

type visitStmtsParam struct {
	visitParam
	stmts                        []*sysl.Statement
	deactivate, last_parent_stmt bool
	app_patterns                 setS
	target_patterns              setS
	agent                        string
	sender                       string
}

func visitStmts(p *visitStmtsParam) string {
	block := func(last_stmt bool, block_stmts []*sysl.Statement, fmtStr string, args ...interface{}) string {
		fmt.Fprintf(&p.w.body, fmtStr, args)
		p.w.body.indent()
		sp := &visitStmtsParam{}
		sp.w = p.w
		sp.vm = p.vm
		sp.m = p.m
		sp.already_visited = p.already_visited
		sp.uptos = p.uptos
		sp.fmtArgs = p.fmtArgs
		sp.fmtEndpoint = p.fmtEndpoint
		sp.fmtReturnParam = p.fmtReturnParam
		sp.appname = p.appname
		sp.epname = p.epname
		sp.app_patterns = p.app_patterns
		sp.target_patterns = p.target_patterns
		sp.deactivate = p.deactivate
		sp.agent = p.agent
		sp.sender = p.sender
		sp.stmts = block_stmts
		sp.last_parent_stmt = last_stmt
		ret := visitStmts(sp)
		p.w.body.unindent()
		return ret
	}

	blockWithEnd := func(last_stmt bool, block_stmts []*sysl.Statement, fmtStr string, args ...interface{}) string {
		payload := block(last_stmt, block_stmts, fmtStr, args)
		p.w.body.WriteString("end\n")
		return payload
	}

	payload := ""
	for i, stmt := range p.stmts {
		last_stmt := p.last_parent_stmt && i == len(p.stmts)-1
		stmt_patterns := getPatternsSet(stmt.GetAttrs())
		switch stmt.GetStmt().(type) {
		case *sysl.Statement_Call:
			ep := &visitEndpointParam{}
			ep.w = p.w
			ep.vm = p.vm
			ep.m = p.m
			ep.already_visited = p.already_visited
			ep.uptos = p.uptos
			ep.fmtArgs = p.fmtArgs
			ep.fmtEndpoint = p.fmtEndpoint
			ep.fmtReturnParam = p.fmtReturnParam
			ep.appname = getAppName(stmt.GetCall().GetTarget())
			ep.epname = stmt.GetCall().GetEndpoint()
			ep.from_app = p.m.GetApps()[p.appname].GetName()
			ep.sender_patterns = p.app_patterns
			ep.sender_endpt_patterns = unionSetS(p.target_patterns, stmt_patterns)
			ep.stmt = stmt
			ep.deactivate = last_stmt && p.deactivate

			p.w.body.indent()
			payload = visitEndpoint(ep)
			p.w.body.unindent()
		case *sysl.Statement_Action:
			fmt.Fprintf(&p.w.body, "%s -> %s : %s\n", p.agent, p.agent, stmt.GetAction().GetAction())
		case *sysl.Statement_Cond:
			payload = blockWithEnd(last_stmt, stmt.GetCond().GetStmt(), "opt %s\n", stmt.GetCond().GetTest())
		case *sysl.Statement_Loop:
			loop := stmt.GetLoop()
			payload = blockWithEnd(last_stmt, loop.GetStmt(), "loop %s %s\n", sysl.Loop_Mode_name[int32(loop.GetMode())], loop.GetCriterion())
		case *sysl.Statement_LoopN:
			payload = blockWithEnd(last_stmt, stmt.GetLoopN().GetStmt(), "loop %d times\n", stmt.GetLoopN().GetCount())
		case *sysl.Statement_Foreach:
			payload = blockWithEnd(last_stmt, stmt.GetForeach().GetStmt(), "loop for each %s\n", stmt.GetForeach().GetCollection())
		case *sysl.Statement_Group:
			payload = blockWithEnd(last_stmt, stmt.GetGroup().GetStmt(), "group %s\n", stmt.GetGroup().GetTitle())
		case *sysl.Statement_Alt:
			prefix := "alt"
			alt := stmt.GetAlt()
			for j, choice := range alt.GetChoice() {
				last_alt_stmt := last_stmt && j == len(alt.GetChoice())-1
				payload = block(last_alt_stmt, choice.GetStmt(), "%s %s", prefix, choice.GetCond())
				prefix = "else"
			}
			p.w.body.WriteString("end\n")
		case *sysl.Statement_Ret:
			rargs := p.fmtReturnParam(stmt.GetRet().GetPayload())
			fmt.Fprintf(&p.w.body, "%s<--%s : %s\n", p.sender, p.agent, strings.Join(rargs, " | "))
		}
	}

	return payload
}

func generateSequenceDiag(m *sysl.Module, p *sequenceDiagParam) (string, error) {
	out := &sequenceDiagWriter{autogenHeader: true}
	var_names := make([]*varName, 0)
	already_visited := make(map[string]int)

	formatArgs := func(an, pn string) string {
		arg := an
		if len(arg) > 0 && len(pn) > 0 {
			arg += "."
			arg += pn

			conf := "?"
			integ := "?"
			if app, ok := m.GetApps()[an]; ok {
				if t, exist := app.GetTypes()[pn]; exist {
					if c, okConf := t.GetAttrs()["iso_conf"]; okConf {
						if s := c.GetS(); len(s) > 0 {
							conf = strings.ToUpper(s[:1])
						}
					}
					if c, okConf := t.GetAttrs()["iso_integ"]; okConf {
						if s := c.GetS(); len(s) > 0 {
							integ = strings.ToUpper(s[:1])
						}
					}
				}
			}
			isocolor := "green"
			if conf == "R" {
				isocolor = "red"
			}
			arg = fmt.Sprintf("<color blue>%s</color> <<color %s>%s, %s</color>>", arg, isocolor, conf, integ)
		}

		return arg
	}

	fmtReturnParam := func(s string) []string {
		ptns := make([]string, 0)
		if len(s) > 0 {
			re := regexp.MustCompile(`,?(![^{]*\})`)
			rns := re.Split(s, -1)
			for _, rn := range rns {
				ptn := rn
				if strings.Count(rn, "<:") == 1 {
					rex := regexp.MustCompile(`\s*<:\s*`)
					ps := rex.Split(rn, -1)
					if len(ps) == 2 {
						ptn = ps[1]
					}
				}

				if _, ok := sysl.Type_Primitive_value[strings.ToUpper(ptn)]; !ok {
					rex := regexp.MustCompile(`set\s+of\s+(.+)$`)
					if m := rex.FindStringSubmatch(ptn); len(m) > 0 {
						ptn = m[1]
					}
					rex = regexp.MustCompile(`one\s+of\s*{(.+)}$`)
					if m := rex.FindStringSubmatch(ptn); len(m) > 0 {
						rex = regexp.MustCompile(`\s*,\s*`)
						ptns = append(ptns, rex.Split(m[1], -1)...)
					} else {
						ptns = append(ptns, ptn)
					}
				}
			}
		}

		rargs := make([]string, 0, len(ptns))
		for _, ptn := range ptns {
			if !strings.Contains(ptn, "...") && strings.Contains(ptn, ".") {
				aps := strings.Split(ptn, ".")
				if len(aps) > 1 {
					rarg := formatArgs(aps[0], aps[1])
					if len(rarg) > 0 {
						rargs = append(rargs, rarg)
					}
				}
			} else {
				rargs = append(rargs, ptn)
			}
		}
		return rargs
	}

	newVarCreated := func(varname, appname string) {
		apps := m.GetApps()
		if apps == nil {
			return
		}

		app, ok := apps[appname]
		if !ok {
			return
		}

		attrs := app.GetAttrs()

		v := makeVarName(varname)
		v.setCategoryAndAgent(attrs)

		isoctrl := getSortedISOCtrls(attrs)

		v.label = p.appfmt(appname, strings.Join(isoctrl, ", "), attrs)

		var_names = append(var_names, v)
	}

	vm := &varManager{make(map[string]string), newVarCreated}

	out.body.WriteString("skinparam maxMessageSize 250\n")
	if len(p.title) > 0 {
		fmt.Fprintf(&out.body, "title %s\n", p.title)
	}

	appeps := make([]*appEndpoint, 0, len(p.endpoints))
	uptos := make(map[string]interface{}) // use as set
	for _, v := range p.endpoints {
		appep := makeAppEndpoint(v)
		appeps = append(appeps, appep)

		upto := fmt.Sprintf("%s <- %s", appep.appname, appep.epname)
		if _, ok := uptos[upto]; !ok {
			uptos[upto] = nil
		}
	}

	blackboxes := make(map[string]string)
	for _, b := range p.blackboxes {
		switch {
		case len(b) == 1:
			blackboxes[b[0]] = ""
		case len(b) > 1:
			blackboxes[b[0]] = b[1]
		}
	}

	for _, a := range appeps {
		fmt.Fprintf(&out.body, "== %s <- %s ==\n", a.appname, a.epname)

		upto := fmt.Sprintf("%s <- %s", a.appname, a.epname)
		bbs := make(map[string]string)
		for k, v := range blackboxes {
			if _, ok := uptos[k]; (ok && v != upto) || k == a.upto {
				bbs[k] = "see below"
			} else {
				bbs[k] = v
			}
		}
		for k := range already_visited {
			delete(already_visited, k)
		}
		ep := &visitEndpointParam{}
		ep.w = out
		ep.vm = vm
		ep.m = m
		ep.already_visited = already_visited
		ep.uptos = bbs
		ep.fmtArgs = formatArgs
		ep.fmtEndpoint = p.epfmt
		ep.fmtReturnParam = fmtReturnParam
		ep.appname = a.appname
		ep.epname = a.epname
		visitEndpoint(ep)
	}

	sort.Slice(var_names, func(i, j int) bool {
		if var_names[i].category < var_names[j].category {
			return true
		} else if var_names[i].category == var_names[j].category {
			return var_names[i].order < var_names[j].order
		}
		return false
	})
	for _, vn := range var_names {
		fmt.Fprintln(&out.head, vn)
	}

	return out.String(), nil
}

type arrayFlags []string

// implement the String method of Value interface in flag.go
func (i *arrayFlags) String() string {
	return strings.Join(*i, ",")
}

// implement the Set method of Value interface in flag.go
func (i *arrayFlags) Set(value string) error {
	*i = append(*i, value)
	return nil
}

func loadApp(root string, models []string) *sysl.Module {
	// Model we want to generate seqs for
	var model string
	for _, val := range models {
		model = val
		break
	}
	mod, err := Parse(model, root)
	if err == nil {
		return mod
	}
	logrus.Errorf("unable to load module:\n\troot: " + root + "\n\tmodel:" + model)
	return nil
}

func transformBlackBoxes(blackboxes []*sysl.Attribute) [][]string {
	bbs := [][]string{}
	for _, vals := range blackboxes {
		sub_bbs := []string{}
		for _, val := range vals.GetA().Elt {
			sub_bbs = append(sub_bbs, val.GetS())
		}
		bbs = append(bbs, sub_bbs)
	}

	return bbs
}

func parseBlackBoxesFromArgument(blackboxFlags []string) [][]string {
	bbs := [][]string{}
	for _, blackboxFlag := range blackboxFlags {
		sub_bbs := []string{}
		sub_bbs = append(sub_bbs, strings.Split(blackboxFlag, ",")...)
		bbs = append(bbs, sub_bbs)
	}

	return bbs
}

func (sp *SimpleParser) fmtEp(p *epFmtParam) string {
	initialStr := sp.self
	matchItems := findMatchItems(initialStr)
	for _, item := range matchItems {
		attr := removeWrapper(item)
		var value string
		switch attr {
		case "epname":
			value = p.epname
		case "human":
			value = p.human
		case "human_sender":
			value = p.human_sender
		case "needs_int":
			value = p.needs_int
		case "args":
			value = p.args
		case "patterns":
			value = p.patterns
		case "controls":
			value = p.controls
		default:
			value = p.attrs[attr].GetS()
		}
		initialStr = strings.Replace(initialStr, item, value, 1)
	}

	return removePercentSymbol(initialStr)
}

func (sp *SimpleParser) fmtApp(appname, controls string, attrs map[string]*sysl.Attribute) string {
	initialStr := sp.self
	matchItems := findMatchItems(initialStr)
	for _, item := range matchItems {
		attr := removeWrapper(item)
		var value string
		switch attr {
		case "appname":
			value = appname
		case "controls":
			value = controls
		default:
			value = attrs[attr].GetS()
		}
		initialStr = strings.Replace(initialStr, item, value, 1)
	}

	return removePercentSymbol(initialStr)
}

func (sp *SimpleParser) fmtSeq(epname, eplongname string, attrs map[string]*sysl.Attribute) string {
	initialStr := sp.self
	matchItems := findMatchItems(initialStr)
	for _, item := range matchItems {
		attr := removeWrapper(item)
		var value string
		switch attr {
		case "epname":
			value = epname
		case "eplongname":
			value = eplongname
		default:
			value = attrs[attr].GetS()
		}
		initialStr = strings.Replace(initialStr, item, value, 1)
	}

	return removePercentSymbol(initialStr)
}

func (sp *SimpleParser) fmtOutput(appname, epname, eplongname string, attrs map[string]*sysl.Attribute) string {
	initialStr := sp.self
	matchItems := findMatchItems(initialStr)

	for _, item := range matchItems {
		attr := removeWrapper(item)
		var value string
		switch attr {
		case "appname":
			value = appname
		case "epname":
			value = epname
		case "eplongname":
			value = eplongname
		default:
			value = attrs[attr].GetS()
		}
		initialStr = strings.Replace(initialStr, item, value, 1)
	}

	return removePercentSymbol(initialStr)
}

func findMatchItems(origin string) []string {
	re := regexp.MustCompile(`(%\(\w+\))`)
	return re.FindAllString(origin, -1)
}

func removeWrapper(origin string) string {
	replaced := strings.Replace(origin, "%(", "", 1)
	replaced = strings.Replace(replaced, ")", "", 1)
	return replaced
}

func removePercentSymbol(origin string) string {
	return strings.Replace(origin, "%", "", -1)
}

func constructSimpleParser(former, latter string) *SimpleParser {
	fmtstr := former
	if former == "" {
		fmtstr = latter
	}

	return &SimpleParser{self: fmtstr}
}

func mergeAttributes(app, edpnt map[string]*sysl.Attribute) map[string]*sysl.Attribute {
	result := make(map[string]*sysl.Attribute)
	for k, v := range app {
		result[k] = v
	}
	for k, v := range edpnt {
		result[k] = v
	}

	return result
}

func DoConstructSequenceDiagrams(root_model, endpoint_format, app_format, title, plantuml, filter, output string,
	no_activations, verbose, expire_cache, dry_run bool,
	endpoints, apps, modules []string, blackboxes [][]string) {
	mod := loadApp(root_model, modules)
	syslSdFilters, exists := os.LookupEnv("SYSL_SD_FILTERS")
	epFilters := []string{}
	if exists {
		epFilters = append(epFilters, strings.Split(syslSdFilters, ",")...)
	} else {
		epFilters = append(epFilters, "*")
	}

	if strings.Contains(output, "%(epname)") {
		spout := &SimpleParser{self: output}
		for _, appName := range apps {
			app := mod.Apps[appName]
			bbs := transformBlackBoxes(app.GetAttrs()["blackboxes"].GetA().GetElt())
			spseqtitle := constructSimpleParser(app.GetAttrs()["seqtitle"].GetS(), title)
			spep := constructSimpleParser(app.GetAttrs()["epfmt"].GetS(), endpoint_format)
			spapp := constructSimpleParser(app.GetAttrs()["appfmt"].GetS(), app_format)
			keys := []string{}
			for k := range app.GetEndpoints() {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			for _, k := range keys {
				is_continue := false
				for _, filt := range epFilters {
					logrus.Warn(filt)
				}

				if is_continue {
					continue
				}

				epAttrs := app.GetEndpoints()[k].GetAttrs()
				output_dir := spout.fmtOutput(appName, k, app.GetEndpoints()[k].GetLongName(), epAttrs)
				bbs2 := transformBlackBoxes(app.GetEndpoints()[k].GetAttrs()["blackboxes"].GetA().GetElt())
				varrefs := mergeAttributes(app.GetAttrs(), app.GetEndpoints()[k].GetAttrs())
				sdEndpoints := []string{}
				statements := app.GetEndpoints()[k].GetStmt()
				for _, stmt := range statements {
					parts := stmt.GetCall().GetTarget().GetPart()
					ep := stmt.GetCall().GetEndpoint()
					sdEndpoints = append(sdEndpoints, strings.Join(parts, " :: ")+" <- "+ep)
				}

				sd := &sequenceDiagParam{
					endpoints:   sdEndpoints,
					epfmt:       SfmtEP(spep.fmtEp),
					appfmt:      SfmtApp(spapp.fmtApp),
					activations: no_activations,
					title:       spseqtitle.fmtSeq(app.GetEndpoints()[k].GetName(), app.GetEndpoints()[k].GetLongName(), varrefs),
					blackboxes:  append(bbs, bbs2...),
				}
				out, _ := generateSequenceDiag(mod, sd)
				OutputPlantuml(output_dir, plantuml, out)
			}
		}
	} else {
		if endpoints == nil {
			return
		}
		spep := constructSimpleParser("", endpoint_format)
		spapp := constructSimpleParser("", app_format)
		sd := &sequenceDiagParam{
			endpoints:   endpoints,
			epfmt:       SfmtEP(spep.fmtEp),
			appfmt:      SfmtApp(spapp.fmtApp),
			activations: no_activations,
			title:       title,
			blackboxes:  blackboxes,
		}
		out, _ := generateSequenceDiag(mod, sd)
		OutputPlantuml(output, plantuml, out)
	}
}

// DoGenerateSequenceDiagrams generate sequence diagrams for the given model
func DoGenerateSequenceDiagrams(stdout, stderr io.Writer, flags *flag.FlagSet, args []string) int {
	var endpoints_flag, apps_flag, blackboxes_flag, modules_flag arrayFlags
	root_model := flags.String("root-model", ".", "sysl root directory for input model file (default: .)")
	flags.Var(&endpoints_flag, "endpoint", "Include endpoint in sequence diagram")
	flags.Var(&apps_flag, "app", "Include all endpoints for app in sequence diagram (currently "+
		"only works with templated --output). Use SYSL_SD_FILTERS env (a "+
		"comma-list of shell globs) to limit the diagrams generated")
	no_activations := flags.Bool("no-activations", true, "Suppress sequence diagram activation bars(default: true)")
	endpoint_format := flags.String("endpoint_format", "%(epname)", "Specify the format string for sequence diagram endpoints. "+
		"May include %%(epname), %%(eplongname) and %%(@foo) for attribute foo(default: %(epname))")
	app_format := flags.String("app_format", "%(appname)", "Specify the format string for sequence diagram participants. "+
		"May include %%(appname) and %%(@foo) for attribute foo(default: %(appname))")
	flags.Var(&blackboxes_flag, "blackbox", "Apps to be treated as black boxes")
	title := flags.String("title", "", "diagram title")
	plantuml := flags.String("plantuml", "", strings.Join([]string{"base url of plantuml server",
		"(default: $SYSL_PLANTUML or http://localhost:8080/plantuml",
		"see http://plantuml.com/server.html#install for more info)"}, "\n"))
	verbose := flags.Bool("verbose", false, "Report each output(default: false)")
	expire_cache := flags.Bool("expire-cache", false, "Expire cache entries to force checking against real destination(default: false)")
	dry_run := flags.Bool("dry-run", false, "Don't perform confluence uploads, but show what would have happened(default: false)")
	filter := flags.String("filter", "", "Only generate diagrams whose output paths match a pattern")
	flags.Var(&modules_flag, "modules", strings.Join([]string{"input files without .sysl extension and with leading /",
		"eg: /project_dir/my_models",
		"combine with --root if needed"}, "\n"))
	output := flags.String("output", "%(epname).png", "output file(default: %(epname).png)")

	flags.Parse(args[1:])
	logrus.Warnf("root_model: %s\n", *root_model)
	logrus.Warnf("endpoints: %v\n", endpoints_flag)
	logrus.Warnf("app: %v\n", apps_flag)
	logrus.Warnf("no_activations: %t\n", *no_activations)
	logrus.Warnf("endpoint_format: %s\n", *endpoint_format)
	logrus.Warnf("app_format: %s\n", *app_format)
	logrus.Warnf("blackbox: %s\n", blackboxes_flag)
	logrus.Warnf("title: %s\n", *title)
	logrus.Warnf("plantuml: %s\n", *plantuml)
	logrus.Warnf("verbose: %t\n", *verbose)
	logrus.Warnf("expire_cache: %t\n", *expire_cache)
	logrus.Warnf("dry_run: %t\n", *dry_run)
	logrus.Warnf("filter: %s\n", *filter)
	logrus.Warnf("modules: %s\n", modules_flag)
	logrus.Warnf("output: %s\n", *output)

	DoConstructSequenceDiagrams(*root_model, *endpoint_format, *app_format, *title, *plantuml, *filter, *output, *no_activations,
		*verbose, *expire_cache, *dry_run, endpoints_flag, apps_flag, modules_flag, parseBlackBoxesFromArgument(blackboxes_flag))

	return 0
}
