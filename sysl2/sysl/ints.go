package main

import (
	"fmt"
	"github.com/anz-bank/sysl/src/proto"
	"strings"
)

type AppElement struct {
	Name     string
	Endpoint string
}

type AppDependency struct {
	Self   *AppElement
	Target *AppElement
}

func MakeAppDependency(self, target *AppElement) *AppDependency {
	return &AppDependency{self, target}
}

func MakeAppElement(name, endpoint string) *AppElement {
	return &AppElement{name, endpoint}
}

type IntsParam struct {
	apps         []string
	highlights   []string
	integrations []*AppDependency
	app          *sysl.Application
	endpt        *sysl.Endpoint
}

type Args struct {
	title     string
	project   string
	clustered bool
	epa       bool
}

type IntsDiagramVisitor struct {
	m       *sysl.Module
	symbols map[string]*_var
}

type _var struct {
	order int
	label string
	alias string
}

func MakeIntsDiagramVisitor(m *sysl.Module) *IntsDiagramVisitor {
	return &IntsDiagramVisitor{
		m:       m,
		symbols: make(map[string]*_var),
	}
}

func VarManagerForComponent(v *IntsDiagramVisitor, appName string, sb *strings.Builder, highlights []string) string {
	if s, ok := v.symbols[appName]; ok {
		return s.alias
	}

	i := len(v.symbols)
	alias := fmt.Sprintf("_%d", i)
	//TODO Deal with format
	label := appName
	s := &_var{
		order: i,
		label: label,
		alias: alias,
	}
	v.symbols[appName] = s
	r := fmt.Sprintf("[%s] as %s", appName, alias)
	for _, v := range highlights {
		if v == appName {
			r += " <<highlight>>"
		}
	}
	fmt.Fprintln(sb, r)
	return s.alias
}

func GenerateView(args *Args, params *IntsParam, mod *sysl.Module) string {
	visitor := MakeIntsDiagramVisitor(mod)
	restrictBy := ""
	if params.endpt.Attrs["restrict_by"] != nil {
		restrictBy = params.endpt.Attrs["restrict_by"].GetS()
	}

	appAttrs := params.app.Attrs
	endptAttrs := params.endpt.Attrs
	highLightColor := appAttrs["highlight_color"].GetS()
	arrowColor := appAttrs["arrow_color"].GetS()
	indirectArrowColor := appAttrs["indirect_arrow_color"].GetS()

	diagramTitle := ""
	if appAttrs["title"].GetS() != "" {
		diagramTitle = appAttrs["title"].GetS()
		//TODO(Jack) fmt title with appAttrs["title"]
	} else {
		//TODO(Jack) fmt title with args.title
	}

	var sb strings.Builder
	if args.epa || endptAttrs["view"].GetS() == "epa" {
		//TODO generate state view
		fmt.Fprintln(&sb, "''''''''''''''''''''''''''''''''''''''''''")
		fmt.Fprintln(&sb, "''                                      ''")
		fmt.Fprintln(&sb, "''  AUTOGENERATED CODE -- DO NOT EDIT!  ''")
		fmt.Fprintln(&sb, "''                                      ''")
		fmt.Fprintln(&sb, "''''''''''''''''''''''''''''''''''''''''''")
		fmt.Fprintln(&sb)

		fmt.Fprintln(&sb, "@startuml")
		if diagramTitle != "" {
			fmt.Fprintln(&sb, "title "+diagramTitle)
		}
		fmt.Fprintln(&sb, "left to right direction")
		fmt.Fprintln(&sb, "scale max 16384 height")
		fmt.Fprintln(&sb, "hide empty description")
		fmt.Fprintln(&sb, "skinparam state {")
		fmt.Fprintln(&sb, "  BackgroundColor FloralWhite")
		fmt.Fprintln(&sb, "  BorderColor Black")
		fmt.Fprintln(&sb, "  ArrowColor Crimson")
		if highLightColor != "" {
			fmt.Fprintln(&sb, "  BackgroundColor<<highlight>> "+highLightColor)
		}
		if arrowColor != "" {
			fmt.Fprintln(&sb, "  ArrowColor "+arrowColor)
		}

		if indirectArrowColor != "" && indirectArrowColor != "none" {
			fmt.Fprintln(&sb, "  ArrowColor<<indirect>> "+indirectArrowColor)
			fmt.Fprintln(&sb, "  ArrowColor<<internal>> "+indirectArrowColor)
		}
		fmt.Fprintln(&sb, "}")
		for _, v := range params.integrations {
			if restrictBy != "" && !stringInSlice(restrictBy, getMapKeys(mod.Apps[v.Self.Name].Attrs)) && !stringInSlice(restrictBy, getMapKeys(mod.Apps[v.Target.Name].Attrs)) {
				continue
			}
		}

	} else {
		fmt.Fprintln(&sb, "''''''''''''''''''''''''''''''''''''''''''")
		fmt.Fprintln(&sb, "''                                      ''")
		fmt.Fprintln(&sb, "''  AUTOGENERATED CODE -- DO NOT EDIT!  ''")
		fmt.Fprintln(&sb, "''                                      ''")
		fmt.Fprintln(&sb, "''''''''''''''''''''''''''''''''''''''''''")
		fmt.Fprintln(&sb)

		fmt.Fprintln(&sb, "@startuml")
		fmt.Fprintln(&sb, "hide stereotype")
		fmt.Fprintln(&sb, "scale max 16384 height")
		fmt.Fprintln(&sb, "skinparam component {")
		fmt.Fprintln(&sb, "  BackgroundColor FloralWhite")
		fmt.Fprintln(&sb, "  BorderColor Black")
		fmt.Fprintln(&sb, "  ArrowColor Crimson")
		if highLightColor != "" {
			fmt.Fprintln(&sb, "  BackgroundColor<<highlight>> "+highLightColor)
		}
		if arrowColor != "" {
			fmt.Fprintln(&sb, "  ArrowColor "+arrowColor)
		}

		if indirectArrowColor != "" && indirectArrowColor != "none" {
			fmt.Fprintln(&sb, "  ArrowColor<<indirect>> "+indirectArrowColor)
		}
		fmt.Fprintln(&sb, "}")

		if args.clustered || endptAttrs["view"].GetS() == "clustered" {
			clusters := make(map[string][]string)
			for _, v := range params.apps {
				cluster := strings.Split(v, " :: ")
				if len(cluster) != 0 {
					if len(clusters[cluster[0]]) != 0 {
						clusters[cluster[0]] = append(clusters[cluster[0]], cluster[1])
					} else {
						clusters[cluster[0]] = []string{cluster[1]}
					}
				}
			}
			for k, v := range clusters {
				if len(v) <= 1 {
					delete(clusters, k)
				}
			}
			nameMap := make(map[string]string)
			for _, v := range clusters {
				for _, s := range v {
					nameMap[s] = strings.Split(s, " :: ")[1]
				}
			}
			for k, v := range clusters {
				fmt.Fprintf(&sb, "package \"%s\" {", k)
				for _, n := range v {
					appName := strings.Split(n, " :: ")[1]
					VarManagerForComponent(visitor, appName, &sb, params.highlights)
				}
				fmt.Fprintln(&sb, "}")
			}
		}
		var callsDrawn [][]string
		if endptAttrs["view"].GetS() == "system" {
			for _, v := range params.integrations {
				appA := v.Self.Name
				appB := v.Target.Name
				apps := []string{appA, appB}
				var direct []string
				for _, v := range params.highlights {
					if v == appA {
						direct = append(direct, appA)
					}
					if v == appB {
						direct = append(direct, appB)
					}
				}
				appA = strings.Split(appA, " :: ")[0]
				appB = strings.Split(appB, " :: ")[0]
				if appA != appB && !sliceInArray(apps, callsDrawn) && !sliceInArray(apps, callsDrawn) {
					if direct != nil || indirectArrowColor != "none" {
						indirect := ""
						if direct == nil {
							indirect = " <<indirect>>"
						}
						fmt.Fprintf(&sb, "%s --> %s%s", VarManagerForComponent(visitor, appA, &sb, params.highlights), VarManagerForComponent(visitor, appB, &sb, params.highlights), indirect)
						fmt.Fprintln(&sb)
						callsDrawn = append(callsDrawn, apps)
					}
				}
			}

		} else {
			for _, v := range params.integrations {
				appA := v.Self.Name
				appB := v.Target.Name
				apps := []string{appA, appB}
				var direct []string
				for _, v := range params.highlights {
					if v == appA {
						direct = append(direct, appA)
					}
					if v == appB {
						direct = append(direct, appB)
					}
				}
				if appA != appB && !sliceInArray(apps, callsDrawn) && !sliceInArray(apps, callsDrawn) {
					if direct != nil || indirectArrowColor != "none" {
						indirect := ""
						if direct == nil {
							indirect = " <<indirect>>"
						}
						fmt.Fprintf(&sb, "%s --> %s%s", VarManagerForComponent(visitor, appA, &sb, params.highlights), VarManagerForComponent(visitor, appB, &sb, params.highlights), indirect)
						fmt.Fprintln(&sb)
						callsDrawn = append(callsDrawn, apps)
					}
				}
			}
			for _, v := range params.apps {
				for _, mixin := range mod.Apps[v].GetMixin2() {
					mixinName := strings.Join(mixin.Name.Part, " :: ")
					fmt.Fprintf(&sb, "%s <|.. %s", VarManagerForComponent(visitor, mixinName, &sb, params.highlights), VarManagerForComponent(visitor, v, &sb, params.highlights))
					fmt.Fprintln(&sb)
				}
			}
		}

		return sb.String()
	}
	return ""
}

func sliceInArray(a []string, list [][]string) bool {
	if list == nil {
		return false
	}
	for _, b := range list {
		for i := range b {
			if a[i] != b[i] {
				return false
			}
		}
	}
	return true
}

func stringInSlice(a string, list []string) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}

func getMapKeys(mymap map[string]*sysl.Attribute) []string {
	keys := make([]string, 0, len(mymap))
	for k := range mymap {
		keys = append(keys, k)
	}
	return keys
}
