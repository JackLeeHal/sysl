package ints

import (
	"fmt"
	"github.com/anz-bank/sysl/src/proto"
	"strings"
)

type AppElement struct {
	Name     string
	Endpoint string
}

type AppDependency struct {
	Self   *AppElement
	Target *AppElement
}

func MakeAppDependency(self, target *AppElement) *AppDependency {
	return &AppDependency{self, target}
}

func MakeAppElement(name, endpoint string) *AppElement {
	return &AppElement{name, endpoint}
}

type IntsParam struct {
	apps         []string
	highlights   map[string]struct{}
	integrations []*AppDependency
	app          *sysl.Application
	endpt        *sysl.Endpoint
}

type Args struct {
	title     string
	project   string
	clustered bool
	epa       bool
}

type IntsDiagramVisitor struct {
	m          *sysl.Module
	symbols    map[string]*_var
	topSymbols map[string]*_topVar
}

type _var struct {
	label string
	alias string
}

type _topVar struct {
	topLabel string
	topAlias string
}

func MakeIntsDiagramVisitor(m *sysl.Module) *IntsDiagramVisitor {
	return &IntsDiagramVisitor{
		m:          m,
		symbols:    make(map[string]*_var),
		topSymbols: make(map[string]*_topVar),
	}
}

func VarManagerForComponent(v *IntsDiagramVisitor, appName string, sb *strings.Builder, highlights map[string]struct{}) string {
	if s, ok := v.symbols[appName]; ok {
		return s.alias
	}

	i := len(v.symbols)
	alias := fmt.Sprintf("_%d", i)
	//TODO Deal with format
	label := appName
	s := &_var{
		label: label,
		alias: alias,
	}
	v.symbols[appName] = s
	r := fmt.Sprintf("[%s] as %s", appName, alias)
	if _, ok := highlights[appName]; ok {
		r += " <<highlight>>"
	}
	fmt.Fprintln(sb, r)
	return s.alias
}

func VarManagerForState(v *IntsDiagramVisitor, appName string, sb *strings.Builder, highlights map[string]struct{}, isTopLevel bool) string {
	var name, alias, label string
	if isTopLevel {
		name = appName
		if ts, ok := v.topSymbols[name]; ok {
			return ts.topAlias
		}
		i := len(v.topSymbols)
		alias = fmt.Sprintf("_%d", i)
		//TODO Deal with format
		label = name
		ts := &_topVar{
			topLabel: label,
			topAlias: alias,
		}
		v.topSymbols[name] = ts
		r := ""
		if _, ok := highlights[name]; ok {
			r = fmt.Sprintf("state \"%s\" as X%s <<highlight>> {", name, alias)
		} else {
			r = fmt.Sprintf("state \"%s\" as X%s {", name, alias)
		}
		fmt.Fprintln(sb, r)

		return ts.topAlias
	} else {
		name = strings.Split(appName, " : ")[1]
		if s, ok := v.symbols[name]; ok {
			return s.alias
		}
		i := len(v.symbols)
		alias = fmt.Sprintf("_%d", i)
		//TODO Deal with format
		label = name
		s := &_var{
			label: label,
			alias: alias,
		}
		v.symbols[name] = s
		r := fmt.Sprintf("  state \"%s\" as %s", name, alias)
		if _, ok := highlights[name]; ok {
			r += " <<highlight>>"
		}
		fmt.Fprintln(sb, r)
		return s.alias
	}
}

func GenerateView(args *Args, params *IntsParam, mod *sysl.Module) string {
	visitor := MakeIntsDiagramVisitor(mod)
	restrictBy := ""
	if params.endpt.Attrs["restrict_by"] != nil {
		restrictBy = params.endpt.Attrs["restrict_by"].GetS()
	}

	appAttrs := params.app.Attrs
	endptAttrs := params.endpt.Attrs
	highLightColor := appAttrs["highlight_color"].GetS()
	arrowColor := appAttrs["arrow_color"].GetS()
	indirectArrowColor := appAttrs["indirect_arrow_color"].GetS()

	diagramTitle := ""
	if appAttrs["title"].GetS() != "" {
		diagramTitle = appAttrs["title"].GetS()
		//TODO(Jack) fmt title with appAttrs["title"]
	} else {
		//TODO(Jack) fmt title with args.title
	}

	var sb strings.Builder
	if args.epa || endptAttrs["view"].GetS() == "epa" {

		fmt.Fprintln(&sb, "''''''''''''''''''''''''''''''''''''''''''")
		fmt.Fprintln(&sb, "''                                      ''")
		fmt.Fprintln(&sb, "''  AUTOGENERATED CODE -- DO NOT EDIT!  ''")
		fmt.Fprintln(&sb, "''                                      ''")
		fmt.Fprintln(&sb, "''''''''''''''''''''''''''''''''''''''''''")
		fmt.Fprintln(&sb)

		fmt.Fprintln(&sb, "@startuml")
		if diagramTitle != "" {
			fmt.Fprintln(&sb, "title "+diagramTitle)
		}
		fmt.Fprintln(&sb, "left to right direction")
		fmt.Fprintln(&sb, "scale max 16384 height")
		fmt.Fprintln(&sb, "hide empty description")
		fmt.Fprintln(&sb, "skinparam state {")
		fmt.Fprintln(&sb, "  BackgroundColor FloralWhite")
		fmt.Fprintln(&sb, "  BorderColor Black")
		fmt.Fprintln(&sb, "  ArrowColor Crimson")
		if highLightColor != "" {
			fmt.Fprintln(&sb, "  BackgroundColor<<highlight>> "+highLightColor)
		}
		if arrowColor != "" {
			fmt.Fprintln(&sb, "  ArrowColor "+arrowColor)
		}

		if indirectArrowColor != "" && indirectArrowColor != "none" {
			fmt.Fprintln(&sb, "  ArrowColor<<indirect>> "+indirectArrowColor)
			fmt.Fprintln(&sb, "  ArrowColor<<internal>> "+indirectArrowColor)
		}
		fmt.Fprintln(&sb, "}")

		clusters := map[string][]string{}
		for _, v := range params.integrations {
			appA := v.Self.Name
			appB := v.Target.Name
			epA := v.Self.Endpoint
			epB := v.Target.Endpoint
			if _, ok := mod.Apps[appA].Attrs[restrictBy]; !ok && restrictBy != "" {
				if _, ok := mod.Apps[appB].Attrs[restrictBy]; !ok {
					continue
				}
			}
			if restrictBy != "" && !stringInSlice(restrictBy, getMapKeys(mod.Apps[appA].Endpoints[epA].Attrs)) && !stringInSlice(restrictBy, getMapKeys(mod.Apps[appB].Endpoints[epB].Attrs)) {
				continue
			}
			clusters[appA] = append(clusters[appA], epA)
			if appA != appB && !mod.Apps[appA].Endpoints[epA].IsPubsub {
				clusters[appA] = append(clusters[appA], epB+" client")
			}
			clusters[appB] = append(clusters[appB], epB)
		}

		for k, v := range clusters {
			clusters[k] = deleteDuplicates(v)
		}

		for k, v := range clusters {
			VarManagerForState(visitor, k, &sb, params.highlights, true)
			for _, m := range v {
				VarManagerForState(visitor, k+" : "+m, &sb, params.highlights, false)
			}
			fmt.Fprintln(&sb, "}")
		}

		var processed []string
		for _, v := range params.integrations {
			appA := v.Self.Name
			appB := v.Target.Name
			epA := v.Self.Endpoint
			epB := v.Target.Endpoint
			if restrictBy != "" && !stringInSlice(restrictBy, getMapKeys(mod.Apps[appA].Attrs)) && !stringInSlice(restrictBy, getMapKeys(mod.Apps[appB].Attrs)) {
				continue
			}
			if restrictBy != "" && !stringInSlice(restrictBy, getMapKeys(mod.Apps[appA].Endpoints[epA].Attrs)) && !stringInSlice(restrictBy, getMapKeys(mod.Apps[appB].Endpoints[epB].Attrs)) {
				continue
			}
			matchApp := appB
			matchEp := epB
			label := ""
			//needsInt := appA != matchApp

			var pubSubSrcPtrns []string
			if mod.Apps[appA].Endpoints[epA].Attrs["patterns"] != nil {
				for _, v := range mod.Apps[appA].Endpoints[epA].Attrs["patterns"].GetA().Elt {
					pubSubSrcPtrns = append(pubSubSrcPtrns, v.GetS())
				}
			}

			var tgtPtrns []string
			if mod.Apps[matchApp].Endpoints[matchEp].Attrs != nil {
				for _, v := range mod.Apps[matchApp].Endpoints[matchEp].Attrs["patterns"].GetA().Elt {
					tgtPtrns = append(tgtPtrns, v.GetS())
				}
			}
			if mod.Apps[matchApp].Attrs["patterns"] != nil {
				for _, v := range mod.Apps[matchApp].Attrs["patterns"].GetA().Elt {
					tgtPtrns = append(tgtPtrns, v.GetS())
				}
			}

			calls := []*sysl.Call{}
			makeCalls(mod.Apps[appA].Endpoints[epA].Stmt, calls)
			for _, stmt := range mod.Apps[appA].Endpoints[epA].Stmt {
				appBName := strings.Join(stmt.GetCall().GetTarget().GetPart(), " :: ")
				if matchApp == appBName && matchEp == stmt.GetCall().Endpoint {
					fmtVars := stmt.GetAttrs()
					var srcPtrns []string
					if fmtVars != nil {
						for _, v := range fmtVars {
							srcPtrns = append(srcPtrns, v.GetS())
						}
					} else {
						srcPtrns = pubSubSrcPtrns
					}
					//var ptrns string
					//if srcPtrns != nil && tgtPtrns != nil {
					//	ptrns = strings.Join(srcPtrns, ", ") + " â†’ " + strings.Join(tgtPtrns, ", ")
					//} else {
					//	ptrns = ""
					//}
					// TODO label fmt
					//  label = diagutil.parse_fmt(app.attrs["epfmt"].s)(
					//  needs_int=needs_int, patterns=ptrns, **fmt_vars)
				}
			}

			flow := strings.Join([]string{appA, epB, appB, epB}, ".")
			isPubSub := mod.Apps[appA].Endpoints[epA].GetIsPubsub()
			epBClient := epB + " client"

			if appA != appB {
				if isPubSub {
					if label != "" {
						label = " : " + label
					}
					fmt.Fprintf(&sb, "%s -%s> %s%s", VarManagerForState(visitor, appA+" : "+epA, &sb, params.highlights, false), "[#blue]", VarManagerForState(visitor, appB+" : "+epB, &sb, params.highlights, false), label)
				} else {
					color := ""
					if indirectArrowColor == "" {
						color = "[#silver]-"
					} else {
						color = "[#" + indirectArrowColor + "]-"
					}
					fmt.Fprintf(&sb, "%s -%s> %s", VarManagerForState(visitor, appA+" : "+epA, &sb, params.highlights, false), color, VarManagerForState(visitor, appA+" : "+epBClient, &sb, params.highlights, false))
					if !stringInSlice(flow, processed) {
						fmt.Fprintf(&sb, "%s -%s> %s%s", VarManagerForState(visitor, appA+" : "+epBClient, &sb, params.highlights, false), "[#black]", VarManagerForState(visitor, appB+" : "+epB, &sb, params.highlights, false), label)
						processed = append(processed, flow)
					}
				}
			} else {
				color := ""
				if indirectArrowColor == "" {
					color = "[#silver]-"
				} else {
					color = "[#" + indirectArrowColor + "]-"
				}
				fmt.Fprintf(&sb, "%s -%s> %s%s", VarManagerForState(visitor, appA+" : "+epA, &sb, params.highlights, false), color, VarManagerForState(visitor, appB+" : "+epB, &sb, params.highlights, false), label)
				fmt.Fprintln(&sb)
			}
		}
		return sb.String()

	} else {
		fmt.Fprintln(&sb, "''''''''''''''''''''''''''''''''''''''''''")
		fmt.Fprintln(&sb, "''                                      ''")
		fmt.Fprintln(&sb, "''  AUTOGENERATED CODE -- DO NOT EDIT!  ''")
		fmt.Fprintln(&sb, "''                                      ''")
		fmt.Fprintln(&sb, "''''''''''''''''''''''''''''''''''''''''''")
		fmt.Fprintln(&sb)

		fmt.Fprintln(&sb, "@startuml")
		fmt.Fprintln(&sb, "hide stereotype")
		fmt.Fprintln(&sb, "scale max 16384 height")
		fmt.Fprintln(&sb, "skinparam component {")
		fmt.Fprintln(&sb, "  BackgroundColor FloralWhite")
		fmt.Fprintln(&sb, "  BorderColor Black")
		fmt.Fprintln(&sb, "  ArrowColor Crimson")
		if highLightColor != "" {
			fmt.Fprintln(&sb, "  BackgroundColor<<highlight>> "+highLightColor)
		}
		if arrowColor != "" {
			fmt.Fprintln(&sb, "  ArrowColor "+arrowColor)
		}

		if indirectArrowColor != "" && indirectArrowColor != "none" {
			fmt.Fprintln(&sb, "  ArrowColor<<indirect>> "+indirectArrowColor)
		}
		fmt.Fprintln(&sb, "}")

		if args.clustered || endptAttrs["view"].GetS() == "clustered" {
			clusters := make(map[string][]string)
			for _, v := range params.apps {
				cluster := strings.Split(v, " :: ")
				if len(cluster) != 0 {
					if len(clusters[cluster[0]]) != 0 {
						clusters[cluster[0]] = append(clusters[cluster[0]], cluster[1])
					} else {
						clusters[cluster[0]] = []string{cluster[1]}
					}
				}
			}
			for k, v := range clusters {
				if len(v) <= 1 {
					delete(clusters, k)
				}
			}
			nameMap := make(map[string]string)
			for _, v := range clusters {
				for _, s := range v {
					nameMap[s] = strings.Split(s, " :: ")[1]
				}
			}
			for k, v := range clusters {
				fmt.Fprintf(&sb, "package \"%s\" {", k)
				for _, n := range v {
					appName := strings.Split(n, " :: ")[1]
					VarManagerForComponent(visitor, appName, &sb, params.highlights)
				}
				fmt.Fprintln(&sb, "}")
			}
		}
		var callsDrawn [][]string
		if endptAttrs["view"].GetS() == "system" {
			for _, v := range params.integrations {
				appA := v.Self.Name
				appB := v.Target.Name
				apps := []string{appA, appB}
				var direct []string
				if _, ok := params.highlights[appA]; ok {
					direct = append(direct, appA)
				}
				if _, ok := params.highlights[appB]; ok {
					direct = append(direct, appB)
				}
				appA = strings.Split(appA, " :: ")[0]
				appB = strings.Split(appB, " :: ")[0]
				if appA != appB && !sliceInArray(apps, callsDrawn) && !sliceInArray(apps, callsDrawn) {
					if direct != nil || indirectArrowColor != "none" {
						indirect := ""
						if direct == nil {
							indirect = " <<indirect>>"
						}
						fmt.Fprintf(&sb, "%s --> %s%s", VarManagerForComponent(visitor, appA, &sb, params.highlights), VarManagerForComponent(visitor, appB, &sb, params.highlights), indirect)
						fmt.Fprintln(&sb)
						callsDrawn = append(callsDrawn, apps)
					}
				}
			}

		} else {
			for _, v := range params.integrations {
				appA := v.Self.Name
				appB := v.Target.Name
				apps := []string{appA, appB}
				var direct []string
				if _, ok := params.highlights[appA]; ok {
					direct = append(direct, appA)
				}
				if _, ok := params.highlights[appB]; ok {
					direct = append(direct, appB)
				}
				if appA != appB && !sliceInArray(apps, callsDrawn) && !sliceInArray(apps, callsDrawn) {
					if direct != nil || indirectArrowColor != "none" {
						indirect := ""
						if direct == nil {
							indirect = " <<indirect>>"
						}
						fmt.Fprintf(&sb, "%s --> %s%s", VarManagerForComponent(visitor, appA, &sb, params.highlights), VarManagerForComponent(visitor, appB, &sb, params.highlights), indirect)
						fmt.Fprintln(&sb)
						callsDrawn = append(callsDrawn, apps)
					}
				}
			}
			for _, v := range params.apps {
				for _, mixin := range mod.Apps[v].GetMixin2() {
					mixinName := strings.Join(mixin.Name.Part, " :: ")
					fmt.Fprintf(&sb, "%s <|.. %s", VarManagerForComponent(visitor, mixinName, &sb, params.highlights), VarManagerForComponent(visitor, v, &sb, params.highlights))
					fmt.Fprintln(&sb)
				}
			}
		}

		return sb.String()
	}
}

func sliceInArray(a []string, list [][]string) bool {
	if list == nil {
		return false
	}
	for _, b := range list {
		for i := range b {
			if a[i] != b[i] {
				return false
			}
		}
	}
	return true
}

func stringInSlice(a string, list []string) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}

func deleteDuplicates(input []string) []string {
	cleaned := []string{}
	for _, value := range input {

		if !stringInSlice(value, cleaned) {
			cleaned = append(cleaned, value)
		}
	}
	return cleaned
}

func getMapKeys(mymap map[string]*sysl.Attribute) []string {
	keys := make([]string, 0, len(mymap))
	for k := range mymap {
		keys = append(keys, k)
	}
	return keys
}

func makeCalls(statements []*sysl.Statement, calls []*sysl.Call) {
	for _, stat := range statements {
		switch c := stat.GetStmt().(type) {
		case *sysl.Statement_Call:
			calls = append(calls, c.Call)
		case *sysl.Statement_Action:
			continue
		case *sysl.Statement_Cond:
			makeCalls(c.Cond.GetStmt(), calls)
		case *sysl.Statement_Loop:
			makeCalls(c.Loop.GetStmt(), calls)
		case *sysl.Statement_LoopN:
			makeCalls(c.LoopN.GetStmt(), calls)
		case *sysl.Statement_Foreach:
			makeCalls(c.Foreach.GetStmt(), calls)
		case *sysl.Statement_Group:
			makeCalls(c.Group.GetStmt(), calls)
		case *sysl.Statement_Alt:
			for _, choice := range c.Alt.GetChoice() {
				makeCalls(choice.GetStmt(), calls)
			}
		case *sysl.Statement_Ret:
			continue
		default:
			panic("No statement!")
		}
	}
}
